Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -50,6 +50,7 @@
 #include <ctype.h>
 #include <pthread.h>
 #include <numa.h>
+#include <stdatomic.h>
 
 #include <arpa/inet.h>
 #include <sys/socket.h>
@@ -253,6 +254,15 @@ struct buf;
 
 typedef void receive_callback(struct buf *);
 
+
+/*
+ * Channel data stucture,
+ *
+ * Channels may be associated with a core on which a busyloop runs.
+ *
+ * Therefore changes to variables may only be made from code
+ * running on that core if multithreading is active.
+ */
 struct rdma_channel {
 	struct i2r_interface *i;	/* The network interface of this channel */
 	struct core_info *core;		/* Core the channel is on or NULL if comp_events is used */
@@ -308,6 +318,7 @@ struct endpoint {
 };
 
 static struct i2r_interface {
+	/* Not changed when multithreading */
 	struct ibv_context *context;		/* Not for RDMA CM use */
 	struct rdma_event_channel *rdma_events;
 	struct rdma_channel *multicast;
@@ -335,11 +346,22 @@ static struct i2r_interface {
 	struct ibv_port_attr port_attr;
 	int iges;
 	struct ibv_gid_entry ige[MAX_GID];
+
+	/* The following may be updated in a multithreaded environment
+	 * from the multicast thread running for each interface.
+ 	 *
+         * Serialization is required but we generally are a bit loose
+	 * by allowing read access without locks.
+         */
 	struct hash *ru_hash;
 	struct fifo resolve_queue;		/* List of send buffers with unresolved addresses */
 	struct hash *ep;			/* Hash of all endpoints reachable here */
 	struct hash *ip_to_ep;			/* Hash based on IP address */
+
+	/* PGM information:  Only updated from the multicast channel core */
 	unsigned nr_tsi;
+	struct hash *pgm_tsi_hash;
+	struct hash *pgm_record_hash;
 } i2r[NR_INTERFACES];
 
 /*
@@ -566,9 +588,14 @@ enum mc_status { MC_OFF, MC_JOINING, MC_
 const char *mc_text[NR_MC_STATUS] = { "Inactive", "Joining", "Joined", "Error" };
 
 /* A multicast group.
+ *
  * ah_info points to multicast address and QP number in use
  * for the stream. There are no "ports" unless they are
  * embedded in the GID (like done by CLLM).
+ *
+ * Multicast groups are setup before we enter multithreaded mode
+ * However, the state of joins etc may change in multithreaded
+ * mode. Access to that status information requires some care.
  */
 static struct mc {
 	struct in_addr addr;
@@ -899,6 +926,9 @@ static void __free_buffer(struct buf *bu
 #ifdef DEBUG
 	memset(buf->raw, 0, DATA_SIZE);
 #endif
+	if (buf->free)
+		abort();
+
 	buf->free = true;
 	buf->next = nextbuffer;
 	nextbuffer = buf;
@@ -928,11 +958,9 @@ static void get_buf(struct buf *buf)
 
 static void put_buf(struct buf *buf)
 {
-	unsigned count;
-
 	lock();
-	count = --buf->refcount;
-	if (count) {
+	buf->refcount--;
+	if (buf->refcount) {
 		unlock();
 		return;
 	}
@@ -1002,10 +1030,12 @@ static struct buf *alloc_buffer(struct r
 	buf = nextbuffer;
 
 	if (buf) {
+		if (!buf->free)
+			abort();
 		nextbuffer = buf->next;
 		buf->free = false;
+		buf->c = c;
 	}
-	buf->c = c;
 	unlock();
 
 #ifdef DEBUG
@@ -2254,7 +2284,6 @@ static void handle_rdma_event(void *priv
 					m->status[in] = MC_ERROR;
 					break;
 				}
-				m->status[in] = MC_JOINED;
 
 				/* Things actually work if both multicast groups are joined */
 				if (!bridging || m->status[in ^ 1] == MC_JOINED)
@@ -2266,6 +2295,7 @@ static void handle_rdma_event(void *priv
 					param->ah_attr.sl,
 					i->text);
 				st(i->multicast, join_success);
+				m->status[in] = MC_JOINED;
 			}
 			break;
 
@@ -2542,9 +2572,13 @@ static int send_to(struct rdma_channel *
 	struct ibv_sge sge;
 	int ret;
 
-	if (!ai->ah)
-		abort();	/* Send without a route */
 
+	if (!ai->ah) {
+		logg(LOG_WARNING, "send_to: %s AH == NULL\n", c->text);
+		return EIO;
+	}
+
+	get_buf(buf);
 	buf->c = c;	/* Change ownership to sending channel */
 	buf->w = NULL;
 
@@ -2847,13 +2881,14 @@ struct pgm_record {
 	unsigned len;			/* Length of the message */
 };
 
-struct hash *pgm_tsi_hash;
-struct hash *pgm_record_hash;
-
 static void init_pgm_streams(void)
 {
-	pgm_tsi_hash = hash_create(0, sizeof(struct pgm_tsi));
-	pgm_record_hash = hash_create(0, sizeof(struct pgm_tsi) + sizeof(uint32_t));
+	struct i2r_interface *i;
+
+	for(i = i2r; i < i2r + NR_INTERFACES; i++) {
+		i->pgm_tsi_hash = hash_create(0, sizeof(struct pgm_tsi));
+		i->pgm_record_hash = hash_create(0, sizeof(struct pgm_tsi) + sizeof(uint32_t));
+	}
 }
 
 static void format_tsi(char *b, struct pgm_tsi *tsi)
@@ -2867,6 +2902,7 @@ static void format_tsi(char *b, struct p
 
 static bool add_record(struct buf *buf, struct pgm_tsi *tsi, uint32_t sqn, void *start, unsigned len)
 {
+	struct i2r_interface *i = buf->c->i;
 	struct pgm_record *r = calloc(1, sizeof(struct pgm_record));
 	struct pgm_record *q;
 
@@ -2877,22 +2913,22 @@ static bool add_record(struct buf *buf,
 	r->len = len;
 
 	lock();
-	if ((q = hash_find(pgm_record_hash, &r))) {
+	if ((q = hash_find(i->pgm_record_hash, &r))) {
 		unlock();
 		return false;
 	} else {
 		__get_buf(buf);
-		hash_add(pgm_record_hash, r);
+		hash_add(i->pgm_record_hash, r);
 		unlock();
 		return true;
 	}
 }
 
-static struct pgm_record *find_record(struct pgm_tsi *tsi, uint32_t sqn)
+static struct pgm_record *find_record(struct i2r_interface *i, struct pgm_tsi *tsi, uint32_t sqn)
 {
 	struct pgm_record f = { .tsi = *tsi, .sqn = sqn };
 
-	return hash_find(pgm_record_hash, &f);
+	return hash_find(i->pgm_record_hash, &f);
 }
 
 /* Forwarded packet if ib2roce behaves like a DLR */
@@ -2943,7 +2979,7 @@ static bool pgm_process(struct rdma_chan
 	tsi.dport = ntohs(header.pgm.pgm_dport);
 	format_tsi(text, &tsi);
 
-	s = hash_find(pgm_tsi_hash, &tsi);
+	s = hash_find(i->pgm_tsi_hash, &tsi);
 
 	switch (header.pgm.pgm_type) {
 		case PGM_SPM:		/* Multicast downstream */
@@ -2980,13 +3016,13 @@ static bool pgm_process(struct rdma_chan
 
 			if (!s) {
 				lock();
-				s = hash_find(pgm_tsi_hash, &tsi);
+				s = hash_find(i->pgm_tsi_hash, &tsi);
 				if (!s) {
 					s = calloc(1, sizeof(struct pgm_stream));
 					s->tsi = tsi;
 					s->i = i;
 					strcpy(s->text, text);
-					hash_add(pgm_tsi_hash, s);
+					hash_add(i->pgm_tsi_hash, s);
 
 					/* First message on new stream */
 					s->last_seq = sqn - 1;
@@ -3019,7 +3055,7 @@ static bool pgm_process(struct rdma_chan
 				break;
 			}
 
-			if (sqn < s->last && find_record(&tsi, sqn)) {
+			if (sqn < s->last && find_record(i, &tsi, sqn)) {
 				st(c, pgm_dup);
 				ret = false;
 				logg(LOG_NOTICE, "%s: Repeated data in Window SQN=%d\n", s->text, sqn);
@@ -3053,7 +3089,7 @@ static bool pgm_process(struct rdma_chan
 				} else {
 					/* We just filled up in a missing piece check how long our consistent history goes now */
 					while (s->last_seq < s->last) {
-						struct pgm_record *r = find_record(&tsi, s->last_seq + 1);
+						struct pgm_record *r = find_record(i, &tsi, s->last_seq + 1);
 
 						if (r) {
 							logg(LOG_NOTICE, "Found earlier record %d\n", s->last_seq + 1);
@@ -3180,7 +3216,7 @@ static bool pgm_process(struct rdma_chan
 					logg(LOG_NOTICE, "%s: End of Stream TSI %s\n", i->text, text);
 					if (s) {
 						/* Remove all records */
-						hash_del(pgm_tsi_hash, &tsi);
+						hash_del(i->pgm_tsi_hash, &tsi);
 						free(s);
 						i->nr_tsi--;
 						s = NULL;
@@ -3545,8 +3581,14 @@ static void receive_multicast(struct buf
 	int ret;
 	struct pgm_header pgm;
 
+	if (!buf->refcount)
+		abort();
+
 	learn_source_address(buf);
 
+	if (!buf->refcount)
+		abort();
+
 	if (!buf->grh_valid) {
 		logg(LOG_WARNING, "No GRH on %s. Packet discarded: %s\n",
 			c->text, payload_dump(buf->cur));
@@ -3631,11 +3673,19 @@ static void receive_multicast(struct buf
 		}
 	}
 
+	if (m->status[INFINIBAND] != MC_JOINED || m->status[ROCE] != MC_JOINED) {
+		logg(LOG_NOTICE, "%s: Packet received on %s but MC Joins not completed\n", c->text, m->text);
+		return;
+	}
+
 	if (m->beacon) {
 		beacon_received(buf);
 		return;
 	}
 
+	if (!buf->refcount)
+		abort();
+
 	if (pgm_mode != pgm_none) {
 		if (!pgm_process(c, m, buf))
 			return;
