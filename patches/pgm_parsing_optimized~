Index: rdma-core/ib2roce/pgm.c
===================================================================
--- rdma-core.orig/ib2roce/pgm.c
+++ rdma-core/ib2roce/pgm.c
@@ -93,6 +93,106 @@ struct pgm_record {
 	unsigned len;			/* Length of the message */
 };
 
+#define MAX_PGM_TYPE (PGM_ACK + 1)
+#define PGM_TYPE_MASK (PGM_OPT_VAR_PKTLEN -1)
+#define MAX_PGM_OPT PGM_OPT_PGMCC_FEEDBACK
+
+/* There are 3 categories of pgm_data frames and one invalid. Encode them in a 64 bit integer */
+#define PGM_CAT_SHIFT 16
+#define PGM_CAT_MAX 3
+
+enum cat_type { cat_invalid, cat_spm, cat_data, cat_nak };
+
+/* This mapping only works for IPv4 */
+static const uint64_t cat_sizes =
+	(sizeof(struct pgm_spm) << PGM_CAT_SHIFT) +
+	(sizeof(struct pgm_data) << (2 * PGM_CAT_SHIFT)) +
+	(sizeof(struct pgm_nak) << (3 * PGM_CAT_SHIFT));
+
+/* Mapping of PGM_TYPES to categories */
+
+/* 2 bits required for each entry in type_to_cat */
+#define PGM_TYPE_SHIFT 2
+
+static const uint64_t type_to_cat = {
+	cat_spm +					/* PGM_SPM	   = 0x00 */
+        (cat_data << (4 * PGM_TYPE_SHIFT)) +		/* PGM_ODATA       = 0x04 */
+        (cat_data << (5 * PGM_TYPE_SHIFT)) +		/* PGM_RDATA       = 0x05 */
+        (cat_nak << (8 * PGM_TYPE_SHIFT)) +		/* PGM_NAK         = 0x08 */
+        (cat_nak << (9 * PGM_TYPE_SHIFT)) +		/* PGM_NNAK        = 0x09 */
+        (cat_nak << (10 * PGM_TYPE_SHIFT)) +		/* PGM_NCF         = 0x0a */
+        (cat_nak << (13 * PGM_TYPE_SHIFT))		/* PGM_ACK         = 0x0d */
+};
+
+/*
+ * Parse the options following the PGM header.
+ *
+ * opt is an array indexed by the option type pointing to the data associated with that option.
+ *
+ * The function returns a pointer at the end of options where the data would start. It returns
+ * NULL if the pgm_type is invalid or the options consistency check fails.
+ *
+ */
+static uint8_t *pgm_opt_parse(struct pgm_header *h, uint16_t *opt_offset)
+{
+	uint8_t *a;
+	uint8_t *opt_start;
+	uint8_t *pgm_start = (uint8_t *)h;
+	struct pgm_opt_header *poh;
+	uint16_t *v;
+	unsigned total_opt_length;
+	unsigned n;
+	enum cat_type c;
+
+	memset(opt_offset, 0, sizeof(uint16_t) * MAX_PGM_OPT);
+
+	n = h->pgm_type & PGM_TYPE_MASK;
+
+	/* Extract category from type_to_cat */
+	c = (type_to_cat >> (n * PGM_TYPE_SHIFT)) & ((1 << PGM_TYPE_SHIFT) -1);
+
+	if (n >= MAX_PGM_TYPE || c == cat_invalid)
+		/* Unsupported PGM type */
+		return NULL;
+
+	/* move to the beginning of the options. Extracts size for category from cat_sizes */
+	a = pgm_start + sizeof(struct pgm_header) + ((cat_sizes >> (c * PGM_CAT_SHIFT)) & ((1 << PGM_CAT_SHIFT) -1));
+
+	if (!(h->pgm_type & PGM_OPT_PRESENT))
+		/* No options available */
+		return a;
+
+	opt_start = a;
+
+	do {
+		poh = (struct pgm_opt_header *)a;
+		n = poh->opt_type & PGM_OPT_MASK;
+
+		/*
+		 * RFC3208 allows ignoring options that are unknown.
+		 * We just skip over unknown data
+		 */
+		if (n <= MAX_PGM_OPT)
+			opt_offset[n] = (a + sizeof(struct pgm_opt_header)) - pgm_start;
+
+		a += poh->opt_length;
+
+	} while (!(poh->opt_type & PGM_OPT_END));
+
+	v = (uint16_t *)(opt_offset[PGM_OPT_LENGTH] + pgm_start);
+
+	if (!v)
+		/* No OPT_LENGTH specified */
+		return a;
+
+	total_opt_length = ntohs(*v);
+	if (a - opt_start != total_opt_length)
+		/* Corrupted option list */
+		return NULL;
+
+	return a;
+}
+
 static void init_pgm_streams(void)
 {
 	struct i2r_interface *i;
@@ -160,8 +260,6 @@ bool pgm_process(struct rdma_channel *c,
 	struct pgm_stream *s;
 	uint32_t sqn;
 	uint32_t tdsu;
-	uint16_t total_opt_length = 0;
-	uint8_t *options_start;
 	union {
 		struct pgm_header pgm;
 		struct {
@@ -169,40 +267,45 @@ bool pgm_process(struct rdma_channel *c,
 			struct in_addr addr;
 			uint16_t port;
 		};
-	} header;
+	} *header;
 	char text[60];
 	struct pgm_spm spm;
 	struct pgm_data data;
 	struct pgm_nak nak;
-#if 0
-	struct pgm_poll poll;
-	struct pgm_polr polr;
-#endif
 	struct pgm_ack ack;
 	int ret = true;
+	uint8_t *a;
+	uint16_t opt_offset[MAX_PGM_OPT];
 
-	PULL(buf, header);
+	header = (void *)buf->cur;
 
 	/* Verify if pgm message originated from our subnet */
-	if (!valid_addr(c->i, header.addr)) {
-		logg(LOG_INFO, "Discarded PGM packet originating from %s is from outside our subnet %s\n", inet_ntoa(header.addr), c->i->text);
-		return false;
-	}
+//	if (!valid_addr(c->i, header->addr)) {
+//		logg(LOG_INFO, "Discarded PGM packet originating from %s is from outside our subnet %s\n", inet_ntoa(header->addr), c->i->text);
+//		return false;
+//	}
 
 	if (pgm_mode < pgm_passthrough)
 		return true;
 
-	tdsu = ntohs(header.pgm.pgm_tsdu_length);
+	tdsu = ntohs(header->pgm.pgm_tsdu_length);
 
 	tsi.mcgroup = m->addr;
-	memcpy(&tsi.sender, header.pgm.pgm_gsi, sizeof(struct in_addr));
-	tsi.sport = ntohs(header.pgm.pgm_sport);
-	tsi.dport = ntohs(header.pgm.pgm_dport);
+	memcpy(&tsi.sender, header->pgm.pgm_gsi, sizeof(struct in_addr));
+	tsi.sport = ntohs(header->pgm.pgm_sport);
+	tsi.dport = ntohs(header->pgm.pgm_dport);
 	format_tsi(text, &tsi);
 
 	s = hash_find(i->pgm_tsi_hash, &tsi);
 
-	switch (header.pgm.pgm_type) {
+	a = pgm_opt_parse(&header->pgm, opt_offset);
+	if (!a) {
+		logg(LOG_NOTICE, "%s: Invalid PGM type/Options %x. Packet Skipped.\n", text, header->pgm.pgm_type);
+		return false;
+	}
+
+	buf->cur += sizeof(struct pgm_header);
+	switch (header->pgm.pgm_type & PGM_TYPE_MASK) {
 		case PGM_SPM:		/* Multicast downstream */
 			PULL(buf, spm);
 			if (!s)
@@ -220,17 +323,12 @@ bool pgm_process(struct rdma_channel *c,
 			}
 			break;
 
-/* 		These may not exist although described in the RFC. There is no definition of the spmr struct available
-		case PGM_SPMR:		Unicast upstream
-			PULL(buf, spmr);
-			break;
-*/
 		case PGM_ODATA:		/* Multicast downstream */
 		case PGM_RDATA:		/* Multicast downstream */
 			PULL(buf, data);
 
 			logg(LOG_DEBUG, "%s: %cDATA SQN=%d TRAIL=%d\n", text,
-				header.pgm.pgm_type == PGM_RDATA ? 'R' : 'O', ntohl(data.data_sqn), ntohl(data.data_trail));
+				header->pgm.pgm_type == PGM_RDATA ? 'R' : 'O', ntohl(data.data_sqn), ntohl(data.data_trail));
 
 			sqn = ntohl(data.data_sqn);
 
@@ -256,7 +354,7 @@ bool pgm_process(struct rdma_channel *c,
 				unlock();
 			}
 
-			if (header.pgm.pgm_type == PGM_RDATA)
+			if (header->pgm.pgm_type == PGM_RDATA)
 				s->rdata++;
 			else
 				s->odata++;
@@ -292,7 +390,7 @@ bool pgm_process(struct rdma_channel *c,
 
 			if (pgm_mode <= pgm_passthrough) {
 
-				if (header.pgm.pgm_type == PGM_ODATA) {
+				if (header->pgm.pgm_type == PGM_ODATA) {
 					if (sqn != s->last +1)
 						logg(LOG_NOTICE, "%s: Sequence error SQN %d->SQN %d diff %d\n", s->text, s->last, sqn, sqn-s->last);
 					s->last = sqn;
@@ -356,18 +454,6 @@ bool pgm_process(struct rdma_channel *c,
 				inet_ntoa(nak.nak_grp_nla));
 			break;
 
-#if 0
-		/* Is POLL really used I do not know of a DLR */
-		case PGM_POLL:		/* DLR downstream multicast */
-			PULL(buf, poll);
-			logg(LOG_NOTICE, "%s: POLL\n", s->text);
-			break;
-
-		case PGM_POLR:		/* Unicast response upstream to DLR */
-			PULL(buf, polr);
-			logg(LOG_NOTICE, "%s: POLR\n", s->text);
-			break;
-#endif
 		/* Not RFC compliant but it seems to be used sometimes */
 		case PGM_ACK:		/* Unicast upstream */
 			PULL(buf, ack);
@@ -376,129 +462,9 @@ bool pgm_process(struct rdma_channel *c,
 			break;
 
 		default:
-			logg(LOG_NOTICE, "%s: Invalid PGM type=%x. Packet Skipped.\n", text, header.pgm.pgm_type);
 			break;
 	}
 
-	options_start = buf->cur;
-	if (header.pgm.pgm_options & 0x1) {
-		bool last = false;
-
-		do {
-			struct pgm_opt_header opt;
-			struct pgm_opt_length length;
-			struct pgm_opt_fragment fragment;
-			struct pgm_opt_nak_list nak_list;
-			struct pgm_opt_join join;
-			struct pgm_opt_redirect redirect;
-			struct pgm_opt_fin fin;
-			struct pgm_opt_syn syn;
-			struct pgm_opt_rst rst;
-			uint8_t *start_option = buf->cur;
-
-			PULL(buf, opt);
-
-			if (opt.opt_length == 0) {
-				logg(LOG_NOTICE, "Invalid option length zero\n");
-				break;
-			}
-
-			last = opt.opt_type & PGM_OPT_END;
-			switch (opt.opt_type & PGM_OPT_MASK) {
-				case PGM_OPT_LENGTH:
-					buf->cur = start_option;
-					PULL(buf, length);
-					total_opt_length = ntohs(length.opt_total_length);
-					break;
-				case PGM_OPT_FRAGMENT:
-					PULL(buf, fragment);
-					logg(LOG_INFO, "%s: OPT Fragment SQN=%x offset=%d len=%d\n", text,
-							ntohl(fragment.opt_sqn), ntohl(fragment.opt_frag_off), ntohl(fragment.opt_frag_len));
-					break;
-				case PGM_OPT_NAK_LIST:
-					PULL(buf, nak_list);
-					logg(LOG_INFO, "%s: OPT NAK list #%d\n", text, (opt.opt_length - 1) /4 );
-
-					break;
-				case PGM_OPT_JOIN:
-					PULL(buf, join);
-					logg(LOG_INFO, "%s: OPT Join MIN SQN=%d\n",
-								text, ntohl(join.opt_join_min));
-					break;
-				case PGM_OPT_REDIRECT:
-					PULL(buf, redirect);
-
-					logg(LOG_INFO, "%s: OPT Redirect NLA=%s\n", text, inet_ntoa(redirect.opt_nla));
-					break;
-
-				/* Not sure if these options are in use.  They are mostly not necessary (?) */
-				case PGM_OPT_SYN:
-					PULL(buf, syn);
-					logg(LOG_INFO, "%s: OPT SYN\n", text);
-					s->last_seq = sqn;
-					s->last = sqn;
-					s->oldest = sqn;
-					break;
-				case PGM_OPT_FIN:
-					PULL(buf, fin);
-					logg(LOG_NOTICE, "%s: End of Stream TSI %s\n", i->text, text);
-					if (s) {
-						/* Remove all records */
-						hash_del(i->pgm_tsi_hash, &tsi);
-						free(s);
-						i->nr_tsi--;
-						s = NULL;
-					}
-					break;
-				case PGM_OPT_RST:
-					PULL(buf, rst);
-					logg(LOG_NOTICE, "%s: OPT RST\n", text);
-					break;
-
-				case 0x21:
-				case 0x22:
-				case 0x23:
-				case 0x24:
-					break;
-
-				/* NAK Intervals */
-				case PGM_OPT_NAK_BO_IVL:
-				case PGM_OPT_NAK_BO_RNG:
-
-				/* NLA redirection */
-				case PGM_OPT_PATH_NLA:
-
-				/* Broken Multicast ??? */
-				case PGM_OPT_NBR_UNREACH:
-
-				case PGM_OPT_INVALID:
-
-				/* Congestion "Control" and avoidance. Traffic load feedback */
-				case PGM_OPT_CR:
-				case PGM_OPT_CRQST:
-
-				/* Forward Error correction.... How would this work ??? */
-				case PGM_OPT_PARITY_PRM:
-				case PGM_OPT_PARITY_GRP:
-				case PGM_OPT_CURR_TGSIZE:
-
-				/* Extensions by PGMCC */
-				case PGM_OPT_PGMCC_DATA:
-				case PGM_OPT_PGMCC_FEEDBACK:
-
-				default:
-					logg(LOG_NOTICE, "%s: Invalid PGM option=%x Option Skipped. D=%s\n",
-						text, opt.opt_type & PGM_OPT_MASK,
-						_hexbytes(start_option, opt.opt_length));
-					break;
-			}
-			buf->cur = start_option + opt.opt_length;
-		} while (!last);
-
-		if (total_opt_length != buf->cur - options_start)
-			logg(LOG_NOTICE, "%s: Option length mismatch. Expected %d but it is %ld\n", s->text, total_opt_length, buf->cur - options_start);
-	}
-
 	return ret;
 }
 
