Index: rdma-core/ib2roce/pgm.c
===================================================================
--- rdma-core.orig/ib2roce/pgm.c
+++ rdma-core/ib2roce/pgm.c
@@ -79,6 +79,9 @@ struct pgm_stream {
 	unsigned first_sqn, last_sqn;
 	unsigned sqn_seq_errs;
 	unsigned last_missed_sqn, last_missed_sqns;
+	uint64_t last_out_of_seq;
+	bool out_of_seq;
+	bool error;
 //	struct nak *nak;
 	char text[60];
 };
@@ -170,7 +173,6 @@ bool pgm_process(struct rdma_channel *c,
 			uint16_t port;
 		};
 	} header;
-	char text[60];
 	struct pgm_spm spm;
 	struct pgm_data data;
 	struct pgm_nak nak;
@@ -198,7 +200,6 @@ bool pgm_process(struct rdma_channel *c,
 	memcpy(&tsi.sender, header.pgm.pgm_gsi, sizeof(struct in_addr));
 	tsi.sport = ntohs(header.pgm.pgm_sport);
 	tsi.dport = ntohs(header.pgm.pgm_dport);
-	format_tsi(text, &tsi);
 
 	s = hash_find(i->pgm_tsi_hash, &tsi);
 
@@ -229,7 +230,7 @@ bool pgm_process(struct rdma_channel *c,
 		case PGM_RDATA:		/* Multicast downstream */
 			PULL(buf, data);
 
-			logg(LOG_DEBUG, "%s: %cDATA SQN=%d TRAIL=%d\n", text,
+			logg(LOG_DEBUG, "%s: %cDATA SQN=%d TRAIL=%d\n", s->text,
 				header.pgm.pgm_type == PGM_RDATA ? 'R' : 'O', ntohl(data.data_sqn), ntohl(data.data_trail));
 
 			sqn = ntohl(data.data_sqn);
@@ -241,7 +242,7 @@ bool pgm_process(struct rdma_channel *c,
 					s = calloc(1, sizeof(struct pgm_stream));
 					s->tsi = tsi;
 					s->i = i;
-					strcpy(s->text, text);
+					format_tsi(s->text, &tsi);
 					hash_add(i->pgm_tsi_hash, s);
 
 					/* First message on new stream */
@@ -264,7 +265,11 @@ bool pgm_process(struct rdma_channel *c,
 			if (sqn < s->last_seq) {
 				s->dup++;
 				ret = false;
-				logg(LOG_NOTICE, "%s: Repeated data out of Window SQN=%u < last=%u\n", s->text, sqn, s->last_seq);
+				if  (!s->out_of_seq) {
+					logg(LOG_NOTICE, "%s: Repeated data out of Window SQN=%u < last=%u\n", s->text, sqn, s->last_seq);
+					s->out_of_seq = true;
+				}
+
 				break;
 			}
 
@@ -352,7 +357,7 @@ bool pgm_process(struct rdma_channel *c,
 			PULL(buf, nak);
 			s->nak++;
 			logg(LOG_NOTICE, "%s: NAK/NCF/NNAK SQN=%x NLA=%s GRP_NLA=%s\n",
-				text, nak.nak_sqn, inet_ntoa(nak.nak_src_nla),
+				s->text, nak.nak_sqn, inet_ntoa(nak.nak_src_nla),
 				inet_ntoa(nak.nak_grp_nla));
 			break;
 
@@ -372,11 +377,11 @@ bool pgm_process(struct rdma_channel *c,
 		case PGM_ACK:		/* Unicast upstream */
 			PULL(buf, ack);
 			s->ack++;
-			logg(LOG_NOTICE, "%s: ACK RX_MAX=%x BITMAP=%x\n", text, ntohl(ack.ack_rx_max), ack.ack_bitmap);
+			logg(LOG_NOTICE, "%s: ACK RX_MAX=%x BITMAP=%x\n", s->text, ntohl(ack.ack_rx_max), ack.ack_bitmap);
 			break;
 
 		default:
-			logg(LOG_NOTICE, "%s: Invalid PGM type=%x. Packet Skipped.\n", text, header.pgm.pgm_type);
+			logg(LOG_NOTICE, "%s: Invalid PGM type=%x. Packet Skipped.\n", s->text, header.pgm.pgm_type);
 			break;
 	}
 
@@ -412,36 +417,36 @@ bool pgm_process(struct rdma_channel *c,
 					break;
 				case PGM_OPT_FRAGMENT:
 					PULL(buf, fragment);
-					logg(LOG_INFO, "%s: OPT Fragment SQN=%x offset=%d len=%d\n", text,
+					logg(LOG_INFO, "%s: OPT Fragment SQN=%x offset=%d len=%d\n", s->text,
 							ntohl(fragment.opt_sqn), ntohl(fragment.opt_frag_off), ntohl(fragment.opt_frag_len));
 					break;
 				case PGM_OPT_NAK_LIST:
 					PULL(buf, nak_list);
-					logg(LOG_INFO, "%s: OPT NAK list #%d\n", text, (opt.opt_length - 1) /4 );
+					logg(LOG_INFO, "%s: OPT NAK list #%d\n", s->text, (opt.opt_length - 1) /4 );
 
 					break;
 				case PGM_OPT_JOIN:
 					PULL(buf, join);
 					logg(LOG_INFO, "%s: OPT Join MIN SQN=%d\n",
-								text, ntohl(join.opt_join_min));
+								s->text, ntohl(join.opt_join_min));
 					break;
 				case PGM_OPT_REDIRECT:
 					PULL(buf, redirect);
 
-					logg(LOG_INFO, "%s: OPT Redirect NLA=%s\n", text, inet_ntoa(redirect.opt_nla));
+					logg(LOG_INFO, "%s: OPT Redirect NLA=%s\n", s->text, inet_ntoa(redirect.opt_nla));
 					break;
 
 				/* Not sure if these options are in use.  They are mostly not necessary (?) */
 				case PGM_OPT_SYN:
 					PULL(buf, syn);
-					logg(LOG_INFO, "%s: OPT SYN\n", text);
+					logg(LOG_INFO, "%s: OPT SYN\n", s->text);
 					s->last_seq = sqn;
 					s->last = sqn;
 					s->oldest = sqn;
 					break;
 				case PGM_OPT_FIN:
 					PULL(buf, fin);
-					logg(LOG_NOTICE, "%s: End of Stream TSI %s\n", i->text, text);
+					logg(LOG_NOTICE, "%s: End of Stream TSI %s\n", i->text, s->text);
 					if (s) {
 						/* Remove all records */
 						hash_del(i->pgm_tsi_hash, &tsi);
@@ -452,7 +457,7 @@ bool pgm_process(struct rdma_channel *c,
 					break;
 				case PGM_OPT_RST:
 					PULL(buf, rst);
-					logg(LOG_NOTICE, "%s: OPT RST\n", text);
+					logg(LOG_NOTICE, "%s: OPT RST\n", s->text);
 					break;
 
 				case 0x21:
@@ -488,7 +493,7 @@ bool pgm_process(struct rdma_channel *c,
 
 				default:
 					logg(LOG_NOTICE, "%s: Invalid PGM option=%x Option Skipped. D=%s\n",
-						text, opt.opt_type & PGM_OPT_MASK,
+						s->text, opt.opt_type & PGM_OPT_MASK,
 						_hexbytes(start_option, opt.opt_length));
 					break;
 			}
