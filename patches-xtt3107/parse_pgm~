Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -231,6 +231,7 @@ static const char *interfaces_text[NR_IN
 enum stats { packets_received, packets_sent, packets_bridged, packets_invalid,
 		join_requests, join_failure, join_success,
 		leave_requests,
+		pgm_dup, pgm_odata, pgm_rdata, pgm_spm, pgm_nak, pgm_ack,
 		nr_stats
 };
 
@@ -339,6 +340,7 @@ static struct i2r_interface {
 	struct fifo resolve_queue;		/* List of send buffers with unresolved addresses */
 	struct hash *ep;			/* Hash of all endpoints reachable here */
 	struct hash *ip_to_ep;			/* Hash based on IP address */
+	unsigned nr_tsi;
 } i2r[NR_INTERFACES];
 
 /*
@@ -2798,6 +2800,444 @@ static unsigned int remove_forwards(stru
 	return n;
 }
 
+/* 
+ * PGM RFC3208 Support
+ */
+
+enum pgm_mode { pgm_none, pgm_passthrough, pgm_dlr, pgm_resend };
+
+enum pgm_mode pgm_mode = pgm_passthrough;
+
+struct nak {
+	struct pgm_nak *next;
+	unsigned sqn;
+	bool nak_sent;
+	bool ncf_sent;
+	bool nnak_sent;
+};
+
+struct pgm_tsi {
+	struct in_addr mcgroup;
+	struct in_addr sender;
+	uint16_t dport;
+	uint16_t sport;
+};
+
+/* Stream information */
+struct pgm_stream {
+	struct pgm_tsi tsi;	
+	struct i2r_interface *i;	/* Interface of the source */
+	unsigned trail;			/* Sender trail */
+	unsigned lead;			/* Sender lead */
+
+	unsigned last;			/* Highest SQN received */
+	unsigned last_seq;		/* Last in sequence */
+	unsigned oldest;		/* The oldest message available locally */
+	struct nak *nak;
+	char text[60];
+};
+
+/* Records (ODATA/RDATA) in a stream */
+struct pgm_record {
+	struct pgm_tsi tsi;
+	uint32_t sqn;			/* Message ID  */
+	struct pgm_stream *stream;	
+	struct buf *buf;		/* Address of buffer */
+	void *start;			/* Beginning of ODATA/RDATA record */
+	unsigned len;			/* Length of the message */
+};
+
+struct hash *pgm_tsi_hash;
+struct hash *pgm_record_hash;
+
+static void init_pgm_streams(void)
+{
+	pgm_tsi_hash = hash_create(0, sizeof(struct pgm_tsi));
+	pgm_record_hash = hash_create(0, sizeof(struct pgm_tsi) + sizeof(uint32_t));
+}
+
+static void format_tsi(char *b, struct pgm_tsi *tsi)
+{
+	static char c[30];
+
+	strcpy(c, inet_ntoa(tsi->sender));
+
+	snprintf(b, 60, "%s:%d->%s:%d", c, ntohs(tsi->sport), inet_ntoa(tsi->mcgroup), ntohs(tsi->dport));
+}
+
+static bool add_record(struct buf *buf, struct pgm_tsi *tsi, uint32_t sqn, void *start, unsigned len)
+{
+	struct pgm_record *r = calloc(1, sizeof(struct pgm_record));
+	struct pgm_record *q;
+
+	r->tsi = *tsi;
+	r->sqn = sqn;
+	r->buf = buf;
+	r->start = start;
+	r->len = len;
+
+	lock();
+	if ((q = hash_find(pgm_record_hash, &r))) {
+		unlock();
+		return false;
+	} else {
+		__get_buf(buf);
+		hash_add(pgm_record_hash, r);
+		unlock();
+		return true;
+	}
+}
+
+static struct pgm_record *find_record(struct pgm_tsi *tsi, uint32_t sqn)
+{
+	struct pgm_record f = { .tsi = *tsi, .sqn = sqn };
+
+	return hash_find(pgm_record_hash, &f);
+}
+
+/* Forwarded packet if ib2roce behaves like a DLR */
+static void forward_packet(struct buf *buf, struct pgm_tsi *tsi, uint32_t sqn)
+{
+}
+
+/* Packet delivery in sequence */
+static void deliver_in_seq(struct buf *buf, struct pgm_tsi *tsi, uint32_t sqn)
+{
+}
+
+static bool pgm_process(struct rdma_channel *c, struct mc *m, struct buf *buf)
+{
+	struct i2r_interface *i = c->i;
+	struct pgm_tsi tsi;
+	struct pgm_stream *s;
+	uint32_t sqn;
+	uint32_t tdsu;
+	uint16_t total_opt_length = 0;
+	uint8_t *options_start;
+	union {
+		struct pgm_header pgm;
+		struct {
+			uint8_t skip[8];
+			struct in_addr addr;
+			uint16_t port;
+		};
+	} header;
+	char text[60];
+	struct pgm_spm spm;
+	struct pgm_data data;
+	struct pgm_nak nak;
+#if 0
+	struct pgm_poll poll;
+	struct pgm_polr polr;
+#endif
+	struct pgm_ack ack;
+	int ret = true;
+
+	PULL(buf, header);
+
+	tdsu = ntohs(header.pgm.pgm_tsdu_length);
+
+	tsi.mcgroup = m->addr;
+	memcpy(&tsi.sender, header.pgm.pgm_gsi, sizeof(struct in_addr));
+	tsi.sport = ntohs(header.pgm.pgm_sport);
+	tsi.dport = ntohs(header.pgm.pgm_dport);
+	format_tsi(text, &tsi);
+
+	s = hash_find(pgm_tsi_hash, &tsi);
+
+	switch (header.pgm.pgm_type) {
+		case PGM_SPM:		/* Multicast downstream */
+			PULL(buf, spm);
+			if (!s)
+				break;
+
+			st(c, pgm_spm);
+
+			s->trail = ntohl(spm.spm_trail);
+			s->lead = ntohl(spm.spm_lead);
+			if (pgm_mode <= pgm_passthrough)
+				break;
+
+			if (s->last_seq < s->lead) {
+				/* We are missing packets */
+			}
+			break;
+
+/* 		These may not exist although described in the RFC. There is no definition of the spmr struct available
+		case PGM_SPMR:		Unicast upstream
+			PULL(buf, spmr);
+			break;
+*/
+		case PGM_ODATA:		/* Multicast downstream */
+		case PGM_RDATA:		/* Multicast downstream */
+			PULL(buf, data);
+
+			if (log_packets > 1)
+				logg(LOG_NOTICE, "%s: %cDATA SQN=%d TRAIL=%d\n", text,
+					header.pgm.pgm_type == PGM_RDATA ? 'R' : 'O', ntohl(data.data_sqn), ntohl(data.data_trail));
+
+			sqn = ntohl(data.data_sqn);
+
+			if (!s) {
+				lock();
+				s = hash_find(pgm_tsi_hash, &tsi);
+				if (!s) {
+					s = calloc(1, sizeof(struct pgm_stream));
+					s->tsi = tsi;
+					s->i = i;
+					strcpy(s->text, text);
+					hash_add(pgm_tsi_hash, s);
+
+					/* First message on new stream */
+					s->last_seq = sqn - 1;
+					s->last = s->last_seq;
+					s->oldest = sqn;
+
+					i->nr_tsi++;
+
+					logg(LOG_NOTICE, "%s: New Stream TSI %s\n", i->text, s->text);
+				}
+				unlock();
+			}	
+
+			if (header.pgm.pgm_type == PGM_RDATA)
+				st(c, pgm_rdata);
+			else
+				st(c, pgm_odata);
+
+			if (sqn < s->last_seq) {
+				st(c, pgm_dup);
+				ret = false;
+				logg(LOG_NOTICE, "%s: Repeated data out of Window\n", s->text);
+				break;
+			}
+
+			if (sqn == s->last) {
+				st(c, pgm_dup);
+				ret = false;
+				logg(LOG_NOTICE, "%s: Sender is duplicating traffic %d\n", s->text, sqn);
+				break;
+			}
+
+			if (sqn < s->last && find_record(&tsi, sqn)) {
+				st(c, pgm_dup);
+				ret = false;
+				logg(LOG_NOTICE, "%s: Repeated data in Window SQN=%d\n", s->text, sqn);
+				break;
+			}
+
+			/* Move trail/lead */
+			if (ntohl(data.data_trail) > s->trail)
+				s->trail = ntohl(data.data_trail);
+
+			if (sqn > s->lead)
+				s->lead = sqn;
+
+			if (pgm_mode <= pgm_passthrough)
+				break;
+
+			/* This is either the next data or missing data */
+
+			if (!add_record(buf, &tsi, sqn, buf->cur, tdsu))
+				abort();
+
+			if (sqn == s->last_seq + 1) {
+				/* The next packet that we need ! */
+				s->last_seq = sqn;
+				forward_packet(buf, &tsi, sqn);
+				deliver_in_seq(buf, &tsi, sqn);
+
+				if (sqn == s->last + 1) {
+					/* Stream without pending holes in the sequence */
+					s->last = sqn;
+				} else {
+					/* We just filled up in a missing piece check how long our consistent history goes now */
+					while (s->last_seq < s->last) {
+						struct pgm_record *r = find_record(&tsi, s->last_seq + 1);
+
+						if (r) {
+							logg(LOG_NOTICE, "Found earlier record %d\n", s->last_seq + 1);
+
+							deliver_in_seq(r->buf, &tsi, s->last_seq + 1);
+							s->last_seq++;
+						} else
+							break;
+					}
+					/* If this was RDATA and there still is a hole then send NAK */
+				}
+			} else {
+				logg(LOG_NOTICE, "Out of sequence sqn=%d last_seq=%d s->last=%d\n", sqn, s->last_seq, s->last);
+				forward_packet(buf, &tsi, sqn);
+				s->last = sqn;
+				/* We have opened up some hole between s->last_seq and s->last. Could send NAK */
+
+				/* s->last_seq ... s->last -1 is missing at this point */
+
+				if (s->last_seq < s->trail) {
+					logg(LOG_ERR, "Unrecoverable Dataloss !\n");
+				} else {
+					logg(LOG_NOTICE, "Nak Processing not implemented yet\n");
+				}
+			}
+
+			break;
+
+		case PGM_NAK:		/* Unicast upstream */
+		case PGM_NCF:		/* Multicast downstream */
+		case PGM_NNAK:		/* Unicast upstream DLR ->source */
+			PULL(buf, nak);
+			st(c, pgm_nak);
+			logg(LOG_NOTICE, "%s: NAK/NCF/NNAK SQN=%x NLA=%s GRP_NLA=%s\n",
+				text, nak.nak_sqn, inet_ntoa(nak.nak_src_nla),
+				inet_ntoa(nak.nak_grp_nla));
+			break;
+
+#if 0
+		/* Is POLL really used I do not know of a DLR */
+		case PGM_POLL:		/* DLR downstream multicast */
+			PULL(buf, poll);
+			logg(LOG_NOTICE, "%s: POLL\n", s->text);
+			break;
+
+		case PGM_POLR:		/* Unicast response upstream to DLR */
+			PULL(buf, polr);
+			logg(LOG_NOTICE, "%s: POLR\n", s->text);
+			break;
+#endif
+		/* Not RFC compliant but it seems to be used sometimes */
+		case PGM_ACK:		/* Unicast upstream */
+			PULL(buf, ack);
+			st(c, pgm_ack);
+			logg(LOG_NOTICE, "%s: ACK RX_MAX=%x BITMAP=%x\n", text, ntohl(ack.ack_rx_max), ack.ack_bitmap);
+			break;
+
+		default:
+			logg(LOG_NOTICE, "%s: Invalid PGM type=%x. Packet Skipped.\n", text, header.pgm.pgm_type);
+			break;
+	}
+
+	options_start = buf->cur;
+	if (header.pgm.pgm_options & 0x1) {
+		bool last = false;
+
+		do {
+			struct pgm_opt_header opt;
+			struct pgm_opt_length length;
+			struct pgm_opt_fragment fragment;
+			struct pgm_opt_nak_list nak_list;
+			struct pgm_opt_join join;
+			struct pgm_opt_redirect redirect;
+			struct pgm_opt_fin fin;
+			struct pgm_opt_syn syn;
+			struct pgm_opt_rst rst;
+			uint8_t *start_option = buf->cur;
+
+			PULL(buf, opt);
+
+			if (opt.opt_length == 0) {
+				logg(LOG_NOTICE, "Invalid option length zero\n");
+				break;
+			}
+
+			last = opt.opt_type & PGM_OPT_END;
+			switch (opt.opt_type & PGM_OPT_MASK) {
+				case PGM_OPT_LENGTH:
+					buf->cur = start_option;
+					PULL(buf, length);
+					total_opt_length = ntohs(length.opt_total_length);
+					break;
+				case PGM_OPT_FRAGMENT:
+					PULL(buf, fragment);
+//					if (log_packets > 1)
+						logg(LOG_NOTICE, "%s: OPT Fragment SQN=%x offset=%d len=%d\n", text,
+							ntohl(fragment.opt_sqn), ntohl(fragment.opt_frag_off), ntohl(fragment.opt_frag_len));
+					break;
+				case PGM_OPT_NAK_LIST:
+					PULL(buf, nak_list);
+//					if (log_packets > 1)
+						logg(LOG_NOTICE, "%s: OPT NAK list #%d\n", text, (opt.opt_length - 1) /4 );
+
+					break;
+				case PGM_OPT_JOIN:
+					PULL(buf, join);
+					if (log_packets > 1)
+						logg(LOG_NOTICE, "%s: OPT Join MIN SQN=%d\n",
+								text, ntohl(join.opt_join_min));
+					break;
+				case PGM_OPT_REDIRECT:
+					PULL(buf, redirect);
+
+					logg(LOG_NOTICE, "%s: OPT Redirect NLA=%s\n", text, inet_ntoa(redirect.opt_nla));
+					break;
+
+				/* Not sure if these options are in use.  They are mostly not necessary (?) */
+				case PGM_OPT_SYN:
+					PULL(buf, syn);
+					logg(LOG_NOTICE, "%s: OPT SYN\n", text);
+					break;
+				case PGM_OPT_FIN:
+					PULL(buf, fin);
+					logg(LOG_NOTICE, "%s: End of Stream TSI %s\n", i->text, text);
+					if (s) {
+						/* Remove all records */
+						hash_del(pgm_tsi_hash, &tsi);
+						free(s);
+						i->nr_tsi--;
+						s = NULL;
+					}
+					break;
+				case PGM_OPT_RST:
+					PULL(buf, rst);
+					logg(LOG_NOTICE, "%s: OPT RST\n", text);
+					break;
+
+				case 0x21:
+				case 0x22:
+				case 0x23:
+				case 0x24:
+					break;
+
+				/* NAK Intervals */
+				case PGM_OPT_NAK_BO_IVL:
+				case PGM_OPT_NAK_BO_RNG:
+
+				/* NLA redirection */
+				case PGM_OPT_PATH_NLA:
+
+				/* Broken Multicast ??? */
+				case PGM_OPT_NBR_UNREACH:
+
+				case PGM_OPT_INVALID:
+
+				/* Congestion "Control" and avoidance. Traffic load feedback */
+				case PGM_OPT_CR:
+				case PGM_OPT_CRQST:
+
+				/* Forward Error correction.... How would this work ??? */
+				case PGM_OPT_PARITY_PRM:
+				case PGM_OPT_PARITY_GRP:
+				case PGM_OPT_CURR_TGSIZE:
+
+				/* Extensions by PGMCC */
+				case PGM_OPT_PGMCC_DATA:
+				case PGM_OPT_PGMCC_FEEDBACK:
+
+				default: 
+					logg(LOG_NOTICE, "%s: Invalid PGM option=%x Option Skipped. D=%s\n",
+						text, opt.opt_type & PGM_OPT_MASK,
+						_hexbytes(start_option, opt.opt_length)); 
+					break;
+			}
+			buf->cur = start_option + opt.opt_length;
+		} while (!last);
+
+		if (total_opt_length != buf->cur - options_start)
+			logg(LOG_NOTICE, "%s: Option length mismatch. Expected %d but it is %ld\n", s->text, total_opt_length, buf->cur - options_start);
+	}
+
+	return ret;
+}
+
 #if 0
 /*
  * Update the forwarder if the source point changes
@@ -3196,6 +3636,11 @@ static void receive_multicast(struct buf
 		return;
 	}
 
+	if (pgm_mode != pgm_none) {
+		if (!pgm_process(c, m, buf))
+			return;
+	}
+
 	if (!bridging)
 		return;
 
@@ -4568,14 +5015,27 @@ static void logging(void)
 	n = 0;
 	for(struct i2r_interface *i = i2r; i < i2r + NR_INTERFACES;i++)
       	   if (i->context)	{
-		n+= sprintf(counts + n, "%s(MC %d/%d, UD %d/%d, %s %d) ",
+		n+= sprintf(counts + n, "%s(MC %d/%d",
 			i->text,
 			i->multicast->stats[packets_received],
-			i->multicast->stats[packets_sent],
-			i->ud ? i->ud->stats[packets_received] : 0,
-			i->ud ?	i->ud->stats[packets_sent] : 0,
-			i->raw ? channel_infos[i->raw->type].suffix : "--",
-			i->raw ? i->raw->stats[packets_received]: 0);
+			i->multicast->stats[packets_sent]);
+
+		if (pgm_mode != pgm_none && i->multicast->stats[pgm_spm])
+			n+= sprintf(counts + n, " [TSI=%d SPM=%u,ODATA=%u,RDATA=%u,NAK=%u]",
+				i->nr_tsi,
+				i->multicast->stats[pgm_spm],
+				i->multicast->stats[pgm_odata],
+				i->multicast->stats[pgm_rdata],
+				i->multicast->stats[pgm_nak]);
+
+		if (i->ud && i->ud->stats[packets_received])
+			n+= sprintf(counts + n, ", UD %d/%d",
+				i->ud->stats[packets_received],
+				i->ud->stats[packets_sent]);
+		if (i->raw && i->raw->stats[packets_received])
+			n+= sprintf(counts + n, ", RAW %d", i->raw->stats[packets_received]);
+
+		n+= sprintf(counts + n, ") ");
 	}
 
 	logg(LOG_NOTICE, "%s. Groups=%d/%d. Packets=%s\n", events, active_mc, nr_mc, counts);
@@ -4850,6 +5310,7 @@ struct enable_option {
 {	"huge", &huge, NULL, "on", "off", "Enable the use of Huge memory for the packet pool" }, 
 {	"loopbackprev", &loopback_blocking, NULL, "on", "off", "Multicast loopback prevention of the NIC" },
 {	"packetsocket", &packet_socket, NULL, "on", "off", "Use a packet socket instead of a RAW QP to capure IB/ROCE traffic" },
+{	"pgm",NULL,(int *)&pgm_mode, "on", "off", "PGM processing mode (0=None, 1= Passtrough, 2=DLR, 3=Resend with new TSI" },
 {	"rate", NULL, &rate, "2", "0", "Make RDMA limit the output speed 2 =2.5GBPS 5 = 5GBPS 3 = 10GBPS ...(see enum ibv_rate)" },
 { 	"raw", 	&raw, NULL, "on", "off", "Use of RAW sockets to capture SIDR Requests. Avoids having to use a patched kernel" },
 {	"unicast", &unicast, NULL, "on", "off", "Processing of unicast packets with QP1 handling of SIDR REQ/REP" },
@@ -5159,6 +5620,7 @@ int main(int argc, char **argv)
 			nr_mc, mgid_mode->id, nr_buffers);
 
 	init_buf();	/* Setup interface registers memmory */
+	init_pgm_streams();
 
 	setup_interface(INFINIBAND);
 	setup_interface(ROCE);
