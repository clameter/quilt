Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -307,18 +307,6 @@ struct rdma_channel {
 };
 
 /*
- * The forwarding struct describes the forwarding for datagrams
- * coming from a source QP to another QP at an endpoint.
- * This is singly linked list attache to the endpoints
- */
-struct forward {
-	struct endpoint *dest;
-	struct forward *next;
-	uint32_t source_qp, dest_qp;
-	uint32_t dest_qkey;
-};
-
-/*
  * Address information for an endpoint.
  * ah points to the address stucture needed to send data to
  * this endpoint. The rest are basically keys to lookup
@@ -354,6 +342,17 @@ static inline void setup_dest(struct des
 	d->remote_qkey = remote_qkey;
 }
 
+/*
+ * The forwarding struct describes the forwarding for datagrams
+ * coming from a source QP to another QP at an endpoint.
+ * This is singly linked list attache to the endpoints
+ */
+struct forward {
+	struct dest dest;
+	struct forward *next;
+	uint32_t source_qp;
+};
+ 
 static struct i2r_interface {
 	/* Not changed when multithreading */
 	struct ibv_context *context;		/* Not for RDMA CM use */
@@ -954,7 +953,7 @@ static void pull(struct buf *buf, void *
 
 static void beacon_received(struct buf *buf);
 
-static int send_buf(struct buf *buf, struct rdma_unicast *ra);
+static int send_buf(struct buf *buf, struct dest *d);
 
 static struct buf *buffers;
 
@@ -2325,7 +2324,7 @@ static void resolve_end(struct rdma_unic
 		struct buf *buf;
 
 		while ((buf = fifo_get(&ru->pending)))		/* Send pending I/O */
-			send_buf(buf, ru);
+			send_buf(buf, &ru->dest);
 	} else
 		zap_channel(ru);
 
@@ -2635,7 +2634,7 @@ static int send_inline(struct rdma_chann
 /*
  * Send data to target using native RDMA structs relying on state in struct buf.
  */
-static int send_ud(struct rdma_channel *c, struct buf *buf, struct ibv_ah *ah, uint32_t remote_qpn, uint32_t qkey)
+static int send_ud(struct rdma_channel *c, struct buf *buf, struct dest *d)
 {
 	struct ibv_send_wr wr, *bad_send_wr;
 	struct ibv_sge sge;
@@ -2654,9 +2653,9 @@ static int send_ud(struct rdma_channel *
 	wr.wr_id = (uint64_t)buf;
 
 	/* Get addr info  */
-	wr.wr.ud.ah = ah;
-	wr.wr.ud.remote_qpn = remote_qpn;
-	wr.wr.ud.remote_qkey = qkey;
+	wr.wr.ud.ah = d->ep->ah;
+	wr.wr.ud.remote_qpn = d->remote_qpn;
+	wr.wr.ud.remote_qkey = d->remote_qkey;
 
 	sge.length = buf->end - buf->cur;
 	sge.lkey = c->mr->lkey;
@@ -2820,15 +2819,15 @@ queue:
 }
 
 /* Send buffer based on state in struct buf. Unicast only */
-static int send_buf(struct buf *buf, struct rdma_unicast *ra)
+static int send_buf(struct buf *buf, struct dest *d)
 {
 	unsigned len = buf->end - buf->cur;
 	int ret;
 
 	if (len < MAX_INLINE_DATA) {
-		ret = send_inline(ra->c, buf->cur, len, &ra->dest, buf->imm_valid, buf->imm);
+		ret = send_inline(buf->c, buf->cur, len, d, buf->imm_valid, buf->imm);
 	} else
-		ret = send_to(ra->c, buf->cur, len, &ra->dest, buf->imm_valid, buf->imm, buf);
+		ret = send_to(buf->c, buf->cur, len, d, buf->imm_valid, buf->imm, buf);
 
 	return ret;
 }
@@ -2941,7 +2940,7 @@ static void list_endpoints(struct i2r_in
 
 				while (f) {
 					n += snprintf(buf + n, sizeof(buf) - n, "[0x%x->%s:%x/%x]",
-						f->source_qp, inet_ntoa(f->dest->addr), f->dest_qp, f->dest_qkey);
+						f->source_qp, inet_ntoa(f->dest.ep->addr), f->dest.remote_qpn, f->dest.remote_qkey);
 
 					f = f->next;
 				}
@@ -2961,13 +2960,11 @@ static void list_endpoints(struct i2r_in
  * This function only adds the forward. Check if there is an existing
  * forward before calling this function.
  */
-static void add_forward(struct endpoint *source, uint32_t source_qp, struct endpoint *dest, uint32_t dest_qp, uint32_t qkey)
+static void add_forward(struct endpoint *source, uint32_t source_qp, struct dest *d)
 {
 	struct forward *f = calloc(1, sizeof(struct forward));
 
-	f->dest = dest;
-	f->dest_qp = dest_qp;
-	f->dest_qkey = qkey;
+	f->dest = *d;
 	f->source_qp = source_qp;
 
 	f->next = source->forwards;
@@ -2985,7 +2982,7 @@ static struct forward *find_forward(stru
 {
 	struct forward *f = source->forwards;
 
-	while (f && f->source_qp != source_qp && (!dest || f->dest == dest))
+	while (f && f->source_qp != source_qp && (!dest || f->dest.ep == dest))
 		f = f->next;
 
 	return f;
@@ -3671,7 +3668,28 @@ redo:
 	return ep;
 }
 
+static struct endpoint *mc_to_ep(struct i2r_interface *i, struct in_addr addr, struct ibv_pd *pd, struct ibv_ah_attr *at)
+{	
+	struct ibv_ah *ah;
+	struct endpoint *ep;
 
+	if (rate)
+		at->static_rate = rate;
+ 
+	ah = ibv_create_ah(pd, at);
+	if (!ah) {
+		logg(LOG_ERR, "mc_to_ep: Failed to create Endpoint on %s: %s. IP=%s\n",
+			i->text, errname(), inet_ntoa(addr));
+		return NULL;
+	}
+
+	ep = calloc(1, sizeof(struct endpoint));
+	ep->i = i;
+	ep->addr = addr;
+	ep->lid = at->dlid;
+	ep->ah = ah;
+	return ep;
+}
 
 /* Create Endpoint just from the IP address */
 static struct endpoint *ip_to_ep(struct i2r_interface *i, struct in_addr addr)
@@ -3798,7 +3816,7 @@ static void delayed_send(void *private)
 		logg(LOG_NOTICE, "%s: End of enforcing sending rate\n", c->i->text);
 	}
 
-	ret = send_to(c, buf->cur, buf->end - buf->cur, &mi->ai, buf->imm_valid, buf->imm, buf);
+	ret = send_to(c, buf->cur, buf->end - buf->cur, &mi->dest, buf->imm_valid, buf->imm, buf);
 	if (!ret)
 		st(c, packets_bridged);
 	buf->mi = NULL;
@@ -3946,8 +3964,9 @@ delayed_packet:
 		mi->last_sent = t;
 	}
 
-	if (!mi->ai.ah)		/* After a join it may take awhile for the ah pointer to propagate */
+	if (!mi->dest.ep->ah)		/* After a join it may take awhile for the ah pointer to propagate */
  		sleep(1);
+
 	get_buf(buf);	/* Packet will not be freed on return from this function */
  
 	ret = send_to(ch_out, buf->cur, buf->end - buf->cur, &mi->dest, buf->imm_valid, buf->imm, buf);
@@ -4178,10 +4197,11 @@ static void sidr_state_init(void)
  */
 static void send_mad(struct endpoint *e, struct buf *buf, void *mad_pos)
 {
+	struct dest d = { e, 1, IB_DEFAULT_QP1_QKEY };
 	buf->cur = mad_pos;
 	buf->end = mad_pos + 256;
 
-	send_ud(e->i->qp1, buf, e->ah, 1, IB_DEFAULT_QP1_QKEY);
+	send_ud(e->i->qp1, buf, &d);
 }
 
 static const char *sidr_req(struct buf *buf, void *mad_pos)
@@ -4366,11 +4386,18 @@ static const char * sidr_rep(struct buf
 		return "Ignoring SIDR REQ since one is already pending";
 	}
 
-	add_forward(ss->source, ss->source_qp, ss->dest, sr_qpn, sr_qkey);
+	{
+	       struct dest d = { ss->dest, sr_qpn, sr_qkey };
 
-	if (ss->source_qp)
+		add_forward(ss->source, ss->source_qp, &d);
+	}
+
+	if (ss->source_qp) {
 		/* Add the reverse forward if we have the source_qp number */
-		add_forward(ss->dest, sr_qpn, ss->source, ss->source_qp, sr_qkey);
+		struct dest d = { ss->source, ss->source_qp, sr_qkey };
+
+		add_forward(ss->dest, sr_qpn, &d);
+	}
 
 	unlock();
 
@@ -4673,11 +4700,13 @@ static void receive_ud(struct buf *buf)
 		/* Hmm... Not good. Maybe there is a wild chart entry if the source_qp was not determined yet */
 		f = find_forward(e, d, 0);
 		if (f) {
+			struct dest de = { e, f->source_qp, f->dest.remote_qkey };
+
 			f->source_qp = w->src_qp;
 			logg(LOG_NOTICE, "Inserted QP#%x into forwarding entry for %s\n", w->src_qp, inet_ntoa(e->addr));
 
 			/* And add the missing reverse forward */
-			add_forward(f->dest, f->dest_qp, e, f->source_qp, f->dest_qkey); 
+			add_forward(f->dest.ep, f->dest.remote_qpn, &de); 
 		}
 
 		unlock();
@@ -4693,12 +4722,12 @@ static void receive_ud(struct buf *buf)
 	 * if the value in immm matches the src_qp.... Maybe we should not do this by default ?
 	 */
 	if (ntohl(buf->imm) == w->src_qp)
-		buf->imm = htonl(f->dest->i->ud->qp->qp_num);
+		buf->imm = htonl(f->dest.ep->i->ud->qp->qp_num);
 
 	logg(LOG_NOTICE, "receive_ud %s Packet len=%u 0x%x lid=%d forwarded to %s %s:0x%x lid=%d qkey=%x\n", c->text,
-			w->byte_len, w->src_qp, e->lid, dest_i->ud->text, inet_ntoa(f->dest->addr), f->dest_qp, f->dest->lid, f->dest_qkey);
+			w->byte_len, w->src_qp, e->lid, dest_i->ud->text, inet_ntoa(f->dest.ep->addr), f->dest.remote_qpn, f->dest.ep->lid, f->dest.remote_qkey);
 
-	send_ud(dest_i->ud, buf, f->dest->ah, f->dest_qp, f->dest_qkey);
+	send_ud(dest_i->ud, buf, &f->dest);
  	return;
  
 discard:
@@ -5042,7 +5071,7 @@ static unsigned show_endpoints(char *b)
 
 				for (f = ep->forwards; f; f = f->next) {
 					n += snprintf(b + n, sizeof(buf) - n, " Q%d->%sQ%d",
-					      f->source_qp, inet_ntoa(f->dest->addr), f->dest_qp);
+					      f->source_qp, inet_ntoa(f->dest.ep->addr), f->dest.remote_qpn);
 				}
 			}
 			offset += 20;
@@ -5194,7 +5223,7 @@ static void send_buf_to(struct i2r_inter
 			return;
 
 		case UC_CONNECTED: /* Channel is open. We can send now */
-			ret = send_buf(buf, ra);
+			ret = send_buf(buf, &ra->dest);
 			if (!ret)
 				logg(LOG_ERR, "Failed to send to %s:%d\n",
 					inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));
