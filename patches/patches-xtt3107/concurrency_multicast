Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -50,6 +50,7 @@
 #include <ctype.h>
 #include <pthread.h>
 #include <numa.h>
+#include <stdatomic.h>
 
 #include <arpa/inet.h>
 #include <sys/socket.h>
@@ -138,12 +139,9 @@ static void logg(int prio, const char *f
 
 static pthread_mutex_t mutex;		/* Generic serialization mutex */
 
-#ifdef DEBU
 /* Is the lock taken */
 bool locked = false;
 
-#endif
-
 /* Are we running concurrent threads ? */
 bool multithreaded = false;
 
@@ -153,31 +151,24 @@ static void lock(void)
  		if (pthread_mutex_lock(&mutex))
  			logg(LOG_ERR, "Mutex lock failed: %s\n", errname());
 	}
-#ifdef DEBUG
-	 else {
-	 	if (locked)
-			abort();
-	}
+
+	if (locked)
+		abort();
 
 	locked = true;
-#endif
 }
  
 static void unlock(void)
 {
-#ifdef DEBUG
 	if (!locked)
 		abort();
-#endif
 
+	locked = false;
 	if (multithreaded) {
  		if (pthread_mutex_unlock(&mutex))
  			logg(LOG_ERR, "Mutex unlock failed: %s\n", errname());
 
 	}
-#ifdef DEBUG
-	locked = false;
-#endif
 }
  
 #if 0
@@ -263,6 +254,15 @@ struct buf;
 
 typedef void receive_callback(struct buf *);
 
+
+/*
+ * Channel data stucture,
+ *
+ * Channels may be associated with a core on which a busyloop runs.
+ *
+ * Therefore changes to variables may only be made from code
+ * running on that core if multithreading is active.
+ */
 struct rdma_channel {
 	struct i2r_interface *i;	/* The network interface of this channel */
 	struct core_info *core;		/* Core the channel is on or NULL if comp_events is used */
@@ -318,6 +318,7 @@ struct endpoint {
 };
 
 static struct i2r_interface {
+	/* Not changed when multithreading */
 	struct ibv_context *context;		/* Not for RDMA CM use */
 	struct rdma_event_channel *rdma_events;
 	struct rdma_channel *multicast;
@@ -345,11 +346,22 @@ static struct i2r_interface {
 	struct ibv_port_attr port_attr;
 	int iges;
 	struct ibv_gid_entry ige[MAX_GID];
+
+	/* The following may be updated in a multithreaded environment
+	 * from the multicast thread running for each interface.
+ 	 *
+         * Serialization is required but we generally are a bit loose
+	 * by allowing read access without locks.
+         */
 	struct hash *ru_hash;
 	struct fifo resolve_queue;		/* List of send buffers with unresolved addresses */
 	struct hash *ep;			/* Hash of all endpoints reachable here */
 	struct hash *ip_to_ep;			/* Hash based on IP address */
+
+	/* PGM information:  Only updated from the multicast channel core */
 	unsigned nr_tsi;
+	struct hash *pgm_tsi_hash;
+	struct hash *pgm_record_hash;
 } i2r[NR_INTERFACES];
 
 /*
@@ -576,9 +588,14 @@ enum mc_status { MC_OFF, MC_JOINING, MC_
 const char *mc_text[NR_MC_STATUS] = { "Inactive", "Joining", "Joined", "Error" };
 
 /* A multicast group.
+ *
  * ah_info points to multicast address and QP number in use
  * for the stream. There are no "ports" unless they are
  * embedded in the GID (like done by CLLM).
+ *
+ * Multicast groups are setup before we enter multithreaded mode
+ * However, the state of joins etc may change in multithreaded
+ * mode. Access to that status information requires some care.
  */
 static struct mc {
 	struct in_addr addr;
@@ -909,6 +926,9 @@ static void __free_buffer(struct buf *bu
 #ifdef DEBUG
 	memset(buf->raw, 0, DATA_SIZE);
 #endif
+	if (buf->free)
+		abort();
+
 	buf->free = true;
 	buf->next = nextbuffer;
 	nextbuffer = buf;
@@ -1010,10 +1030,12 @@ static struct buf *alloc_buffer(struct r
 	buf = nextbuffer;
 
 	if (buf) {
+		if (!buf->free)
+			abort();
 		nextbuffer = buf->next;
 		buf->free = false;
+		buf->c = c;
 	}
-	buf->c = c;
 	unlock();
 
 #ifdef DEBUG
@@ -2273,7 +2295,6 @@ static void handle_rdma_event(void *priv
 					param->ah_attr.sl,
 					i->text);
 				st(i->multicast, join_success);
-
 				m->status[in] = MC_JOINED;
 			}
 			break;
@@ -2552,9 +2573,12 @@ static int send_to(struct rdma_channel *
 	int ret;
 
 
-	if (!ai->ah)
-		abort();	/* Send without a route */
+	if (!ai->ah) {
+		logg(LOG_WARNING, "send_to: %s AH == NULL\n", c->text);
+		return EIO;
+	}
 
+	get_buf(buf);
 	buf->c = c;	/* Change ownership to sending channel */
 	buf->w = NULL;
 
@@ -2579,8 +2603,8 @@ static int send_to(struct rdma_channel *
 	if (ret) {
 		errno = - ret;
 		logg(LOG_WARNING, "Failed to post send: %s on %s\n", errname(), c->text);
+		put_buf(buf);
 	} else {
-		get_buf(buf);
 		if (log_packets > 1)
 			logg(LOG_NOTICE, "RDMA Send to QPN=%d QKEY=%x %d bytes\n",
 				wr.wr.ud.remote_qpn, wr.wr.ud.remote_qkey, len);
@@ -2856,13 +2880,14 @@ struct pgm_record {
 	unsigned len;			/* Length of the message */
 };
 
-struct hash *pgm_tsi_hash;
-struct hash *pgm_record_hash;
-
 static void init_pgm_streams(void)
 {
-	pgm_tsi_hash = hash_create(0, sizeof(struct pgm_tsi));
-	pgm_record_hash = hash_create(0, sizeof(struct pgm_tsi) + sizeof(uint32_t));
+	struct i2r_interface *i;
+
+	for(i = i2r; i < i2r + NR_INTERFACES; i++) {
+		i->pgm_tsi_hash = hash_create(0, sizeof(struct pgm_tsi));
+		i->pgm_record_hash = hash_create(0, sizeof(struct pgm_tsi) + sizeof(uint32_t));
+	}
 }
 
 static void format_tsi(char *b, struct pgm_tsi *tsi)
@@ -2876,6 +2901,7 @@ static void format_tsi(char *b, struct p
 
 static bool add_record(struct buf *buf, struct pgm_tsi *tsi, uint32_t sqn, void *start, unsigned len)
 {
+	struct i2r_interface *i = buf->c->i;
 	struct pgm_record *r = calloc(1, sizeof(struct pgm_record));
 	struct pgm_record *q;
 
@@ -2886,22 +2912,22 @@ static bool add_record(struct buf *buf,
 	r->len = len;
 
 	lock();
-	if ((q = hash_find(pgm_record_hash, &r))) {
+	if ((q = hash_find(i->pgm_record_hash, &r))) {
 		unlock();
 		return false;
 	} else {
 		__get_buf(buf);
-		hash_add(pgm_record_hash, r);
+		hash_add(i->pgm_record_hash, r);
 		unlock();
 		return true;
 	}
 }
 
-static struct pgm_record *find_record(struct pgm_tsi *tsi, uint32_t sqn)
+static struct pgm_record *find_record(struct i2r_interface *i, struct pgm_tsi *tsi, uint32_t sqn)
 {
 	struct pgm_record f = { .tsi = *tsi, .sqn = sqn };
 
-	return hash_find(pgm_record_hash, &f);
+	return hash_find(i->pgm_record_hash, &f);
 }
 
 /* Forwarded packet if ib2roce behaves like a DLR */
@@ -2952,7 +2978,7 @@ static bool pgm_process(struct rdma_chan
 	tsi.dport = ntohs(header.pgm.pgm_dport);
 	format_tsi(text, &tsi);
 
-	s = hash_find(pgm_tsi_hash, &tsi);
+	s = hash_find(i->pgm_tsi_hash, &tsi);
 
 	switch (header.pgm.pgm_type) {
 		case PGM_SPM:		/* Multicast downstream */
@@ -2989,13 +3015,13 @@ static bool pgm_process(struct rdma_chan
 
 			if (!s) {
 				lock();
-				s = hash_find(pgm_tsi_hash, &tsi);
+				s = hash_find(i->pgm_tsi_hash, &tsi);
 				if (!s) {
 					s = calloc(1, sizeof(struct pgm_stream));
 					s->tsi = tsi;
 					s->i = i;
 					strcpy(s->text, text);
-					hash_add(pgm_tsi_hash, s);
+					hash_add(i->pgm_tsi_hash, s);
 
 					/* First message on new stream */
 					s->last_seq = sqn - 1;
@@ -3028,7 +3054,7 @@ static bool pgm_process(struct rdma_chan
 				break;
 			}
 
-			if (sqn < s->last && find_record(&tsi, sqn)) {
+			if (sqn < s->last && find_record(i, &tsi, sqn)) {
 				st(c, pgm_dup);
 				ret = false;
 				logg(LOG_NOTICE, "%s: Repeated data in Window SQN=%d\n", s->text, sqn);
@@ -3062,7 +3088,7 @@ static bool pgm_process(struct rdma_chan
 				} else {
 					/* We just filled up in a missing piece check how long our consistent history goes now */
 					while (s->last_seq < s->last) {
-						struct pgm_record *r = find_record(&tsi, s->last_seq + 1);
+						struct pgm_record *r = find_record(i, &tsi, s->last_seq + 1);
 
 						if (r) {
 							logg(LOG_NOTICE, "Found earlier record %d\n", s->last_seq + 1);
@@ -3189,7 +3215,7 @@ static bool pgm_process(struct rdma_chan
 					logg(LOG_NOTICE, "%s: End of Stream TSI %s\n", i->text, text);
 					if (s) {
 						/* Remove all records */
-						hash_del(pgm_tsi_hash, &tsi);
+						hash_del(i->pgm_tsi_hash, &tsi);
 						free(s);
 						i->nr_tsi--;
 						s = NULL;
@@ -3554,8 +3580,14 @@ static void receive_multicast(struct buf
 	int ret;
 	struct pgm_header pgm;
 
+	if (!buf->refcount)
+		abort();
+
 	learn_source_address(buf);
 
+	if (!buf->refcount)
+		abort();
+
 	if (!buf->grh_valid) {
 		logg(LOG_WARNING, "No GRH on %s. Packet discarded: %s\n",
 			c->text, payload_dump(buf->cur));
@@ -3650,6 +3682,9 @@ static void receive_multicast(struct buf
 		return;
 	}
 
+	if (!buf->refcount)
+		abort();
+
 	if (pgm_mode != pgm_none) {
 		if (!pgm_process(c, m, buf))
 			return;
