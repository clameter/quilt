Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- rdma-core.orig/ib2roce/interfaces.c
+++ rdma-core/ib2roce/interfaces.c
@@ -292,17 +292,12 @@ static void qp_destroy(struct i2r_interf
 	}
 #endif
 
-	channel_destroy(i->multicast);
-	i->multicast = NULL;
-
-	channel_destroy(i->raw);
-	i->raw = NULL;
-
-	channel_destroy(i->ud);
-	i->ud = NULL;
-
-	channel_destroy(i->qp1);
-	i->qp1 = NULL;
+	channelp_foreach(c, &i->channels) {
+		if (*c) {
+			channel_destroy(*c);
+			*c = NULL;
+		}
+	}
 }
 
 /* Retrieve Kernel Stack info about the interface */
@@ -412,10 +407,28 @@ void check_out_of_buffer(void *private)
 	add_event(now + ONE_SECOND, check_out_of_buffer, i, "Check out of buffers");
 }
 
+/* Find an RDMA channel by type */
+struct rdma_channel *find_channel(struct i2r_interface *i, enum channel_type type)
+{
+	channel_foreach(c, &i->channels) {
+
+		if (c->type == type)
+			return c;
+	}
+
+	panic("Cannot find channel type %u on interface %s\n", type, i->text);
+	return NULL;
+}
+
 void setup_interface(enum interfaces in)
 {
 	struct i2r_interface *i = i2r + in;
 	struct ibv_gid_entry *e;
+	struct rdma_channel *multicast= NULL;
+	struct rdma_channel *qp1 = NULL;
+	struct rdma_channel *raw_channel = NULL;
+	struct rdma_channel *ud = NULL;
+	unsigned channels;
 
 	if (in == INFINIBAND)
 		i->maclen = 20;
@@ -477,7 +490,6 @@ void setup_interface(enum interfaces in)
 
 
 	/* Create RDMA elements that are interface wide */
-
 	i->rdma_events = rdma_create_event_channel();
 	if (!i->rdma_events)
 		panic("rdma_create_event_channel() for %s failed (%s).\n",
@@ -500,31 +512,43 @@ void setup_interface(enum interfaces in)
 	if (!i->mr)
 		panic("ibv_reg_mr failed for %s:%s.\n", i->text, errname());
 
-	i->multicast = new_rdma_channel(i, channel_rdmacm, NULL);
+	/* Calculate number of required RDMA channels for multicast */
+	channels = 1 + nr_mc / i->device_attr.max_mcast_grp;
 
-	if (!i->multicast)
-		abort();
+	for (int j = 0; j < channels; j++) {
+		char buf[5];
 
-	if (unicast) {
+		snprintf(buf, sizeof(buf), "%d", j);
+		i->channels.c[j] = multicast = new_rdma_channel(i, channel_rdmacm, buf);
 
-		i->ud = new_rdma_channel(i, channel_ud, NULL);
-		i->qp1 = new_rdma_channel(i, channel_qp1, NULL);
+		if (!multicast)
+			panic("Cannot create %d rdma channels required for multicast\n", channels);
 
-		if (raw) {
-			if (i == i2r + INFINIBAND) {
-				i->raw = new_rdma_channel(i, channel_ibraw, NULL);
-				/* Sadly fallback is not working here */
-			} else {
-				if (packet_socket)
-					i->raw = new_rdma_channel(i, channel_packet, NULL);
-				else
-					i->raw = new_rdma_channel(i, channel_raw, NULL);
-			}
-		}
 	}
 
-	check_out_of_buffer(i);
-	numa_run_on_node(-1);
+	if (unicast) {
+
+		i->channels.c[channels++] = ud = new_rdma_channel(i, channel_ud, NULL);
+		i->channels.c[channels++] = qp1 = new_rdma_channel(i, channel_qp1, NULL);
+
+ 		if (raw) {
+ 			if (i == i2r + INFINIBAND) {
+				i->channels.c[channels++] = raw_channel = new_rdma_channel(i, channel_ibraw, NULL);
+ 				/* Sadly fallback is not working here */
+ 			} else {
+ 				if (packet_socket)
+					i->channels.c[channels++] = new_rdma_channel(i, channel_packet, NULL);
+ 				else
+					i->channels.c[channels++] = new_rdma_channel(i, channel_raw, NULL);
+ 			}
+ 		}
+ 	}
+
+	if (channels > MAX_CHANNELS_PER_INTERFACE)
+		panic("Too many channels for interface %s\n", i->text);
+
+ 	check_out_of_buffer(i);
+ 	numa_run_on_node(-1);
 
 	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u"
 		"/%u/%u"
@@ -535,9 +559,9 @@ void setup_interface(enum interfaces in)
 		i->port,
 		inet6_ntoa(e->gid.raw), i->gid_index,
 		inet_ntoa(i->if_addr.sin_addr), default_port,
-		i->multicast ? i->multicast->nr_cq: 0,
-		i->ud ? i->ud->nr_cq : 0,
-		i->raw ? i->raw->nr_cq : 0,
+		multicast ? multicast->nr_cq: 0,
+		ud ? ud->nr_cq : 0,
+		raw_channel ? raw_channel->nr_cq : 0,
 		i->mtu,
 		i->numa_node
 	);
@@ -548,7 +572,10 @@ void shutdown_ib(void)
 	if (!i2r[INFINIBAND].context)
 		return;
 
-	leave_mc(INFINIBAND, i2r[INFINIBAND].multicast);
+	channel_foreach(c, &i2r[INFINIBAND].channels) {
+		if (c->type == channel_rdmacm)
+			leave_mc(INFINIBAND, c);
+	}
 
 	/* Shutdown Interface */
 	qp_destroy(i2r + INFINIBAND);
@@ -559,7 +586,10 @@ void shutdown_roce(void)
 	if (!i2r[ROCE].context)
 		return;
 
-	leave_mc(ROCE, i2r[ROCE].multicast);
+	channel_foreach(c, &i2r[ROCE].channels) {
+		if (c->type == channel_rdmacm)
+			leave_mc(ROCE, c);
+	}
 
 	/* Shutdown Interface */
 	qp_destroy(i2r + ROCE);
@@ -864,15 +894,11 @@ void post_receive(struct rdma_channel *c
 
 void post_receive_buffers(void)
 {
-	interface_foreach(i) {
-		post_receive(i->multicast);
-		post_receive(i->raw);
-		post_receive(i->qp1);
-		post_receive(i->ud);
-	}
+	interface_foreach(i)
+		channel_foreach(c, &i->channels)
+			post_receive(c);
 }
 
-
 void reset_flags(struct buf *buf)
 {
 	memset(&buf->ip_valid, 0, (void *)&buf->ip_csum_ok - (void *)&buf->ip_valid);
@@ -1084,18 +1110,10 @@ unsigned show_interfaces(char *b)
 {
 	int n = 0;
 
-	interface_foreach(i) {
-
-		if (i->multicast)
-			n += channel_stats(b + n, i->multicast, i->text, "Multicast");
-#ifdef UNICAST
-		if (i->ud)
-			n += channel_stats(b + n, i->ud, i->text, "UD");
-		if (i->raw)
-			n += channel_stats(b + n, i->raw, i->text, "Raw");
-#endif
+	interface_foreach(i)
+		channel_foreach(c, &i->channels)
+			n += channel_stats(b + n, c, i->text, c->type == channel_rdmacm ? "Multicast" : c->text);
 
-	}
 	return n;
 }
 
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- rdma-core.orig/ib2roce/interfaces.h
+++ rdma-core/ib2roce/interfaces.h
@@ -64,16 +64,31 @@ extern int irate;	/* Software delay per
 extern int max_rburst;	/* Dont delay until # of packets for ROCE */
 extern int max_iburst;	/* Dont delay until # of packets for Infiniband */
 
+#define MAX_CHANNELS_PER_INTERFACE 10
+
+struct channel_list {
+	struct rdma_channel *c[MAX_CHANNELS_PER_INTERFACE];
+};
+
+bool is_a_channel_of(struct rdma_channel *, struct channel_list *);
+
+/* Iterators for channel array */
+
+/* Iterator is a pointer to pointer to the object */
+#define channelp_foreach(_channel, _channel_list)					\
+	for(struct rdma_channel **_channel = ((struct rdma_channel **)&((_channel_list)->c));				\
+		_channel < ((struct rdma_channel **)&((_channel_list)->c)) + MAX_CHANNELS_PER_INTERFACE; _channel++)
+
+/* Iterator that is a pointer to the object */
+#define channel_foreach(_channel, _channel_list)						\
+	channelp_foreach(_ch2, _channel_list) for(struct rdma_channel *_channel = *_ch2; _channel; _channel = NULL)
 
 struct i2r_interface {
 	/* Not changed when multithreading */
 	struct ibv_context *context;		/* Not for RDMA CM use */
-	struct rdma_event_channel *rdma_events;
-	struct rdma_channel *multicast;
-	struct rdma_channel *qp1;		/* Channel for QP1 communications but not QP1 (userspace) */
-	struct rdma_channel *ud;		/* Regular data */
-	struct rdma_channel *raw;
 	struct ibv_comp_channel *comp_events;
+	struct rdma_event_channel *rdma_events;
+	struct channel_list channels;
 	struct ibv_cq *cq;
 	struct ibv_pd *pd;
 	struct ibv_mr *mr;
@@ -144,6 +159,10 @@ int check_rdma_device(enum interfaces i,
 int find_rdma_devices(void);
 /* Find the interface that allows us to reach a certain IP address */
 struct i2r_interface *find_interface(struct sockaddr_in *sin);
+struct rdma_channel *find_channel(struct i2r_interface *i, enum channel_type type);
+
+void check_joins(struct channel_list *infiniband, struct channel_list *roce);
+void next_join_complete(void);
 
 void check_out_of_buffer(void *);
 
@@ -157,25 +176,4 @@ void shutdown_roce(void);
 
 unsigned show_interfaces(char *b);
 
-static inline struct rdma_channel *find_channel(struct i2r_interface *i, enum channel_type type)
-{
-	switch (type) {
-		case channel_rdmacm:
-			return i->multicast;
-
-		case channel_ud:
-			return i->ud;
-
-		case channel_qp1:
-			return i->qp1;
-
-		case channel_raw:
-		case channel_ibraw:
-			return i->raw;
-
-		default:
-			abort();
-	}
-}
-
 #endif
Index: rdma-core/ib2roce/logging.c
===================================================================
--- rdma-core.orig/ib2roce/logging.c
+++ rdma-core/ib2roce/logging.c
@@ -154,6 +154,27 @@ char *hexbytes(uint8_t *q, unsigned len,
 	return __hexbytes(b, q, len, separator);
 }
 
+static bool sum_stats(unsigned *stats, struct i2r_interface  *i, enum channel_type type)
+{
+	bool r = false;
+
+	memset(stats, 0, nr_stats * sizeof(unsigned));
+
+	channel_foreach(c, &i->channels) {
+		int j;
+
+		if (type != nr_channel_types && c->type != type)
+			continue;
+
+		for(j = 0; j < nr_stats; j++)
+			if (c->stats[j]) {
+				stats[j] += c->stats[j];
+				r = true;
+			}
+	}
+	return r;
+}
+
 void brief_status(FILE *out)
 {
 	char buf[4000];
@@ -178,31 +199,36 @@ void brief_status(FILE *out)
 	}
 
 	n = 0;
-	for(struct i2r_interface *i = i2r; i < i2r + NR_INTERFACES;i++)
-      	   if (i->context)	{
+	interface_foreach(i) {
+		unsigned stats[nr_stats];
+
+		sum_stats(stats, i, channel_rdmacm);
+
 		n+= sprintf(counts + n, "%s(MC %d/%d",
 			i->text,
-			i->multicast->stats[packets_received],
-			i->multicast->stats[packets_sent]);
+			stats[packets_received],
+			stats[packets_sent]);
 
 		if (i->mc_rate_limited)
 			n+= sprintf(counts + n, " R%d", i->mc_rate_limited);
 
-		if (pgm_mode != pgm_none && (i->multicast->stats[pgm_spm] || i->multicast->stats[pgm_odata]))
+		if (pgm_mode != pgm_none && (stats[pgm_spm] || stats[pgm_odata]))
 			n+= sprintf(counts + n, " [TSI=%d SPM=%u,ODATA=%u,RDATA=%u,NAK=%u]",
 				i->nr_tsi,
-				i->multicast->stats[pgm_spm],
-				i->multicast->stats[pgm_odata],
-				i->multicast->stats[pgm_rdata],
-				i->multicast->stats[pgm_nak]);
-#ifdef UNICAST
-		if (i->ud && i->ud->stats[packets_received])
-			n+= sprintf(counts + n, ", UD %d/%d",
-				i->ud->stats[packets_received],
-				i->ud->stats[packets_sent]);
-		if (i->raw && i->raw->stats[packets_received])
-			n+= sprintf(counts + n, ", RAW %d", i->raw->stats[packets_received]);
-#endif
+				stats[pgm_spm],
+				stats[pgm_odata],
+				stats[pgm_rdata],
+				stats[pgm_nak]);
+		if (sum_stats(stats, i, channel_ud) && stats[packets_received]) {
+				n+= sprintf(counts + n, ", UD %d/%d",
+					stats[packets_received],
+					stats[packets_sent]);
+		}
+
+		if (sum_stats(stats, i, channel_raw) && stats[packets_received]) {
+			n+= sprintf(counts + n, ", RAW %d", stats[packets_received]);
+		}
+
 		n+= sprintf(counts + n, ") ");
 	}
 
Index: rdma-core/ib2roce/channel.c
===================================================================
--- rdma-core.orig/ib2roce/channel.c
+++ rdma-core/ib2roce/channel.c
@@ -317,6 +317,7 @@ static bool setup_multicast(struct rdma_
 
 	register_callback(handle_async_event, i->context->async_fd, i);
 
+	/* XXX This is not going to work for multi channel RDMA */
 	ret = rdma_bind_addr(c->id, c->bindaddr);
 	if (ret) {
 		logg(LOG_CRIT, "Failed to bind %s interface. Error %s\n",
@@ -597,17 +598,19 @@ void stop_channel(struct rdma_channel *c
 
 void all_channels(FILE *out, void (*func)(FILE *out, struct rdma_channel *))
 {
-	interface_foreach(i) {
-		if (i->multicast)
-			func(out, i->multicast);
-		if (i->ud)
-			func(out, i->ud);
-		if (i->raw)
-			func(out, i->raw);
-		if (i->qp1)
-			func(out, i->qp1);
-	}
-	run_bridge_channels(NULL, func);
+ 	interface_foreach(i)
+		channel_foreach(c, &i->channels)
+				func(out, c);
+
+ 	run_bridge_channels(NULL, func);
+}
+
+bool is_a_channel_of(struct rdma_channel *c, struct channel_list *cl)
+{
+	channel_foreach(c2, cl)
+		if (c2 == c)
+			return true;
+	return false;
 }
 
 void arm_channel(struct rdma_channel *c)
@@ -617,30 +620,34 @@ void arm_channel(struct rdma_channel *c)
 
 void arm_channels(struct core_info *core)
 {
-	interface_foreach(i) {
-		/* And request notifications if something happens */
-		if (i->multicast && core == i->multicast->core) {
-			ibv_req_notify_cq(i->multicast->cq, 0);
-		}
-		if (i->raw && core == i->raw->core &&
-			       (i->raw->type == channel_raw || i->raw->type == channel_ibraw)) {
-			start_channel(i->raw);
-			ibv_req_notify_cq(i->raw->cq, 0);
-
-			setup_flow(i->raw);
-		}
-
-		if (i->ud && core == i->ud->core) {
-			start_channel(i->ud);
-			ibv_req_notify_cq(i->ud->cq, 0);
-		}
-
-		if (i->qp1 && core == i->qp1->core) {
-			start_channel(i->qp1);
-			ibv_req_notify_cq(i->qp1->cq, 0);
-		}
-	}
+	interface_foreach(i)
+		channel_foreach(c, &i->channels) {
 
+			switch (c->type) {
+		   		case  channel_rdmacm:
+		  			if (core == c->core) {
+						ibv_req_notify_cq(c->cq, 0);
+					}
+					break;
+
+				case channel_raw:
+				case channel_ibraw:
+					start_channel(c);
+					ibv_req_notify_cq(c->cq, 0);
+					setup_flow(c);
+					break;
+
+				case channel_ud:
+				case channel_qp1:
+ 					if (core == c->core) {
+						start_channel(c);
+						ibv_req_notify_cq(c->cq, 0);
+					}
+					break;
+				default:
+					break;
+			}
+ 		}
 }
 
 static int stat_interval = 10;		/* Interval for statistics */
Index: rdma-core/ib2roce/channel.h
===================================================================
--- rdma-core.orig/ib2roce/channel.h
+++ rdma-core/ib2roce/channel.h
@@ -46,7 +46,6 @@
 #include "buffers.h"
 #include "fifo.h"
 
-
 #define ROCE_PORT 4791
 #define ETHERTYPE_ROCE 0x8915
 
Index: rdma-core/ib2roce/multicast.c
===================================================================
--- rdma-core.orig/ib2roce/multicast.c
+++ rdma-core/ib2roce/multicast.c
@@ -203,7 +203,7 @@ void setup_mc_addrs(struct mc *m, struct
  * Parse an address with port number [:xxx] and/or mgid format [/YYYY]
  */
 struct sockaddr_in *parse_addr(const char *arg, int port,
-	uint8_t *p_mgid_mode, uint8_t *p_tos_mode, bool mc_only)
+		uint8_t *p_mgid_mode, uint8_t *p_tos_mode, bool mc_only)
 {
 	struct addrinfo *res;
 	char *service;
@@ -306,8 +306,8 @@ void mgids_out(void)
 	for (n = 0; n < nr_mgid_signatures; n++) {
 		struct mgid_signature *m = mgid_signatures + n;
 
-			printf("%7s|    0x%04x | %s\n",
-					m->id, m->signature, m->port ? "true" : "false");
+		printf("%7s|    0x%04x | %s\n",
+				m->id, m->signature, m->port ? "true" : "false");
 	}
 }
 
@@ -324,8 +324,8 @@ bool mgid_check(struct mc *m, unsigned s
 
 /* Multicast group specifications on the command line */
 int new_mc_addr(char *arg,
-	bool sendonly_infiniband,
-	bool sendonly_roce)
+		bool sendonly_infiniband,
+		bool sendonly_roce)
 {
 	struct sockaddr_in *si;
 	struct mc *m = mcs + nr_mc;
@@ -363,7 +363,7 @@ out:
 
 
 static int _join_mc(struct in_addr addr, struct sockaddr *sa,
-	unsigned port, uint8_t tos, struct rdma_channel *c, bool sendonly, struct mc *m)
+		unsigned port, uint8_t tos, struct rdma_channel *c, bool sendonly, struct mc *m)
 {
 	int ret;
 	int i;
@@ -371,7 +371,7 @@ static int _join_mc(struct in_addr addr,
 	struct rdma_cm_join_mc_attr_ex mc_attr = {
 		.comp_mask = RDMA_CM_JOIN_MC_ATTR_ADDRESS | RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS,
 		.join_flags = sendonly ? RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER
-                                       : RDMA_MC_JOIN_FLAG_FULLMEMBER,
+			: RDMA_MC_JOIN_FLAG_FULLMEMBER,
 		.addr = sa
 	};
 
@@ -462,7 +462,7 @@ int leave_mc(enum interfaces i, struct r
  * List the two rdma channels for bridging MC traffic on which joins are currently processed
  */
 static struct global_join_state {
-	struct rdma_channel *channels[2];
+	struct channel_list *channels[NR_INTERFACES];
 } gjs;
 
 /*
@@ -488,45 +488,53 @@ static void send_joins(void)
 			struct mc_interface *mi = m->interface + in;
 			uint8_t tos = in == ROCE ? m->tos_mode : 0;
 
-			if (mi->channel && mi->channel != gjs.channels[in]) {
-				logg(LOG_INFO, "Not joning multicast group %s which is not on rdma channel %s but on %s\n",
-						m->text, gjs.channels[in]->text, mi->channel->text);
+			if (mi->channel && !is_a_channel_of(mi->channel, gjs.channels[in])) {
+				logg(LOG_INFO, "Not joining multicast group %s which is not on rdma channel %s but on %s\n",
+						m->text, gjs.channels[in]->c[0]->text, mi->channel->text);
 				continue;
 			}
 
 			if (i2r[in].context) {
 				switch(mi->status) {
 
-				case MC_OFF:
-					if (_join_mc(m->addr, mi->sa, port, tos, gjs.channels[in], mi->sendonly, m) == 0) {
-						mi->status = MC_JOINING;
-						mi->channel = gjs.channels[in];
-					} else
-						/* Error during join... Lets retry this in awhile */
-						return;
-					break;
-
-				case MC_ERROR:
-
-					_leave_mc(m->addr, mi->sa, mi->channel, m);
-					mi->status = MC_OFF;
-					mi->channel = NULL;
-					logg(LOG_WARNING, "Left Multicast group %s on %s due to MC_ERROR\n",
-						m->text, interfaces_text[in]);
-					break;
-
-				case MC_JOINED:
-					break;
-
-				case MC_JOINING:
-					/* Join is still being processed */
-					break;
-
-				default:
-					logg(LOG_ERR, "Bad MC status %d MC %s on %s\n",
-					       mi->status, m->text, interfaces_text[in]);
-					break;
+					case MC_OFF:
+						/* Find rdma channel with available multicast slots  */
+						channel_foreach(c, gjs.channels[in]) {
+							if (c->type == channel_rdmacm && c->nr_mcs < c->i->device_attr.max_mcast_grp) {
+								if (_join_mc(m->addr, mi->sa, port, tos, c, mi->sendonly, m) == 0) {
+									mi->status = MC_JOINING;
+									mi->channel = c;
+									goto next;
+								} else
+									/* Error during join... Lets retry this in awhile */
+									return;
+							}
+						}
+						panic("Not enough rdma channels for multicast channels\n");
+						break;
+
+					case MC_ERROR:
+
+						_leave_mc(m->addr, mi->sa, mi->channel, m);
+						mi->status = MC_OFF;
+						mi->channel = NULL;
+						logg(LOG_WARNING, "Left Multicast group %s on %s due to MC_ERROR\n",
+								m->text, interfaces_text[in]);
+						break;
+
+					case MC_JOINED:
+						break;
+
+					case MC_JOINING:
+						/* Join is still being processed */
+						break;
+
+					default:
+						logg(LOG_ERR, "Bad MC status %d MC %s on %s\n",
+								mi->status, m->text, interfaces_text[in]);
+						break;
 				}
+				next: ;
 			}
 		}
 	}
@@ -550,17 +558,20 @@ void next_join_complete(void)
 	 */
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-	   if (i->context)	{
-		struct rdma_channel *c = gjs.channels[i - i2r];
+		if (i->context)	{
+			channel_foreach(c, gjs.channels[i - i2r]) {
+				if (c->type != channel_rdmacm)
+					continue;
 
-		if (c->listening)
-			continue;
+				if (c->listening)
+					continue;
 
-		if (rdma_listen(c->id, 50))
-			logg(LOG_ERR, "rdma_listen on %s error %s\n", c->text, errname());
+				if (rdma_listen(c->id, 50))
+					logg(LOG_ERR, "rdma_listen on %s error %s\n", c->text, errname());
 
-		c->listening = true;
-	}
+				c->listening = true;
+			}
+		}
 }
 
 static void __check_joins(void *private)
@@ -574,15 +585,14 @@ static void __check_joins(void *private)
 	}
 }
 
-void check_joins(struct rdma_channel *infiniband, struct rdma_channel *roce)
+void check_joins(struct channel_list *infiniband,
+		struct channel_list *roce)
 {
 	gjs.channels[INFINIBAND] = infiniband;
 	gjs.channels[ROCE] = roce;
-
-	__check_joins(NULL);
+	 __check_joins(NULL);
 }
 
-
 unsigned show_multicast(char *b)
 {
 	int n = 0;
@@ -635,7 +645,7 @@ static void multicast_cmd(FILE *out, cha
 			if (m->admin)
 				fprintf(out, "admin ");
 
-			if (mi->channel != i2r[in].multicast)
+			if (!is_a_channel_of(mi->channel, &i2r[in].channels))
 				fprintf(out, "remote ");
 
 			fprintf(out, "packet_time=%dns, max_burst=%d packets, delayed=%ld packets, last_sent=%ldms ago, last_delayed=%ldms ago, pending=%u packets, burst=%d\n",
Index: rdma-core/ib2roce/beacon.c
===================================================================
--- rdma-core.orig/ib2roce/beacon.c
+++ rdma-core/ib2roce/beacon.c
@@ -90,7 +90,7 @@ struct bridge_state {
 	unsigned beacons_missed;
 	unsigned beacons_received;
 	long  distance[3];
-	struct rdma_channel *channel[NR_INTERFACES];
+	struct channel_list *channels[NR_INTERFACES];
 	struct beacon_info last;
 };
 
@@ -120,8 +120,11 @@ void run_bridge_channels(FILE *out, void
 	for(i = 0; i < nr_bridges; i++) {
 		struct bridge_state *br = remote_bridge + i;
 
-		func(out, br->channel[INFINIBAND]);
-		func(out, br->channel[ROCE]);
+		channel_foreach(c, br->channels[INFINIBAND])
+			func(out, c);
+
+		channel_foreach(c, br->channels[ROCE])
+			func(out,c );
 	}
 }
 
@@ -136,7 +139,8 @@ static void enable_bridge(struct bridge_
 
 	/* Create new MC channels */
 	for (i = 0; i < NR_INTERFACES; i++) {
-		b->channel[i] = new_rdma_channel(i2r + i, channel_rdmacm, "beacon");
+		/* XXX Needs to be fixed to support multiple rdma channels */
+		b->channels[i]->c[0] = new_rdma_channel(i2r + i, channel_rdmacm, "beacon");
 	}
 
 
@@ -178,11 +182,18 @@ static void enable_bridge(struct bridge_
 
 		m->enabled = true;
 	}
-	post_receive(b->channel[INFINIBAND]);
-	post_receive(b->channel[ROCE]);
-	arm_channel(b->channel[INFINIBAND]);
-	arm_channel(b->channel[ROCE]);
-	check_joins(b->channel[INFINIBAND], b->channel[ROCE]);
+
+	channel_foreach(c, b->channels[INFINIBAND])
+		post_receive(c);
+	channel_foreach(c, b->channels[ROCE])
+		post_receive(c);
+
+	channel_foreach(c, b->channels[INFINIBAND])
+		arm_channel(c);
+	channel_foreach(c, b->channels[ROCE])
+		arm_channel(c);
+
+	check_joins(b->channels[INFINIBAND], b->channels[ROCE]);
 	b->active = true;
 }
 
@@ -195,11 +206,15 @@ static void disable_bridge(struct bridge
  * If there are errors: Do not worry. Destroying the
  * QP is also an implied leave
  */
-	leave_mc(INFINIBAND, b->channel[INFINIBAND]);
-	leave_mc(ROCE, b->channel[ROCE]);
-
-	channel_destroy(b->channel[INFINIBAND]);
-	channel_destroy(b->channel[ROCE]);
+	channel_foreach(c, b->channels[INFINIBAND])
+		leave_mc(INFINIBAND, c);
+	channel_foreach(c, b->channels[ROCE])
+		leave_mc(ROCE, c);
+
+	channel_foreach(c, b->channels[INFINIBAND])
+		channel_destroy(c);
+	channel_foreach(c, b->channels[ROCE])
+		channel_destroy(c);
 }
 
 static void check_remote_bridges(void)
@@ -239,7 +254,7 @@ static void prep_beacon_struct(struct i2
 	for(m = mcs; m < mcs + nr_mc; m++) {
 		struct beacon_multicast *bm = b->mc + groups;
 
-		if (m->admin || !m->enabled || m->interface[i - i2r].channel != i->multicast)
+		if (m->admin || !m->enabled || !is_a_channel_of(m->interface[i - i2r].channel, &i->channels))
 			continue;
 
 		bm->group = m->addr;
@@ -352,12 +367,13 @@ static void beacon_send(void *private)
 		if (beacon_mc) {
 			enum interfaces in = last_interface;
 			struct i2r_interface *i = i2r + in;
+			struct rdma_channel *c = beacon_mc->interface[in].channel;
 
 			if (i->context && beacon_mc->interface[in].status == MC_JOINED) {
 
-				buf = alloc_buffer(i->multicast);
+				buf = alloc_buffer(c);
 				prep_beacon_struct(i, buf);
-				send_to(i->multicast, buf->raw, buf->end - buf->raw, &beacon_mc->interface[in].ai, false, 0, buf);
+				send_to(c, buf->raw, buf->end - buf->raw, &beacon_mc->interface[in].ai, false, 0, buf);
 			}
 
 		} else { /* Unicast */
@@ -368,7 +384,8 @@ static void beacon_send(void *private)
 				beacon = false;
 				return;
 			}
-			buf = alloc_buffer(i->multicast);
+			/* Just some channel. This is unicast and will be handled differently */
+			buf = alloc_buffer(i->channels.c[0]);
 			prep_beacon_struct(i, buf);
 
 			reset_flags(buf);
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -389,7 +389,7 @@ static void setup_timed_events(void)
 
 	calculate_pps(NULL);
 
-	check_joins(i2r[INFINIBAND].multicast, i2r[ROCE].multicast);
+	check_joins(&i2r[INFINIBAND].channels, &i2r[ROCE].channels);
 }
 
 static void update_status(int x)
Index: rdma-core/ib2roce/multicast.h
===================================================================
--- rdma-core.orig/ib2roce/multicast.h
+++ rdma-core/ib2roce/multicast.h
@@ -126,9 +126,6 @@ struct sockaddr_in *parse_addr(const cha
 
 int leave_mc(enum interfaces i, struct rdma_channel *);
 
-void check_joins(struct rdma_channel *infiniband, struct rdma_channel *roce);
-void next_join_complete(void);
-
 /* MGID format related functions */
 const char *mgid_text(struct mc *m);
 void mgids_out(void);
