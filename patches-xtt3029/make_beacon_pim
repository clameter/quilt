Index: rdma-core/ib2roce/beacon.c
===================================================================
--- rdma-core.orig/ib2roce/beacon.c
+++ rdma-core/ib2roce/beacon.c
@@ -38,13 +38,19 @@
 #include "multicast.h"
 #include "cli.h"
 
+#include <unistd.h>
+
 #include "beacon.h"
 
 #define BEACON_SIGNATURE 0xD3ADB33F
+#define BEACON_MC_ADDR "239.1.2.3"
+#define BEACON_PORT	1109
 
-static bool beacon = false;		/* Announce our presence (and possibly coordinate between multiple instances in the future */
+static bool beacon = false;
+static int beacon_interval = 1000;	/* Default Hello interval in Milliseconds */
+static unsigned sessionid;		/* Random Number for this session */
 
-const char *beacon_arg = NULL;
+static char hostname[40];
 
 #define BEACON_MCS 500
 
@@ -53,53 +59,136 @@ struct beacon_mc {
 	uint16_t port;
 };
 
-/*
- * Beacon processing
- */
-struct beacon_info {
-	unsigned long signature;
-	char version[10];
-	bool infiniband;
-	uint16_t beacon_port;
-	struct in_addr beacon_mc;
-	uint64_t t;
-	unsigned gateway_qp;
-	struct in_addr bridge_addr;		/* Where is the local bridge */
-	struct in_addr to_addr;			/* To which address is it bridging */
-	unsigned nr_mc;				/* Active Multicast */
-	unsigned nr_tsi;			/* Active TSIs */
-	struct beacon_mc mc[500];
-};
+#define MAX_BRIDGES 10
+static struct bridge_state remote_bridge[MAX_BRIDGES];
+
+static unsigned int nr_bridges;
 
 static struct mc *beacon_mc;		/* == NULL if unicast */
 static struct sockaddr_in *beacon_sin;
 
-static void prep_beacon_struct(struct i2r_interface *i, struct beacon_info *b)
+static void enable_bridge(struct bridge_state *b)
+{
+	struct beacon_multicast *bm;
+	int nr_mcs;
+
+	logg(LOG_INFO, "Taking over for bridge on %s\n", inet_ntoa(b->origin[0]));
+
+	nr_mcs = b->last.nr_mc;
+
+	/* Subscribe to all MC groups of the specified group */
+	for(bm = b->last.mc; bm < b->last.mc + nr_mcs; bm++) {
+		struct mc *m;
+		struct sockaddr_in sin = {
+			.sin_family = AF_INET,
+			.sin_addr = bm->group,
+			.sin_port = htons(bm->port)
+		};
+		int ret;
+
+		m = hash_lookup_mc(bm->group);
+		if (!m) {
+
+			if (nr_mc == MAX_MC) {
+				logg(LOG_ERR, "Too many multicast groups when enabling bridge %s\n", b->last.name);
+				break;
+			}
+			m = mcs + nr_mc;
+			nr_mc++;
+
+			ret = hash_add_mc(m);
+			if (ret) {
+				logg(LOG_ERR, "Duplicate multicast address when enabling bridge %s\n", b->last.name);
+				break;
+			}
+
+		}
+		m->bridge = b;
+		m->addr = bm->group;
+		m->interface[INFINIBAND].sendonly = bm->sendonly[INFINIBAND];
+		m->interface[ROCE].sendonly = bm->sendonly[ROCE];
+		m->text = strdup(inet_ntoa(sin.sin_addr));
+		m->tos_mode = bm->tos_mode;
+		m->mgid_mode = bm->mgid_mode;
+		m->port = bm->port;
+		setup_mc_addrs(m, &sin);
+
+		m->enabled = true;
+	}
+	check_joins(NULL);
+	b->active = true;
+}
+
+static void disable_bridge(struct bridge_state *b)
+{
+	logg(LOG_INFO, "Stopping to bridge for %s\n", inet_ntoa(b->origin[0]));
+
+	leave_mc(INFINIBAND, b);
+	leave_mc(ROCE, b);
+	b->active = false;
+}
+
+static void check_remote_bridges(void)
+{
+	struct bridge_state *b;
+
+	now = timestamp();
+
+	for(b = remote_bridge; b < remote_bridge + nr_bridges; b++)
+		if (b->active && b->expiration && now > b->expiration)
+		{
+			enable_bridge(b);
+		}
+}
+
+static void prep_beacon_struct(struct i2r_interface *i, struct buf *buf)
 {
+	struct beacon_info *b = (void *)buf->raw;
 	enum interfaces in = i - i2r;
 	struct mc *m;
 
+	buf->cur = buf->raw + sizeof(struct beacon_info);
+
 	b->signature = BEACON_SIGNATURE;
 	memcpy(b->version, VERSION, 10);
 	b->infiniband = in == INFINIBAND;
-	b->beacon_port = beacon_sin->sin_port;
-	b->beacon_mc = beacon_sin->sin_addr;
-	b->bridge_addr = i2r[in].if_addr.sin_addr;
-	b->to_addr = i2r[in^1].if_addr.sin_addr;
+	b->sessionid = sessionid;
+	b->addr[INFINIBAND] = i2r[INFINIBAND].if_addr.sin_addr;
+	b->addr[ROCE] = i2r[ROCE].if_addr.sin_addr;
+	b->hold_time = beacon_interval * 3 + beacon_interval / 2;
 	b->nr_mc = nr_mc;
 	b->nr_tsi = i2r[INFINIBAND].nr_tsi;
 	if (b->nr_tsi < i2r[ROCE].nr_tsi)
 		b->nr_tsi = i2r[ROCE].nr_tsi;
 
 	for(m = mcs; m < mcs + nr_mc; m++) {
-		b->mc[m - mcs].addr = m->addr;
-		b->mc[m - mcs].port = m->port;
+		struct beacon_multicast *bm = (void *)buf->cur;
+
+		if (m->admin || !m->enabled || m->bridge)
+			continue;
+
+		bm->group = m->addr;
+		bm->tos_mode = m->tos_mode;
+		bm->port = m->port;
+		bm->sendonly[INFINIBAND] = m->interface[INFINIBAND].sendonly;
+		bm->sendonly[ROCE] = m->interface[ROCE].sendonly;
+		bm->mgid_mode = m->mgid_mode;
+
+		buf->cur += sizeof(struct beacon_multicast);
 	}
+
+	/* Max MTU is 4096 bytes */
+	if (buf->cur > buf->raw + 4096)
+		abort();
+
+	b->timestamp = now = timestamp();
+	buf->end = buf->cur;
 }
 
 static void beacon_received(struct mc *m, enum interfaces in, struct buf *buf)
 {
 	struct beacon_info *b = (struct beacon_info *)buf->cur;
+	struct bridge_state *r;
 	char bridge[40];
 	uint64_t diff;
 
@@ -109,17 +198,67 @@ static void beacon_received(struct mc *m
 	}
 
 	now = timestamp();
-	strcpy(bridge, inet_ntoa(b->bridge_addr));
-	diff = b->t - now;
+	if (buf->ip_valid) {
+		struct in_addr x;
+
+		x.s_addr = buf->ip.saddr;
+		strcpy(bridge, inet_ntoa(x));
+	}
+	else
+		inet_ntop(AF_INET6, &buf->grh.sgid, bridge, INET6_ADDRSTRLEN);
+
+	diff = b->timestamp - now;
 
-	logg(LOG_NOTICE, "Received Beacon on %s Version %s Bridge=%s(%s), BridgeTo=%s MC groups=%u, TSIs=%d. Latency %ld ns GatewayQP=%u\n",
+	logg(LOG_NOTICE, "Received Beacon on %s Version %s Bridge=%s(%s), Bridge=%s MC groups=%u, TSIs=%d. Latency %ld ns\n",
 		beacon_mc->text, b->version, bridge, b->infiniband ? "Infiniband" : "ROCE",
-		inet_ntoa(b->to_addr), b->nr_mc, b->nr_tsi, diff, b->gateway_qp);
+		inet_ntoa(b->addr[0]), b->nr_mc, b->nr_tsi, diff);
+
+	/* See if we already have that bridge */
+	for(r = remote_bridge; r < remote_bridge + nr_bridges; r++)
+		if (r->origin[0].s_addr == b->addr[0].s_addr && r->origin[1].s_addr == b->addr[1].s_addr)
+			break;
+
+	if (r < remote_bridge + nr_bridges) {
+		if (nr_bridges < MAX_BRIDGES) {
+			/* New bridge */
+			nr_bridges++;
+			r->active = false;
+			r->origin[0] = b->addr[0];
+			r->origin[1] = b->addr[1];
+
+		} else {
+			logg(LOG_ERR, "Too many bridges. Max is %d\n", MAX_BRIDGES);
+			return;
+		}
+	}
+
+	r->beacons_received++;
+	if (r->last.sqn && r->last.sqn != b->sqn) {
+		int missed = b->sqn - r->last.sqn + 1;
+
+		r->beacons_missed++;
+		logg(LOG_NOTICE, "%d beacons missed on %s\n", missed, buf->c->i->text);
+	}
+
+	if (!b->hold_time) {	/* Remote request to forget all information */
+
+		r->expiration = 0;	/* That means it is exempt from expiration scans */
+
+		if (r->active)
+			disable_bridge(r);
+
+		return;
+	}
+	if (r->active) {
+		/* Received a beacon for a bridge that we took over */
+		disable_bridge(r);
+	}
+	memcpy(&r->last, b, sizeof(struct beacon_info));
+	r->expiration = timestamp() + milliseconds(b->hold_time);
 }
 
 static void beacon_send(void *private)
 {
-	struct beacon_info b;
 	struct buf *buf;
 
 	if (beacon_mc) {
@@ -127,23 +266,15 @@ static void beacon_send(void *private)
 
 		for(in = 0; in < NR_INTERFACES; in++) {
 			struct i2r_interface *i = i2r + in;
-			prep_beacon_struct(i, &b);
-			b.t = now = timestamp();
-
-
 			if (i->context && beacon_mc->interface[in].status == MC_JOINED) {
-				if (sizeof(b) > MAX_INLINE_DATA) {
-					buf = alloc_buffer(i->multicast);
-					memcpy(buf->raw, &b, sizeof(b));
-					send_to(i->multicast, buf, sizeof(b), &beacon_mc->interface[in].ai, false, 0, buf);
-				} else
-					send_inline(i->multicast, &b, sizeof(b), &beacon_mc->interface[in].ai, false, 0);
+
+				buf = alloc_buffer(i->multicast);
+				prep_beacon_struct(i, buf);
+				send_to(i->multicast, buf->raw, buf->end - buf->raw, &beacon_mc->interface[in].ai, false, 0, buf);
 			}
 		}
 
-	}
-#ifdef UNICAST
-	else {
+	} else { /* Unicast */
 		struct i2r_interface *i = find_interface(beacon_sin);
 
 		if (!i) {
@@ -152,43 +283,48 @@ static void beacon_send(void *private)
 			return;
 		}
 		buf = alloc_buffer(i->multicast);
-		prep_beacon_struct(i, &b);
-		memcpy(buf->raw, &b, sizeof(b));
+		prep_beacon_struct(i, buf);
 
 		reset_flags(buf);
 		buf->cur = buf->raw;
-		buf->end = buf->cur + sizeof(b);
-
+		buf->end = buf->cur + sizeof(struct beacon_info);
 		send_buf_to(i, buf, beacon_sin);
 
 	}
-#endif
-	add_event(timestamp() + seconds(10), beacon_send, NULL, "Send Beacon");
+
+	check_remote_bridges();
+	if (beacon_interval)
+		add_event(timestamp() + milliseconds(beacon_interval), beacon_send, NULL, "Send Beacon");
+}
+
+void beacon_shutdown(void)
+{
+	/* Send a beacon with a 0 hold time to expire all information at the other bridges */
+	beacon_interval = 0;
+	beacon_send(NULL);
 }
 
 void beacon_setup(void)
 {
-	struct mgid_signature *mgid;
+	uint8_t mgid;
 	struct in_addr addr;
 	uint8_t tos;
 
 	if (!beacon)
 		return;
 
-	if (!beacon_arg)
-		beacon_arg = "239.1.2.3";
-
 	beacon_mc = NULL;
-	beacon_sin = parse_addr(beacon_arg, default_mc_port, &mgid, &tos, false);
+	beacon_sin = parse_addr(BEACON_MC_ADDR, BEACON_PORT, &mgid, &tos, false);
 	addr = beacon_sin->sin_addr;
 	if (IN_MULTICAST(ntohl(addr.s_addr))) {
 		struct mc *m = mcs + nr_mc++;
 
 		memset(m, 0, sizeof(*m));
-		m->text = strdup(beacon_arg);
+		m->text = BEACON_MC_ADDR;
 		m->mgid_mode = mgid;
 		m->tos_mode = tos;
 		m->addr = addr;
+		m->admin = true;
 
 		setup_mc_addrs(m, beacon_sin);
 
@@ -199,21 +335,73 @@ void beacon_setup(void)
 			beacon_sin = NULL;
 		} else
 			beacon_mc = m;
+
 		m->callback = beacon_received;
 	}
-	add_event(timestamp() + ONE_SECOND, beacon_send, NULL, "Send Beacon");
+
+	/*
+	 * First hello should have a random interval offset for each bridge if multiple
+	 * are starting up simultaneously.
+	 *
+	 * Also the first hello is delayed to ensure the bridges are all up and running
+	 * and have stabilized.
+	 */
+	add_event(timestamp() + seconds(5) + rand() % beacon_interval,
+			beacon_send, NULL, "Send Beacon");
 }
 
 static void beacon_option(char *optarg)
 {
 	beacon = true;
 
-	beacon_arg = optarg;
+	if (optarg)
+		beacon_interval = atoi(optarg);
+}
+
+/* Print the bridge states */
+static void beacon_cmd(char *parameters)
+{
+	struct bridge_state *b;
+
+	if (!nr_bridges) {
+		printf("No remote bridges detected\n");
+		return;
+	}
+
+	printf("Nr|Origin   |SessID|Time to Expire|Active |Received | Missed\n");
+	printf("--+---------+------+--------------+-------+---------+-------\n");
+
+	for(b = remote_bridge; b < remote_bridge + nr_bridges; b++) {
+		char ex[30];
+		char origin_roce[INET_ADDRSTRLEN];
+
+		if (b->expiration && b->expiration > now)
+			sprintf(ex, "%ld ms", (b->expiration - now / ONE_MILLISECOND));
+		else
+			strcpy(ex, "Expired");
+
+		inet_ntop(AF_INET, &b->origin[ROCE], origin_roce, INET_ADDRSTRLEN);
+
+		printf("%2ld|%20s|%10x|%s|%s|%10d|%10d\n",
+				(b - remote_bridge) + 1,
+				b->last.name,
+				b->last.sessionid,
+				ex,
+				b->active ? "Bridging" : "Monitoring",
+				b->beacons_received,
+				b->beacons_missed);
+	}
 }
 
 __attribute__((constructor))
 static void beacon_init(void) {
 	register_option("beacon", optional_argument, 'b', beacon_option,
-			"<multicast address>/<unicast address>", "Send beacon every second. Off by default");
+			"<time in milliseconds>", "Send beacon in given milliseconds. 1 second by default");
+	register_enable("beaconinterval", true, NULL, &beacon_interval, "100", "0", NULL, "Beacon Interval");
+	register_concom("beacons", true, 0, "Show Beacon info", beacon_cmd);
+
+	sessionid = rand();
+	if (gethostname(hostname, sizeof(hostname) < 0))
+			logg(LOG_CRIT, "Cannot determine hostname: %s\n", errname());
 }
 
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -292,6 +292,9 @@ void receive_multicast(struct buf *buf)
 		goto invalid_packet;
 	}
 
+	if (!m->enabled)
+		return;
+
 	if (m->interface[in].sendonly) {
 
 		logg(LOG_INFO, "Discard Packet: Received data from Sendonly MC group %s from %s\n",
@@ -1631,6 +1634,7 @@ int main(int argc, char **argv)
 	if (event_loop() <0)
 		logg(LOG_ERR, "Event Loop failed with %s\n", errname());
 
+	beacon_shutdown();
 	stop_cores();
 
 	if (background)
Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- rdma-core.orig/ib2roce/interfaces.c
+++ rdma-core/ib2roce/interfaces.c
@@ -545,7 +545,7 @@ void shutdown_ib(void)
 	if (!i2r[INFINIBAND].context)
 		return;
 
-	leave_mc(INFINIBAND);
+	leave_mc(INFINIBAND, NULL);
 
 	/* Shutdown Interface */
 	qp_destroy(i2r + INFINIBAND);
@@ -556,7 +556,7 @@ void shutdown_roce(void)
 	if (!i2r[ROCE].context)
 		return;
 
-	leave_mc(ROCE);
+	leave_mc(ROCE, NULL);
 
 	/* Shutdown Interface */
 	qp_destroy(i2r + ROCE);
@@ -615,7 +615,7 @@ void handle_rdma_event(void *private)
 					param->ah_attr.sl,
 					i->text);
 				st(i->multicast, join_success);
-
+				m->enabled = true;
 				set_rate(m);
 			}
 			break;
Index: rdma-core/ib2roce/beacon.h
===================================================================
--- rdma-core.orig/ib2roce/beacon.h
+++ rdma-core/ib2roce/beacon.h
@@ -37,6 +37,51 @@
  *
  */
 
-void beacon_setup(void);
+/*
+ * Multicast state in the beacon packet
+ */
+struct beacon_multicast {
+	struct in_addr group;
+	bool sendonly[2];
+	uint8_t tos_mode;
+	uint8_t mgid_mode;
+	uint16_t port;
+};
+
+/*
+ * Beacon info
+ */
+struct beacon_info {
+	unsigned long signature;
+	char version[10];
+	char name[20];			/* The Hostname of the remote bridge */
+	unsigned sessionid;		/* Unique session id created on startup */
+	unsigned hold_time;		/* Validity of the Beacon Info */
+	unsigned sqn;
+	uint64_t timestamp;
+	bool infiniband;
+	struct in_addr addr[2];		/* Addresses of the bridge */
+	unsigned nr_mc;			/* Active Multicast */
+	unsigned nr_tsi;		/* Active TSIs */
+	struct beacon_multicast mc[];	/* nr_mc beacon_jp_multicast instances follow */
+};
 
+/*
+ * Remote bridge states: This is controlled by the beacons that will refresh
+ * the expiration time. If the expiration occurs then the bridge will take subscribe
+ * to all the multicast groups of that bridge.
+ * If a new beacon is encoutered from that bridge then there will be an unsubscribe.
+ */
+struct bridge_state {
+	unsigned long expiration;
+	bool active;
+	struct in_addr origin[2];
+	unsigned beacons_missed;
+	unsigned beacons_received;
+	struct beacon_info last;
+};
+
+void beacon_setup(void);
+void beacon_shutdown(void);
 #endif
+
Index: rdma-core/ib2roce/multicast.h
===================================================================
--- rdma-core.orig/ib2roce/multicast.h
+++ rdma-core/ib2roce/multicast.h
@@ -96,6 +96,9 @@ struct mc {
 	struct in_addr addr;
 	struct mc_interface interface[2];
 	void (*callback)(struct mc *, enum interfaces, struct buf *);
+	struct bridge_state *bridge;		/* Set if its a remote bridge */
+	bool enabled;				/* Is forwarding active ? */
+	bool admin;				/* Administrative group */
 	uint8_t tos_mode;
 	uint8_t mgid_mode;
 	uint16_t port;
@@ -118,7 +121,7 @@ int _join_mc(struct in_addr addr, struct
 	unsigned port, uint8_t tos, enum interfaces i, bool sendonly, void *private);
 int _leave_mc(struct in_addr addr,struct sockaddr *si, enum interfaces i);
 
-int leave_mc(enum interfaces i);
+int leave_mc(enum interfaces i, struct bridge_state *);
 
 void check_joins(void *);
 
Index: rdma-core/ib2roce/multicast.c
===================================================================
--- rdma-core.orig/ib2roce/multicast.c
+++ rdma-core/ib2roce/multicast.c
@@ -66,6 +66,7 @@
 #include "interfaces.h"
 #include "multicast.h"
 #include "cli.h"
+#include "beacon.h"
 
 unsigned default_mc_port = 4711;	/* Port for MC groups that do not have a port (if a port is required) */
 uint8_t tos_mode = 0;
@@ -403,7 +404,7 @@ int _leave_mc(struct in_addr addr,struct
 	return 0;
 }
 
-int leave_mc(enum interfaces i)
+int leave_mc(enum interfaces i, struct bridge_state *br)
 {
 	int j;
 	int ret;
@@ -411,6 +412,10 @@ int leave_mc(enum interfaces i)
 	for (j = 0; j < nr_mc; j++) {
 		struct mc *m = mcs + j;
 
+		if (br && m->bridge != br)
+			continue;
+
+		m->enabled = false;
 		ret = _leave_mc(m->addr, m->interface[i].sa, i);
 		if (ret)
 			return 1;
@@ -432,6 +437,9 @@ static void join_processing(void)
 		struct mc *m = mcs + i;
 		unsigned port = m->port;
 
+		if (!m->enabled)
+			continue;
+
 		if (m->interface[ROCE].status == MC_JOINED && m->interface[INFINIBAND].status == MC_JOINED)
 			continue;
 
@@ -511,18 +519,24 @@ static void multicast_cmd(char *paramete
 	for(m = mcs; m < mcs + nr_mc; m++) {
 
 		for(enum interfaces in = INFINIBAND; in <= ROCE; in++) {
-			printf("%s %s %s %s %s packet_time=%dns, max_burst=%d packets, delayed=%ld packets, last_sent=%ldms ago, last_delayed=%ldms ago, pending=%u packets, burst=%d\n",
-				interfaces_text[in], m->text,
-			mc_text[m->interface[in].status],
-			m->interface[in].sendonly ? "Sendonly " : "",
-			in == INFINIBAND ? mgid_text(m) : "",
-			m->interface[in].packet_time,
-			m->interface[in].max_burst,
-			m->interface[in].delayed,
-			m->interface[in].last_sent ? (now - m->interface[in].last_sent) / ONE_MILLISECOND : -999,
-			m->interface[in].last_delayed ? (now - m->interface[in].last_delayed) / ONE_MILLISECOND : -999,
-			m->interface[INFINIBAND].pending,
-			m->interface[in].burst);
+			printf("%s %s %s %s %s ", interfaces_text[in], m->text,
+				mc_text[m->interface[in].status],
+				m->interface[in].sendonly ? "Sendonly " : "",
+				in == INFINIBAND ? mgid_text(m) : "");
+			if (!m->enabled)
+				printf(" disabled");
+
+			if (m->bridge)
+				printf(" bridge %s", m->bridge->last.name);
+
+			printf("packet_time=%dns, max_burst=%d packets, delayed=%ld packets, last_sent=%ldms ago, last_delayed=%ldms ago, pending=%u packets, burst=%d\n",
+				m->interface[in].packet_time,
+				m->interface[in].max_burst,
+				m->interface[in].delayed,
+				m->interface[in].last_sent ? (now - m->interface[in].last_sent) / ONE_MILLISECOND : -999,
+				m->interface[in].last_delayed ? (now - m->interface[in].last_delayed) / ONE_MILLISECOND : -999,
+				m->interface[INFINIBAND].pending,
+				m->interface[in].burst);
 		}
 	}
 }
