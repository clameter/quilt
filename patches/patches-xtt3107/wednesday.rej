--- ib2roce/ib2roce.c
+++ ib2roce/ib2roce.c
@@ -1376,7 +1377,8 @@ static struct rdma_channel *create_chann
 	c->attr.port_num = port;
 	c->attr.qp_state = IBV_QPS_INIT;
 	c->attr.pkey_index = 0;
-	c->attr.qkey = RDMA_UDP_QKEY;
+	c->attr.qkey = IB_DEFAULT_QP1_QKEY;
+//	c->attr.qkey = RDMA_UDP_QKEY;
 
 //	c->attr.qkey = 0x12345;		/* Default QKEY from ibdump source code */
 
@@ -2852,92 +2927,38 @@ struct sidr_req {
 	uint64_t	service_id;
 } __packed;
 
-#if 0
-static void print_sidr(void)
-{
-	char *payload = alloca(1500);
-	struct sidr_req sr;
-
-	PULL(buf, sr);
-
-	buf->cur = buf->raw;
-	__hexbytes(payload, buf->cur, buf->end - buf->cur, ' ');
+struct sidr_rep {
+	uint32_t request_id;
+	uint8_t	status;
+	uint8_t ail;
+	uint16_t vendorid1;
+	uint32_t qpn;
+	uint64_t service_id;
+	uint32_t q_key;
+	char add_info[72];
+	char private[136];
+} __packed;
 
-	logg(LOG_NOTICE, "SIDR_REQ: %s APSN=%x method=%s status=%s attr_id=%s attr_mod=%x SID=%lx RID=%x pkey=%x %s\n",
-		header, buf->bth.apsn, umad_method_str(buf->umad.mgmt_class, buf->umad.method),
-		umad_common_mad_status_str(buf->umad.status),
-		umad_attribute_str(buf->umad.mgmt_class, buf->umad.attr_id), ntohl(buf->umad.attr_mod),
-		be64toh(sr.service_id), ntohl(sr.request_id), ntohs(sr.pkey),
-		payload);
-}
+struct hash *sidrs;
 
-#endif
+struct sidr_state {
+	uint32_t request_id;		/* Should be generated locally in the future */
+	struct endpoint *source;
+	struct endpoint *dest;
+};
 
-/*
- * Simple listener to quickly gather IP/ GID information off the wire
- */
-static const char *process_arp(struct i2r_interface *i, struct buf *buf, uint16_t lids[2])
+static void sidr_state_init(void)
 {
-	uint8_t mac[20];
-	unsigned j;
-	struct arphdr arp;
-
-	PULL(buf, arp);
-	
-	if (ntohs(arp.ar_op) != ARPOP_REPLY)
-       		return "-Only ARP replies supported";
-
-	if (arp.ar_pln != sizeof(struct in_addr))
-		return "ARP protocol length != 4";
-
-	if (ntohs(arp.ar_hrd) != ARPHRD_ETHER &&
-	    ntohs(arp.ar_hrd) != ARPHRD_INFINIBAND)
-		return "ARP implementation supports only Ethernet and Infiniband";
-
-	for (j = 0; j < 2; j++, buf->cur += arp.ar_hln + sizeof(struct in_addr)) {
-		struct endpoint *ep;
-
-		memcpy(mac, buf->cur, arp.ar_hln);
-		memcpy(&buf->addr, buf->cur + arp.ar_hln, sizeof(struct in_addr));
-
-		if (!valid_addr(i, buf->addr)) {
-			logg(LOG_NOTICE, "ARP REPLY: Invalid %sIP=%s MAC=%s\n",
-				j ? "Dest" : " Source",
-			       inet_ntoa(buf->addr),
-				hexbytes(mac, arp.ar_hln,':'));
-			continue;
-		}
-
-		ep = hash_find(i->ep, i2r + ROCE == i ? (void *)&buf->addr : (void *)(lids + j));
-		if (ep) {
-			if (!ep->addr.s_addr) {
-
-				ep->addr = buf->addr;
-				hash_add(i->ip_to_ep, ep);
-
-			} else if(ep->addr.s_addr != buf->addr.s_addr)
-
-				return "IP address for MAC changed!";
+	if (sizeof(struct umad_hdr) != 3 * 8)
+		abort();
 
-			continue;
-		}
+	if (sizeof(struct sidr_req) != 2 * 8)
+		abort();
 
-		buf->w->slid = lids[j];
-		ep = buf_to_ep(buf);
-		if (!ep)
-			return "Cannot create Endpoint";
+	if (sizeof(struct sidr_rep) != 3* 8 + 72 + 136)
+		abort();
 
-		logg(LOG_NOTICE, "ARP: Created Endpoint IP=%s LID=%x\n", inet_ntoa(ep->addr), ep->lid);
-		memcpy(&ep->gid, mac, arp.ar_hln);
-		if (lids[j]) {
-			if (ep->lid) {
-				hash_del(i->ep, ep);
-				ep->lid = lids[j];
-				hash_add(i->ep, ep);
-			}
-		}
-	}
-	return NULL;
+	sidrs = hash_create(offsetof(struct sidr_state, request_id), sizeof(uint32_t));
 }
 
 static const char *sidr_req(struct buf *buf, void *mad_pos, unsigned short dlid)
