Index: rdma-core/ib2roce/multicast.c
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/multicast.c
@@ -0,0 +1,488 @@
+/*
+ * RDMA / Socket Multicast Support
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <numa.h>
+#include <stdatomic.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <rdma/rdma_cma.h>
+#include <infiniband/ib.h>
+#include <infiniband/verbs.h>
+#include <poll.h>
+#include <sys/mman.h>
+
+#include <linux/rtnetlink.h>
+#include <net/ethernet.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/if_arp.h>
+#include <linux/if_packet.h>
+#include <infiniband/mad.h>
+#include <infiniband/umad_cm.h>
+#include <infiniband/umad_str.h>
+#include <execinfo.h>
+#include "packet.h"
+#include "errno.h"
+#include "bth_hdr.h"
+#include "ib_hdrs.h"
+#include "fifo.h"
+#include "ring.h"
+#include "hash.h"
+#include "sched.h"
+#include "logging.h"
+#include "locking.h"
+#include "buffers.h"
+#include "interfaces.h"
+#include "multicast.h"
+
+unsigned default_mc_port = 4711;	/* Port for MC groups that do not have a port (if a port is required) */
+/*
+ * Multicast Handling (follows the limit per QP as stated in device_attr for ConnectX6)
+ */
+unsigned nr_mc;
+unsigned active_mc;	/* MC groups actively briding */
+
+const char *mc_text[NR_MC_STATUS] = { "Inactive", "Joining", "Joined", "Error" };
+
+struct mc mcs[MAX_MC];
+
+struct hash *mc_hash;
+
+struct mc *hash_lookup_mc(struct in_addr addr)
+{
+	unsigned a = ntohl(addr.s_addr) | 0xe0000000; /* Infiniband may strip top 4 bits so provide them */
+	struct in_addr x = {
+		.s_addr = htonl(a)
+	};
+
+	return hash_find(mc_hash, &x);
+}
+
+int hash_add_mc(struct mc *m)
+{
+	lock();
+
+	if (hash_find(mc_hash, &m->addr)) {
+		unlock();
+		return -EEXIST;
+	}
+
+	hash_add(mc_hash, m);
+
+	unlock();
+	return 0;
+}
+
+/*
+ * Handling of special Multicast Group MGID encodings on Infiniband
+ */
+#define nr_mgid_signatures 5
+
+static struct mgid_signature {		/* Manage different MGID formats used */
+	unsigned short signature;
+	const char *id;
+	bool port;		/* Port field is used in MGID */
+	bool full_ipv4;		/* Full IP address */
+	bool pkey;		/* Pkey in MGID */
+} mgid_signatures[nr_mgid_signatures] = {
+	{	0x0000, "RDMA", false, false, true },
+	{	0x401B,	"IPv4",	false, false, true },
+	{	0x601B,	"IPv6",	false, false, true },
+	{	0xA01B,	"CLLM", true, true, false },
+	{	0x4001, "IB",	false, false, false }
+};
+
+static struct mgid_signature *mgid_mode = mgid_signatures + 3;		/* CLLM is the default */
+
+
+static struct mgid_signature *__find_mgid_mode(char *p)
+{
+	struct mgid_signature *g;
+
+	for(g = mgid_signatures; g < mgid_signatures + nr_mgid_signatures; g++)
+		if (strcasecmp(p, g->id) == 0)
+			return g;
+
+	return NULL;
+}
+
+bool find_mgid_mode(char *p)
+{
+	struct mgid_signature *g = __find_mgid_mode(p);
+
+	if (!g) {
+		fprintf(stderr, "Not a valid mgid mode %s\n", p);
+		return false;
+	}
+	mgid_mode = g;
+	return true;
+}
+
+/* Setup the addreses for ROCE and INFINIBAND based on a ipaddr:port spec */
+void setup_mc_addrs(struct mc *m, struct sockaddr_in *si)
+{
+	m->interface[ROCE].sa = (struct sockaddr  *)si;
+	m->port = ntohs(si->sin_port);
+	m->interface[INFINIBAND].sa = m->interface[ROCE].sa;
+
+	if (m->mgid_mode->signature) {
+		/*
+		 * MGID is build according to according to RFC 4391 Section 4
+		 * by taking 28 bits and putting them into the mgid
+		 *
+		 * But then CLLM and others include the full 32 bit...
+		 * Deal with this crappy situation.
+		 */
+		struct sockaddr_ib *saib	= calloc(1, sizeof(struct sockaddr_ib));
+		unsigned short *mgid_header	= (unsigned short *)saib->sib_addr.sib_raw;
+		unsigned short *mgid_signature	= (unsigned short *)(saib->sib_addr.sib_raw + 2);
+		unsigned short *mgid_pkey	= (unsigned short *)(saib->sib_addr.sib_raw + 4);
+		unsigned short *mgid_port	= (unsigned short *)(saib->sib_addr.sib_raw + 10);
+		unsigned int *mgid_ipv4		= (unsigned int *)(saib->sib_addr.sib_raw + 12);
+		unsigned int multicast = ntohl(m->addr.s_addr);
+		struct mgid_signature *mg = m->mgid_mode;
+
+		saib->sib_family = AF_IB,
+		saib->sib_sid = si->sin_port;
+
+		*mgid_header = htons(0xff15);
+		*mgid_signature = htons(mg->signature);
+
+		if (mg->pkey)
+			/* WTF? Where do we get the pkey from ? */
+			*mgid_pkey = 0xFFFF;
+
+		if (mg->port)
+			*mgid_port = si->sin_port;
+
+		if (!mg->full_ipv4)
+			/* Strip to 28 bits according to RFC */
+			multicast &= 0x0fffffff;
+
+		*mgid_ipv4 = htonl(multicast);
+
+		m->interface[INFINIBAND].sa = (struct sockaddr *)saib;
+	}
+}
+
+/*
+ * Parse an address with port number [:xxx] and/or mgid format [/YYYY]
+ */
+struct sockaddr_in *parse_addr(const char *arg, int port,
+	struct mgid_signature **p_mgid_mode, uint8_t *p_tos_mode, bool mc_only)
+{
+	struct addrinfo *res;
+	char *service;
+	const struct addrinfo hints = {
+		.ai_family = AF_INET,
+		.ai_socktype = SOCK_DGRAM,
+		.ai_protocol = IPPROTO_UDP
+	};
+	struct sockaddr_in *si;
+	char *p, *q;
+	int ret;
+	struct mgid_signature *mgid;
+	struct in_addr addr;
+	uint8_t tos;
+	char *a = strdupa(arg);
+
+	service = strchr(a, ':');
+
+	if (service) {
+
+		*service++ = 0;
+		p = service;
+
+	} else {
+		char *s = alloca(10);
+
+		snprintf(s, 10, "%d", port);
+		service = s;
+		p = a;
+	}
+
+	q = strchr(p, '/');
+	if (q) {
+		*q++ = 0;
+		mgid = __find_mgid_mode(q);
+
+		if (!mgid) {
+			fprintf(stderr, "MGID mode not found %s\n", p);
+			return NULL;
+		}
+		p = q;
+	} else
+		mgid = mgid_mode;
+
+	q = strchr(p, '#');
+	if (q) {
+		*q++ = 0;
+		tos = atoi(q);
+		if (!tos) {
+			fprintf(stderr, "TOS value invalid : %p\n", p);
+			return NULL;
+		}
+	} else
+		tos = tos_mode;
+
+	ret = getaddrinfo(a, service, &hints, &res);
+	if (ret) {
+		fprintf(stderr, "getaddrinfo() failed (%s) - invalid IP address.\n", gai_strerror(ret));
+		return NULL;
+	}
+
+	si = malloc(sizeof(struct sockaddr_in));
+	memcpy(si, res->ai_addr, sizeof(struct sockaddr_in));
+	freeaddrinfo(res);
+
+	addr = si->sin_addr;
+	if (mc_only && !IN_MULTICAST(ntohl(addr.s_addr))) {
+		fprintf(stderr, "Not a multicast address (%s)\n", arg);
+		return NULL;
+	}
+
+	*p_mgid_mode = mgid;
+	*p_tos_mode = tos;
+	return si;
+}
+
+const char * mgid_text(struct mc *m)
+{
+	if (m)
+		return m->mgid_mode->id;
+	else
+		return mgid_mode->id;
+}
+
+void mgids_out(void)
+{
+	int n;
+
+	printf("List of supported MGID formats via -l<id>\n");
+	printf("=================================\n");
+	printf(" ID    | Signature | Port in MGID\n");
+	printf("-------+-----------+-------------\n");
+	for (n = 0; n < nr_mgid_signatures; n++) {
+		struct mgid_signature *m = mgid_signatures + n;
+
+			printf("%7s|    0x%04x | %s\n",
+					m->id, m->signature, m->port ? "true" : "false");
+	}
+}
+
+bool mgid_check(struct mc *m, unsigned short signature)
+{
+	if (m->mgid_mode->signature) {
+		if (signature != m->mgid_mode->signature)
+			return false;
+	}
+	return true;
+}
+
+/* Multicast group specifications on the command line */
+int new_mc_addr(char *arg,
+	bool sendonly_infiniband,
+	bool sendonly_roce)
+{
+	struct sockaddr_in *si;
+	struct mc *m = mcs + nr_mc;
+	int ret;
+
+	if (nr_mc == MAX_MC) {
+		fprintf(stderr, "Too many multicast groups\n");
+		return 1;
+	}
+
+	m->interface[INFINIBAND].sendonly = sendonly_infiniband;
+	m->interface[ROCE].sendonly = sendonly_roce;
+	m->text = strdup(arg);
+
+	si = parse_addr(arg, default_mc_port, &m->mgid_mode, &m->tos_mode, true);
+	if (!si)
+		return 1;
+
+	m->addr = si->sin_addr;
+	ret = hash_add_mc(m);
+	if (ret) {
+		fprintf(stderr, "Duplicate multicast address (%s)\n", arg);
+		goto out;
+	}
+
+	setup_mc_addrs(m, si);
+	nr_mc++;
+	ret = 0;
+
+out:
+	return ret;
+}
+
+int _join_mc(struct in_addr addr, struct sockaddr *sa,
+	unsigned port, uint8_t tos, enum interfaces i, bool sendonly, void *private)
+{
+	struct rdma_cm_join_mc_attr_ex mc_attr = {
+		.comp_mask = RDMA_CM_JOIN_MC_ATTR_ADDRESS | RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS,
+		.join_flags = sendonly ? RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER
+                                       : RDMA_MC_JOIN_FLAG_FULLMEMBER,
+		.addr = sa
+	};
+	int ret;
+
+	ret = rdma_join_multicast_ex(id(i), &mc_attr, private);
+
+	if (ret) {
+		logg(LOG_CRIT, "Failed to create join request %s:%d on %s. Error %s\n",
+			inet_ntoa(addr), port,
+			interfaces_text[i],
+			errname());
+		return 1;
+	}
+	logg(LOG_NOTICE, "Join Request %sMC group %s:%d on %s.\n",
+		sendonly ? "Sendonly " : "",
+		inet_ntoa(addr), port,
+		interfaces_text[i]);
+	st(i2r[i].multicast, join_requests);
+	return 0;
+}
+
+int _leave_mc(struct in_addr addr,struct sockaddr *si, enum interfaces i)
+{
+	int ret;
+
+	ret = rdma_leave_multicast(id(i), si);
+	if (ret) {
+		logg(LOG_ERR, "Failure on rdma_leave_multicast on %s:%s\n", interfaces_text[i], inet_ntoa(addr));
+		return 1;
+	}
+	logg(LOG_NOTICE, "Leaving MC group %s on %s .\n",
+		inet_ntoa(addr),
+		interfaces_text[i]);
+	st(i2r[i].multicast, leave_requests);
+	return 0;
+}
+
+int leave_mc(enum interfaces i)
+{
+	int j;
+	int ret;
+
+	for (j = 0; j < nr_mc; j++) {
+		struct mc *m = mcs + j;
+
+		ret = _leave_mc(m->addr, m->interface[i].sa, i);
+		if (ret)
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * Join MC groups. This is called from the event loop every second
+ * as long as there are unjoined groups
+ */
+void join_processing(void)
+{
+	int i;
+	enum interfaces in;
+	int mcs_per_call = 0;
+
+	for (i = 0; i < nr_mc; i++) {
+		struct mc *m = mcs + i;
+		unsigned port = m->port;
+
+		if (m->interface[ROCE].status == MC_JOINED && m->interface[INFINIBAND].status == MC_JOINED)
+			continue;
+
+		for(in = 0; in < 2; in++) {
+			struct mc_interface *mi = m->interface + in;
+			uint8_t tos = i == ROCE ? m->tos_mode : 0;
+
+			if (i2r[in].context) {
+				switch(mi->status) {
+
+				case MC_OFF:
+					if (_join_mc(m->addr, mi->sa, port, tos, in, mi->sendonly, m) == 0)
+						m->interface[in].status = MC_JOINING;
+					break;
+
+				case MC_ERROR:
+
+					_leave_mc(m->addr, mi->sa, in);
+					mi->status = MC_OFF;
+					logg(LOG_WARNING, "Left Multicast group %s on %s due to MC_ERROR\n",
+						m->text, interfaces_text[in]);
+					break;
+
+				case MC_JOINED:
+					break;
+
+				default:
+					logg(LOG_ERR, "Bad MC status %d MC %s on %s\n",
+					       mi->status, m->text, interfaces_text[in]);
+					break;
+				}
+			}
+		}
+
+		mcs_per_call++;
+
+		if (mcs_per_call > 10)
+			break;
+
+	}
+}
+
+void multicast_init(void) {
+	mc_hash = hash_create(offsetof(struct mc, addr), sizeof(struct in_addr));
+}
+
Index: rdma-core/ib2roce/multicast.h
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/multicast.h
@@ -0,0 +1,168 @@
+#ifndef IB2ROCE_MULTICAST
+#define IB2ROCE_MULTICAST
+/*
+ * RDMA / Socket Multicast Support
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <numa.h>
+#include <stdatomic.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <rdma/rdma_cma.h>
+#include <infiniband/ib.h>
+#include <infiniband/verbs.h>
+#include <poll.h>
+#include <sys/mman.h>
+
+#include <linux/rtnetlink.h>
+#include <net/ethernet.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/if_arp.h>
+#include <linux/if_packet.h>
+#include <infiniband/mad.h>
+#include <infiniband/umad_cm.h>
+#include <infiniband/umad_str.h>
+#include "errno.h"
+#include "ib_hdrs.h"
+#include "fifo.h"
+#include "ring.h"
+#include "hash.h"
+#include "sched.h"
+#include "logging.h"
+#include "locking.h"
+#include "buffers.h"
+
+
+#define MAX_MC 240
+
+extern unsigned nr_mc;
+
+extern unsigned active_mc;	/* MC groups actively briding */
+
+enum mc_status { MC_OFF, MC_JOINING, MC_JOINED, MC_ERROR, NR_MC_STATUS };
+
+extern const char *mc_text[NR_MC_STATUS];
+
+extern uint8_t tos_mode;
+extern unsigned int default_mc_port;
+
+/* A multicast group.
+ *
+ * ah_info points to multicast address and QP number in use
+ * for the stream. There are no "ports" unless they are
+ * embedded in the GID (like done by CLLM).
+ *
+ * Multicast groups are setup before we enter multithreaded mode
+ * However, the state of joins etc may change in multithreaded
+ * mode. Access to that status information requires some care.
+ */
+struct mc_interface {
+	enum mc_status status;
+	bool sendonly;
+	struct ah_info ai;
+	struct sockaddr *sa;
+	uint32_t packet_time;		/* How much time must elapse for a packet to be sent 0 = disabled */
+	uint32_t max_burst;		/* How long can a burst last */
+	uint64_t last_sent;		/* Last time a packet was sent */
+	uint64_t last_delayed;		/* Last a delayed packet was scheduled */
+	unsigned pending;		/* How many packets are waiting to be sent */
+	unsigned burst;			/* # of packets encountered with pacing below packet_time */
+	unsigned long delayed;		/* Packets delayed */
+};
+
+struct mc {
+	struct in_addr addr;
+	struct mc_interface interface[2];
+	void (*callback)(struct mc *, enum interfaces, struct buf *);
+	uint8_t tos_mode;
+	uint16_t port;
+	struct mgid_signature *mgid_mode;
+	const char *text;
+};
+
+extern struct mc mcs[MAX_MC];
+
+int hash_add_mc(struct mc *m);
+struct mc *hash_lookup_mc(struct in_addr addr);
+
+/* Setup the addreses for ROCE and INFINIBAND based on a ipaddr:port spec */
+void setup_mc_addrs(struct mc *m, struct sockaddr_in *si);
+/* Multicast group specifications on the command line */
+int new_mc_addr(char *arg,
+	bool sendonly_infiniband,
+	bool sendonly_roce);
+
+int _join_mc(struct in_addr addr, struct sockaddr *sa,
+	unsigned port, uint8_t tos, enum interfaces i, bool sendonly, void *private);
+int _leave_mc(struct in_addr addr,struct sockaddr *si, enum interfaces i);
+
+int leave_mc(enum interfaces i);
+
+void join_processing(void);
+
+/* MGID format processing */
+bool find_mgid_mode(char *p);
+
+struct sockaddr_in *parse_addr(const char *arg, int port,
+	struct mgid_signature **p_mgid_mode, uint8_t *p_tos_mode, bool mc_only);
+
+const char *mgid_text(struct mc *m);
+
+void mgids_out(void);
+
+bool mgid_check(struct mc *m, unsigned short signature);
+
+void multicast_init(void);
+
+#endif
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -83,6 +83,9 @@
 #include "logging.h"
 #include "locking.h"
 #include "buffers.h"
+#include "multicast.h"
+#include "interfaces.h"
+
 
 #include "ibraw.h"
 #include "cma-hdr.h"
@@ -103,12 +106,10 @@
 /* Globals */
 
 static unsigned default_port = 0;	/* Port to use to bind to devices  */
-static unsigned default_mc_port = 4711;	/* Port for MC groups that do not have a port (if a port is required) */
 static bool debug = false;		/* Stay in foreground, print more details */
 static bool background = false;		/* Are we actually running in the background ? */
 static bool update_requested = false;	/* Received SIGUSR1. Dump all MC data details */
 static bool beacon = false;		/* Announce our presence (and possibly coordinate between multiple instances in the future */
-static bool bridging = true;		/* Allow briding */
 #ifdef UNICAST
 static bool unicast = false;		/* Bridge unicast packets */
 static bool flow_steering = false;	/* Use flow steering to filter packets */
@@ -120,55 +121,19 @@ static bool testing = false;		/* Run som
 static bool latency = false;		/* Perform Latency tests and provide stats */
 static bool loopback_blocking = true;	/* Ask for loopback blocking on Multicast QPs */
 static int drop_packets = 0;		/* Packet dropper */
-static int rate = IBV_RATE_10_GBPS;	/* Limit sending rate */
-static int rrate = 0;			/* Software delay per message for ROCE */
-static int irate = 0;			/* Software delay per message for Infiniband */
-static int max_rburst = 10;		/* Dont delay until # of packets for ROCE */
-static int max_iburst = 10;		/* Dont delay until # of packets for Infiniband */
 static int stat_interval = 10;		/* Interval for statistics */
 static int loglevel = LOG_INFO;		/* LOG level for console output */
 
-static const char *inet6_ntoa(void *x)
-{
-	char buf[INET6_ADDRSTRLEN];
-
-	return inet_ntop(AF_INET6, x, buf, INET6_ADDRSTRLEN);
-}
-
 const struct in_addr ip_none = { .s_addr = 0 };
 
-/*
- * Handling of special Multicast Group MGID encodings on Infiniband
- */
-#define nr_mgid_signatures 5
-
-struct mgid_signature {		/* Manage different MGID formats used */
-	unsigned short signature;
-	const char *id;
-	bool port;		/* Port field is used in MGID */
-	bool full_ipv4;		/* Full IP address */
-	bool pkey;		/* Pkey in MGID */
-} mgid_signatures[nr_mgid_signatures] = {
-	{	0x0000, "RDMA", false, false, true },
-	{	0x401B,	"IPv4",	false, false, true },
-	{	0x601B,	"IPv6",	false, false, true },
-	{	0xA01B,	"CLLM", true, true, false },
-	{	0x4001, "IB",	false, false, false }
-};
-
-struct mgid_signature *mgid_mode = mgid_signatures + 3;		/* CLLM is the default */
-
 uint8_t tos_mode = 0;
 
 /*
  * Basic RDMA interface management
  */
 
-#define MAX_GID 20
 #define MAX_INLINE_DATA 64
 
-static char *ib_name, *roce_name;
-
 struct buf;
 
 typedef void event_callback(void *);
@@ -203,57 +168,6 @@ struct endpoint {
 	struct forward *forwards;
 };
 
-static struct i2r_interface {
-	/* Not changed when multithreading */
-	struct ibv_context *context;		/* Not for RDMA CM use */
-	struct rdma_event_channel *rdma_events;
-	struct rdma_channel *multicast;
-#ifdef UNICAST
-	struct rdma_channel *qp1;		/* Channel for QP1 communications but not QP1 (userspace) */
-	struct rdma_channel *ud;		/* Regular data */
-	struct rdma_channel *raw;
-#endif
-	struct ibv_comp_channel *comp_events;
-	struct ibv_cq *cq;
-	struct ibv_pd *pd;
-	struct ibv_mr *mr;
-	unsigned port;
-	unsigned mtu;
-	unsigned maclen;
-	const char *text;
-	char if_name[IFNAMSIZ];
-	const char *rdma_name;
-	uint8_t if_mac[ETH_ALEN];
-	struct sockaddr_in if_addr;
-	struct sockaddr_in if_netmask;
-	unsigned ifindex;
-	unsigned numa_node;			/* NUMA Affinity of the interface */
-	unsigned gid_index;
-	union ibv_gid gid;
-	struct ibv_device_attr device_attr;
-	struct ibv_port_attr port_attr;
-	int iges;
-	struct ibv_gid_entry ige[MAX_GID];
-
-	/* The following may be updated in a multithreaded environment
-	 * from the multicast thread running for each interface.
- 	 *
-         * Serialization is required but we generally are a bit loose
-	 * by allowing read access without locks.
-         */
-	struct hash *ru_hash;
-	struct fifo resolve_queue;		/* List of send buffers with unresolved addresses */
-	struct hash *ep;			/* Hash of all endpoints reachable here */
-	struct hash *ip_to_ep;			/* Hash based on IP address */
-	unsigned mc_rate_limited;		/* Number of MC groups where rate limiting is ongoing */
-	unsigned long out_of_buffer;		/* Last state of /sys/class/infiniband .../overrun */
-
-	/* PGM information:  Only updated from the multicast channel core */
-	unsigned nr_tsi;
-	struct hash *pgm_tsi_hash;
-	struct hash *pgm_record_hash;
-} i2r[NR_INTERFACES];
-
 #ifdef UNICAST
 /*
  * A Unicastconnection to a certain port and host with
@@ -273,496 +187,14 @@ struct rdma_unicast {
 #endif
 
 
-/* Forwards */
-static void handle_comp_event(void *private);
-static void handle_rdma_event(void *private);
-static void handle_async_event(void *private);
 #ifdef UNICAST
 static struct rdma_unicast *new_rdma_unicast(struct i2r_interface *i, struct sockaddr_in *sin);
 static void handle_receive_packet(void *private);
 #endif
 
-static inline struct rdma_cm_id *id(enum interfaces i)
-{
-	return i2r[i].multicast->id;
-}
-
-/* Check the RDMA device if it fits what was specified on the command line and store it if it matches */
-static int check_rdma_device(enum interfaces i, int port, char *name,
-	       struct ibv_context *c, struct ibv_port_attr *a, struct ibv_device_attr *d)
-{
-	char *s;
-	int p = 1;
-	const char *rdmadev = ibv_get_device_name(c->device);
-
-	if (i2r[i].context)
-		/* Already found a match */
-		return 0;
-
-	if (!name)
-		/* No command line option, take the first port/device */
-		goto success;
-
-	if (strncmp(name, rdmadev, strlen(rdmadev)))
-		return 0;
-
-	/* Port / device specified */
-	s = strchr(name, ':');
-	if (s) {
-		/* Portnumber follows device name */
-		p = atoi(s + 1);
-
-		if (port != p)
-			return 0;
-	}
-
-	s = strchr(name, '/');
-	if (s && i == INFINIBAND) {
-		/* IP device name follows */
-		char *q = s + 1;
-
-		while (isdigit(*q) || isalpha(*q))
-			 q++;
-
-		memcpy(i2r[INFINIBAND].if_name, s + 1, q - s - 1);
-	}
-
-success:
-	if (a->active_mtu == IBV_MTU_4096)
-		i2r[i].mtu = 4096;
-	else if (a->active_mtu == IBV_MTU_2048)
-		i2r[i].mtu = 2048;
-	else if (a->active_mtu == IBV_MTU_1024) 	/* Needed for rxe support */
-		i2r[i].mtu = 1024;
-	else
-		/* Other MTUs are not supported */
-		return 0;
-
-	i2r[i].context = c;
-	i2r[i].port = port;
-	i2r[i].port_attr = *a;
-	i2r[i].device_attr = *d;
-	i2r[i].rdma_name = rdmadev;
-	return 1;
-}
-
-/* Scan through available RDMA devices in order to locate the devices for bridging */
-static int find_rdma_devices(void)
-{
-	int nr;
-	int i;
-	struct ibv_device **list;
-
-	i2r[ROCE].rdma_name = i2r[INFINIBAND].rdma_name = "<disabled>";
-	list = ibv_get_device_list(&nr);
-
-	if (nr <= 0) {
-		logg(LOG_EMERG, "No RDMA devices present.\n");
-		return 1;
-	}
-
-	for (i = 0; i < nr; i++) {
-		struct ibv_device *d = list[i];
-		const char *name = ibv_get_device_name(d);
-		struct ibv_context *c;
-		struct ibv_device_attr dattr;
-		int found = 0;
-		int port;
-
-		if (d->node_type != IBV_NODE_CA)
-			continue;
-
-		if (d->transport_type != IBV_TRANSPORT_IB)
-			continue;
-
-		c = ibv_open_device(d);
-		if (!c) {
-			logg(LOG_EMERG, "Cannot open device %s\n", name);
-			return 1;
-		}
-
-		if (ibv_query_device(c, &dattr)) {
-			logg(LOG_EMERG, "Cannot query device %s\n", name);
-			return 1;
-		}
-
-		for (port = 1; port <= dattr.phys_port_cnt; port++) {
-			struct ibv_port_attr attr;
-
-			if (ibv_query_port(c, port, &attr)) {
-				logg(LOG_CRIT, "Cannot query port %s:%d\n", name, port);
-				return 1;
-			}
-
-			if (attr.link_layer == IBV_LINK_LAYER_INFINIBAND) {
-				if (check_rdma_device(INFINIBAND, port, ib_name, c, &attr, &dattr) &&
-					(!i2r[ROCE].mtu || i2r[ROCE].mtu == i2r[INFINIBAND].mtu))
-					found = 1;
-
-			} else if (attr.link_layer == IBV_LINK_LAYER_ETHERNET) {
-				if (check_rdma_device(ROCE, port, roce_name, c, &attr, &dattr) &&
-					(!i2r[INFINIBAND].mtu || i2r[ROCE].mtu == i2r[INFINIBAND].mtu))
-					found = 1;
-			}
-		}
-
-		if (!found)
-			ibv_close_device(c);
-	}
-
-
-	ibv_free_device_list(list);
-
-
-	if (!i2r[ROCE].context) {
-
-		if (roce_name && roce_name[0] == '-')
-			/* Disabled on the command line */
-			bridging = false;
-		else {
-			if (roce_name) {
-				logg(LOG_EMERG, "ROCE device %s not found\n", roce_name);
-				return 1;
-			}
-			/* There is no ROCE device so we cannot bridge */
-			bridging = false;
-		}
-	}
-
-	if (!i2r[INFINIBAND].context) {
-
-		if ((ib_name && ib_name[0] == '-') && bridging)
-			/* Disabled on the command line */
-			bridging = false;
-		else {
-			if (ib_name)
-				/* User specd IB device */
-				logg(LOG_EMERG, "Infiniband device %s not found.\n", ib_name);
-			else {
-				if (!bridging) {
-					logg(LOG_EMERG, "No RDMA Devices available.\n");
-					return 1;
-				}
-				/* We only have a ROCE device but we cannot bridge */
-				bridging = false;
-			}
-		}
-	}
-	return 0;
-}
-
 /*
  * Multicast Handling (follows the limit per QP as stated in device_attr for ConnectX6)
  */
-#define MAX_MC 240
-
-static unsigned nr_mc;
-static unsigned active_mc;	/* MC groups actively briding */
-
-enum mc_status { MC_OFF, MC_JOINING, MC_JOINED, MC_ERROR, NR_MC_STATUS };
-
-const char *mc_text[NR_MC_STATUS] = { "Inactive", "Joining", "Joined", "Error" };
-
-/* A multicast group.
- *
- * ah_info points to multicast address and QP number in use
- * for the stream. There are no "ports" unless they are
- * embedded in the GID (like done by CLLM).
- *
- * Multicast groups are setup before we enter multithreaded mode
- * However, the state of joins etc may change in multithreaded
- * mode. Access to that status information requires some care.
- */
-struct mc_interface {
-	enum mc_status status;
-	bool sendonly;
-	struct ah_info ai;
-	struct sockaddr *sa;
-	uint32_t packet_time;		/* How much time must elapse for a packet to be sent 0 = disabled */
-	uint32_t max_burst;		/* How long can a burst last */
-	uint64_t last_sent;		/* Last time a packet was sent */
-	uint64_t last_delayed;		/* Last a delayed packet was scheduled */
-	unsigned pending;		/* How many packets are waiting to be sent */
-	unsigned burst;			/* # of packets encountered with pacing below packet_time */
-	unsigned long delayed;		/* Packets delayed */
-};
-
-static struct mc {
-	struct in_addr addr;
-	struct mc_interface interface[2];
-	void (*callback)(struct mc *, enum interfaces, struct buf *);
-	uint8_t tos_mode;
-	uint16_t port;
-	struct mgid_signature *mgid_mode;
-	const char *text;
-} mcs[MAX_MC];
-
-struct hash *mc_hash;
-
-static struct mc *hash_lookup_mc(struct in_addr addr)
-{
-	unsigned a = ntohl(addr.s_addr) | 0xe0000000; /* Infiniband may strip top 4 bits so provide them */
-	struct in_addr x = {
-		.s_addr = htonl(a)
-	};
-
-	return hash_find(mc_hash, &x);
-}
-
-static int hash_add_mc(struct mc *m)
-{
-	lock();
-
-	if (hash_find(mc_hash, &m->addr)) {
-		unlock();
-		return -EEXIST;
-	}
-
-	hash_add(mc_hash, m);
-
-	unlock();
-	return 0;
-}
-
-static struct mgid_signature *find_mgid_mode(char *p)
-{
-	struct mgid_signature *g;
-
-	for(g = mgid_signatures; g < mgid_signatures + nr_mgid_signatures; g++)
-		if (strcasecmp(p, g->id) == 0)
-			break;
-
-	if (g >= mgid_signatures + nr_mgid_signatures) {
-		fprintf(stderr, "Not a valid mgid mode %s\n", p);
-		return NULL;
-	}
-	return g;
-}
-
-/*
- * Parse an address with port number [:xxx] and/or mgid format [/YYYY]
- */
-static struct sockaddr_in *parse_addr(const char *arg, int port,
-	struct mgid_signature **p_mgid_mode, uint8_t *p_tos_mode, bool mc_only)
-{
-	struct addrinfo *res;
-	char *service;
-	const struct addrinfo hints = {
-		.ai_family = AF_INET,
-		.ai_socktype = SOCK_DGRAM,
-		.ai_protocol = IPPROTO_UDP
-	};
-	struct sockaddr_in *si;
-	char *p, *q;
-	int ret;
-	struct mgid_signature *mgid;
-	struct in_addr addr;
-	uint8_t tos;
-	char *a = strdupa(arg);
-
-	service = strchr(a, ':');
-
-	if (service) {
-
-		*service++ = 0;
-		p = service;
-
-	} else {
-		char *s = alloca(10);
-
-		snprintf(s, 10, "%d", port);
-		service = s;
-		p = a;
-	}
-
-	q = strchr(p, '/');
-	if (q) {
-		*q++ = 0;
-		mgid = find_mgid_mode(q);
-
-		if (!mgid) {
-			fprintf(stderr, "MGID mode not found %s\n", p);
-			return NULL;
-		}
-		p = q;
-	} else
-		mgid = mgid_mode;
-
-	q = strchr(p, '#');
-	if (q) {
-		*q++ = 0;
-		tos = atoi(q);
-		if (!tos) {
-			fprintf(stderr, "TOS value invalid : %p\n", p);
-			return NULL;
-		}
-	} else
-		tos = tos_mode;
-
-	ret = getaddrinfo(a, service, &hints, &res);
-	if (ret) {
-		fprintf(stderr, "getaddrinfo() failed (%s) - invalid IP address.\n", gai_strerror(ret));
-		return NULL;
-	}
-
-	si = malloc(sizeof(struct sockaddr_in));
-	memcpy(si, res->ai_addr, sizeof(struct sockaddr_in));
-	freeaddrinfo(res);
-
-	addr = si->sin_addr;
-	if (mc_only && !IN_MULTICAST(ntohl(addr.s_addr))) {
-		fprintf(stderr, "Not a multicast address (%s)\n", arg);
-		return NULL;
-	}
-
-	*p_mgid_mode = mgid;
-	*p_tos_mode = tos;
-	return si;
-}
-
-/* Setup the addreses for ROCE and INFINIBAND based on a ipaddr:port spec */
-static void setup_mc_addrs(struct mc *m, struct sockaddr_in *si)
-{
-	m->interface[ROCE].sa = (struct sockaddr  *)si;
-	m->port = ntohs(si->sin_port);
-	m->interface[INFINIBAND].sa = m->interface[ROCE].sa;
-
-	if (m->mgid_mode->signature) {
-		/*
-		 * MGID is build according to according to RFC 4391 Section 4
-		 * by taking 28 bits and putting them into the mgid
-		 *
-		 * But then CLLM and others include the full 32 bit...
-		 * Deal with this crappy situation.
-		 */
-		struct sockaddr_ib *saib	= calloc(1, sizeof(struct sockaddr_ib));
-		unsigned short *mgid_header	= (unsigned short *)saib->sib_addr.sib_raw;
-		unsigned short *mgid_signature	= (unsigned short *)(saib->sib_addr.sib_raw + 2);
-		unsigned short *mgid_pkey	= (unsigned short *)(saib->sib_addr.sib_raw + 4);
-		unsigned short *mgid_port	= (unsigned short *)(saib->sib_addr.sib_raw + 10);
-		unsigned int *mgid_ipv4		= (unsigned int *)(saib->sib_addr.sib_raw + 12);
-		unsigned int multicast = ntohl(m->addr.s_addr);
-		struct mgid_signature *mg = m->mgid_mode;
-
-		saib->sib_family = AF_IB,
-		saib->sib_sid = si->sin_port;
-
-		*mgid_header = htons(0xff15);
-		*mgid_signature = htons(mg->signature);
-
-		if (mg->pkey)
-			/* WTF? Where do we get the pkey from ? */
-			*mgid_pkey = 0xFFFF;
-
-		if (mg->port)
-			*mgid_port = si->sin_port;
-
-		if (!mg->full_ipv4)
-			/* Strip to 28 bits according to RFC */
-			multicast &= 0x0fffffff;
-
-		*mgid_ipv4 = htonl(multicast);
-
-		m->interface[INFINIBAND].sa = (struct sockaddr *)saib;
-	}
-}
-
-/* Multicast group specifications on the command line */
-static int new_mc_addr(char *arg,
-	bool sendonly_infiniband,
-	bool sendonly_roce)
-{
-	struct sockaddr_in *si;
-	struct mc *m = mcs + nr_mc;
-	int ret;
-
-	if (nr_mc == MAX_MC) {
-		fprintf(stderr, "Too many multicast groups\n");
-		return 1;
-	}
-
-	m->interface[INFINIBAND].sendonly = sendonly_infiniband;
-	m->interface[ROCE].sendonly = sendonly_roce;
-	m->text = strdup(arg);
-
-	si = parse_addr(arg, default_mc_port, &m->mgid_mode, &m->tos_mode, true);
-	if (!si)
-		return 1;
-
-	m->addr = si->sin_addr;
-	ret = hash_add_mc(m);
-	if (ret) {
-		fprintf(stderr, "Duplicate multicast address (%s)\n", arg);
-		goto out;
-	}
-
-	setup_mc_addrs(m, si);
-	nr_mc++;
-	ret = 0;
-
-out:
-	return ret;
-}
-
-static int _join_mc(struct in_addr addr, struct sockaddr *sa,
-	unsigned port, uint8_t tos, enum interfaces i, bool sendonly, void *private)
-{
-	struct rdma_cm_join_mc_attr_ex mc_attr = {
-		.comp_mask = RDMA_CM_JOIN_MC_ATTR_ADDRESS | RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS,
-		.join_flags = sendonly ? RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER
-                                       : RDMA_MC_JOIN_FLAG_FULLMEMBER,
-		.addr = sa
-	};
-	int ret;
-	
-	ret = rdma_join_multicast_ex(id(i), &mc_attr, private);
-
-	if (ret) {
-		logg(LOG_CRIT, "Failed to create join request %s:%d on %s. Error %s\n",
-			inet_ntoa(addr), port,
-			interfaces_text[i],
-			errname());
-		return 1;
-	}
-	logg(LOG_NOTICE, "Join Request %sMC group %s:%d on %s.\n",
-		sendonly ? "Sendonly " : "",
-		inet_ntoa(addr), port,
-		interfaces_text[i]);
-	st(i2r[i].multicast, join_requests);
-	return 0;
-}
-
-static int _leave_mc(struct in_addr addr,struct sockaddr *si, enum interfaces i)
-{
-	int ret;
-
-	ret = rdma_leave_multicast(id(i), si);
-	if (ret) {
-		logg(LOG_ERR, "Failure on rdma_leave_multicast on %s:%s\n", interfaces_text[i], inet_ntoa(addr));
-		return 1;
-	}
-	logg(LOG_NOTICE, "Leaving MC group %s on %s .\n",
-		inet_ntoa(addr),
-		interfaces_text[i]);
-	st(i2r[i].multicast, leave_requests);
-	return 0;
-}
-
-static int leave_mc(enum interfaces i)
-{
-	int j;
-	int ret;
-
-	for (j = 0; j < nr_mc; j++) {
-		struct mc *m = mcs + j;
-
-		ret = _leave_mc(m->addr, m->interface[i].sa, i);
-		if (ret)
-			return 1;
-	}
-	return 0;
-}
-
 static void beacon_received(struct mc *, enum interfaces, struct buf *buf);
 
 #ifdef UNICAST
@@ -959,7 +391,6 @@ err:
 	return NULL;
 }
 
-static void process_cqes(struct rdma_channel *c, struct ibv_wc *w, unsigned cqs);
 static void arm_channels(struct core_info *core);
 
 /*
@@ -1863,62 +1294,6 @@ static void shutdown_roce(void)
 	qp_destroy(i2r + ROCE);
 }
 
-/*
- * Join MC groups. This is called from the event loop every second
- * as long as there are unjoined groups
- */
-static void join_processing(void)
-{
-	int i;
-	enum interfaces in;
-	int mcs_per_call = 0;
-
-	for (i = 0; i < nr_mc; i++) {
-		struct mc *m = mcs + i;
-		unsigned port = m->port;
-
-		if (m->interface[ROCE].status == MC_JOINED && m->interface[INFINIBAND].status == MC_JOINED)
-			continue;
-
-		for(in = 0; in < 2; in++) {
-			struct mc_interface *mi = m->interface + in;
-			uint8_t tos = i == ROCE ? m->tos_mode : 0;
-
-			if (i2r[in].context) {
-				switch(mi->status) {
-
-				case MC_OFF:
-					if (_join_mc(m->addr, mi->sa, port, tos, in, mi->sendonly, m) == 0)
-						m->interface[in].status = MC_JOINING;
-					break;
-
-				case MC_ERROR:
-
-					_leave_mc(m->addr, mi->sa, in);
-					mi->status = MC_OFF;
-					logg(LOG_WARNING, "Left Multicast group %s on %s due to MC_ERROR\n",
-						m->text, interfaces_text[in]);
-					break;
-
-				case MC_JOINED:
-					break;
-
-				default:
-					logg(LOG_ERR, "Bad MC status %d MC %s on %s\n",
-					       mi->status, m->text, interfaces_text[in]);
-					break;
-				}
-			}
-		}
-
-		mcs_per_call++;
-
-		if (mcs_per_call > 10)
-			break;
-
-	}
-}
-
 #ifdef UNICAST
 static void resolve_start(struct rdma_unicast *);
 
@@ -1996,254 +1371,6 @@ static void resolve(struct rdma_unicast
 }
 #endif
 
-static void set_rate(struct mc *m)
-{
-	if (irate) {
-			m->interface[INFINIBAND].packet_time = ONE_SECOND / irate;
-			m->interface[INFINIBAND].max_burst = max_iburst;
-	}
-
-	if (rrate) {
-			m->interface[ROCE].packet_time = ONE_SECOND / rrate;
-			m->interface[ROCE].max_burst = max_rburst;
-	}
-
-}
-
-static void set_rates(void)
-{
-	int j;
-
-	for (j = 0; j < nr_mc; j++) {
-		struct mc *m = mcs + j;
-
-		set_rate(m);
-		set_rate(m);
-	}
-}
-
-static void handle_rdma_event(void *private)
-{
-	struct i2r_interface *i = private;
-	struct rdma_cm_event *event;
-	int ret;
-	enum interfaces in = i - i2r;
-#ifdef UNICAST
-	struct rdma_unicast *ru = fifo_first(&i->resolve_queue);
-#endif
-
-	ret = rdma_get_cm_event(i->rdma_events, &event);
-	if (ret) {
-		logg(LOG_WARNING, "rdma_get_cm_event()_ failed. Error = %s\n", errname());
-		return;
-	}
-
-	switch(event->event) {
-		/* Connection events */
-		case RDMA_CM_EVENT_MULTICAST_JOIN:
-			{
-				struct rdma_ud_param *param = &event->param.ud;
-				struct mc *m = (struct mc *)param->private_data;
-				struct ah_info *a = &m->interface[in].ai;
-
-				a->remote_qpn = param->qp_num;
-				a->remote_qkey = param->qkey;
-
-				if (rate)
-					param->ah_attr.static_rate = rate;
-
-				if (m->tos_mode)
-					param->ah_attr.grh.traffic_class = m->tos_mode;
-
-				a->ah = ibv_create_ah(i->multicast->pd, &param->ah_attr);
-				if (!a->ah) {
-					logg(LOG_ERR, "Failed to create AH for Multicast group %s on %s \n",
-						m->text, i->text);
-					m->interface[in].status = MC_ERROR;
-					break;
-				}
-				m->interface[in].status = MC_JOINED;
-
-				/* Things actually work if both multicast groups are joined */
-				if (!bridging || m->interface[in^1].status == MC_JOINED)
-					active_mc++;
-
-				logg(LOG_NOTICE, "Joined %s MLID 0x%x tos %u sl %u on %s\n",
-					inet6_ntoa(param->ah_attr.grh.dgid.raw),
-					param->ah_attr.dlid,
-					m->tos_mode,
-					param->ah_attr.sl,
-					i->text);
-				st(i->multicast, join_success);
-
-				set_rate(m);
-			}
-			break;
-
-		case RDMA_CM_EVENT_MULTICAST_ERROR:
-			{
-				struct rdma_ud_param *param = &event->param.ud;
-				struct mc *m = (struct mc *)param->private_data;
-
-				logg(LOG_ERR, "Multicast Error. Group %s on %s\n",
-					m->text, i->text);
-
-				/* If already joined then the bridging may no longer work */
-				if (!bridging || (m->interface[in].status == MC_JOINED && m->interface[in^1].status == MC_JOINED))
-				       active_mc--;
-
-				m->interface[in].status = MC_ERROR;
-				st(i->multicast, join_failure);
-			}
-			break;
-
-#ifdef UNICAST
-		case RDMA_CM_EVENT_ADDR_RESOLVED:
-			logg(LOG_NOTICE, "RDMA_CM_EVENT_ADDR_RESOLVED for %s:%d\n",
-				inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
-
-			if (rdma_resolve_route(ru->c->id, 2000) < 0) {
-
-				logg(LOG_ERR, "rdma_resolve_route error %s on %s  %s:%d. Packet dropped.\n",
-					errname(), ru->c->text,
-					inet_ntoa(ru->sin.sin_addr),
-					ntohs(ru->sin.sin_port));
-					goto err;
-			}
-			ru->state = UC_ROUTE_REQ;
-			break;
-
-		case RDMA_CM_EVENT_ADDR_ERROR:
-			logg(LOG_ERR, "Address resolution error %d on %s  %s:%d. Packet dropped.\n",
-				event->status, ru->c->text,
-				inet_ntoa(ru->sin.sin_addr),
-				ntohs(ru->sin.sin_port));
-
-			goto err;
-			break;
-
-		case RDMA_CM_EVENT_ROUTE_RESOLVED:
-			{
-				struct rdma_conn_param rcp = { };
-
-				logg(LOG_NOTICE, "RDMA_CM_EVENT_ROUTE_RESOLVED for %s:%d\n",
-					inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
-
-				allocate_rdmacm_qp(ru->c, false);
-
-				post_receive(ru->c);
-				ibv_req_notify_cq(ru->c->cq, 0);
-
-				if (rdma_connect(ru->c->id, &rcp) < 0) {
-					logg(LOG_ERR, "rdma_connecte error %s on %s  %s:%d. Packet dropped.\n",
-						errname(), ru->c->text,
-						inet_ntoa(ru->sin.sin_addr),
-						ntohs(ru->sin.sin_port));
-
-					goto err;
-				}
-				ru->state = UC_CONN_REQ;
-			}
-			break;
-
-		case RDMA_CM_EVENT_ROUTE_ERROR:
-			logg(LOG_ERR, "Route resolution error %d on %s  %s:%d. Packet dropped.\n",
-				event->status, ru->c->text,
-				inet_ntoa(ru->sin.sin_addr),
-				ntohs(ru->sin.sin_port));
-
-			goto err;
-			break;
-
-		case RDMA_CM_EVENT_CONNECT_REQUEST:
-			{
-				struct rdma_conn_param rcp = { };
-				struct rdma_channel *c = new_rdma_channel(i, channel_rdmacm);
-
-				logg(LOG_NOTICE, "RDMA_CM_CONNECT_REQUEST id=%p listen_id=%p\n",
-					event->id, event->listen_id);
-
-				c->id->context = c;
-
-				if (!allocate_rdmacm_qp(c, false))
-					goto err;
-
-				post_receive(c);
-
-				ibv_req_notify_cq(c->cq, 0);
-
-				rcp.qp_num = c->id->qp->qp_num;
-				if (rdma_accept(c->id, &rcp)) {
-					logg(LOG_ERR, " rdma_accept error %s\n", errname());
-					channel_destroy(c);
-				}
-				/* Create a structure just for tracking buffers */
-				c->ru = new_rdma_unicast(i, NULL);
-				c->ru->c = c;
-				c->ru->state = UC_CONNECTED;
-
-			}
-			break;
-
-		case RDMA_CM_EVENT_DISCONNECTED:
-			{
-				struct rdma_channel *c = event->id->context;
-
-				logg(LOG_NOTICE, "RDMA_CM_EVENT_DISCONNECTED id=%p %s\n",
-					event->id, c->text);
-
-				if (c->ru)
-					zap_channel(c->ru);
-				else
-					channel_destroy(c);
-			}
-			break;
-
-		case RDMA_CM_EVENT_ESTABLISHED:
-			{
-				struct ah_info *ai = &ru->ai;
-
-				logg(LOG_NOTICE, "RDMA_CM_EVENT_ESTABLISHED for %s:%d\n",
-					inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
-
-				ai->ah = ibv_create_ah(ru->c->pd, &event->param.ud.ah_attr);
-				ai->remote_qpn = event->param.ud.qp_num;
-				ai->remote_qkey = event->param.ud.qkey;
-
-				rdma_ack_cm_event(event);
-				ru->state = UC_CONNECTED;
-				resolve_end(ru);
-				return;
-			}
-			break;
-
-		case RDMA_CM_EVENT_UNREACHABLE:
-			logg(LOG_ERR, "Unreachable Port error %d on %s  %s:%d. Packet dropped.\n",
-				event->status, ru->c->text,
-				inet_ntoa(ru->sin.sin_addr),
-				ntohs(ru->sin.sin_port));
-
-			goto err;
-			break;
-#endif
-
-		default:
-			logg(LOG_NOTICE, "RDMA Event handler:%s status: %d\n",
-				rdma_event_str(event->event), event->status);
-			break;
-	}
-
-	rdma_ack_cm_event(event);
-	return;
-
-#ifdef UNICAST
-err:
-	rdma_ack_cm_event(event);
-	ru->state = UC_ERROR;
-	resolve_end(ru);
-#endif
-}
-
 #ifdef UNICAST
 static struct rdma_unicast *new_rdma_unicast(struct i2r_interface *i, struct sockaddr_in *sin)
 {
@@ -3300,15 +2427,10 @@ static void receive_multicast(struct buf
 		unsigned char *mgid = buf->grh.dgid.raw;
 		unsigned short signature = ntohs(*(unsigned short*)(mgid + 2));
 
-		if (m->mgid_mode->signature) {
-			if (signature == m->mgid_mode->signature) {
-//				if (m->mgid_mode->port)
-//					port = ntohs(*((unsigned short *)(mgid + 10)));
-			} else {
-				logg(LOG_INFO, "Discard Packet: MGID multicast signature(%x)  mismatch. MGID=%s\n",
-						signature, inet6_ntoa(mgid));
-				goto invalid_packet;
-			}
+		if (!mgid_check(m, signature)) {
+			logg(LOG_INFO, "Discard Packet: MGID multicast signature(%x)  mismatch. MGID=%s\n",
+					signature, inet6_ntoa(mgid));
+			goto invalid_packet;
 		}
 
 	}
@@ -4192,117 +3314,6 @@ discard:
 }
 #endif
 
-static void reset_flags(struct buf *buf)
-{
-	memset(&buf->ip_valid, 0, (void *)&buf->ip_csum_ok - (void *)&buf->ip_valid);
-}
-
-static void process_cqes(struct rdma_channel *c, struct ibv_wc *wc, unsigned cqs)
-{
-	unsigned j;
-
-	if (cqs > c->cq_high)
-		c->cq_high = cqs;
-
-	for (j = 0; j < cqs; j++) {
-		struct ibv_wc *w = wc + j;
-		struct buf *buf = (struct buf *)w->wr_id;
-
-		if (w->status == IBV_WC_SUCCESS && w->opcode == IBV_WC_RECV) {
-
-			c->active_receive_buffers--;
-			st(c, packets_received);
-
-			if (c != buf->c) {
-				logg(LOG_CRIT, "%s: RDMA Channel mismatch CQE is from %s.\n", c->text, buf->c->text);
-				st(c, packets_invalid);
-				free(buf);
-				continue;
-			}
-
-			buf->cur = buf->raw;
-			buf->end = buf->raw + w->byte_len;
-			buf->w = w;
-			reset_flags(buf);
-			if (w->wc_flags & IBV_WC_WITH_IMM) {
-
-				buf->imm = w->imm_data;
-				buf->imm_valid = true;
-
-			} else {
-				buf->imm = 0;
-				buf->imm_valid = false;
-			}
-
-			if (w->wc_flags & IBV_WC_GRH) {
-				PULL(buf, buf->grh);
-				buf->grh_valid = true;
-				if (c->i == i2r + ROCE) {
-					/*
-					 * In the ROCE ipv4 case the IP header is
-					 * at the end of the GRH instead of a
-					 * SGID and DGID
-					 */
-					memcpy(&buf->ip, (void *)buf->cur - 20, 20);
-					buf->ip_valid = true;
-				}
-			} else
-				buf->grh_valid = false;
-
-			buf->ip_csum_ok = (w->wc_flags & IBV_WC_IP_CSUM_OK) != 0;
-
-			c->receive(buf);
-			put_buf(buf);
-
-		} else {
-			if (w->status == IBV_WC_SUCCESS && w->opcode == IBV_WC_SEND) {
-				c->active_send_buffers--;
-				/* Completion entry */
-				st(c, packets_sent);
-				put_buf(buf);
-			} else
-				logg(LOG_NOTICE, "Strange CQ Entry %d/%d: Status:%x Opcode:%x Len:%u QP=%x SRC_QP=%x Flags=%x\n",
-					j, cqs, w->status, w->opcode, w->byte_len, w->qp_num, w->src_qp, w->wc_flags);
-
-		}
-	}
-
-	/* Since we freed some buffers up we may be able to post more of them */
-	post_receive(c);
-}
-
-static void handle_comp_event(void *private)
-{
-	struct ibv_comp_channel *events = private;
-	struct rdma_channel *c;
-	struct ibv_cq *cq;
-	int cqs;
-	struct ibv_wc wc[10];
-
-	if (ibv_get_cq_event(events, &cq, (void **)&c)) {
-		logg(LOG_ERR, "ibv_get_cq_event failed with %s\n", errname());
-		return;
-	}
-
-	ibv_ack_cq_events(cq, 1);
-	if (ibv_req_notify_cq(cq, 0))
-		panic("ibv_req_notify_cq: Failed\n");
-
-	if (!c || c->cq != cq)
-       		panic("Invalid channel in handle_comp_event() %p\n", c);
-
-	/* Retrieve completion events and process incoming data */
-	cqs = ibv_poll_cq(cq, 10, wc);
-	if (cqs < 0) {
-		logg(LOG_WARNING, "CQ polling failed with: %s on %s\n",
-			errname(), c->text);
-		return;
-	}
-
-	if (cqs)
-		process_cqes(c, wc, cqs);
-}
-
 #ifdef UNICAST
 /* Special handling using raw socket */
 static void handle_receive_packet(void *private)
@@ -4354,27 +3365,6 @@ static void handle_receive_packet(void *
 }
 #endif
 
-static void handle_async_event(void *private)
-{
-	struct i2r_interface *i = private;
-	struct ibv_async_event event;
-
-	if (!ibv_get_async_event(i->context, &event))
-		logg(LOG_ALERT, "Async event retrieval failed on %s.\n", i->text);
-	else
-		logg(LOG_ALERT, "Async RDMA EVENT %d on %s\n", event.event_type, i->text);
-
-	/*
-	 * Regardless of what the cause is the first approach here
-	 * is to simply terminate the program.
-	 * We can make exceptions later.
-	 */
-
-	terminate(0);
-
-        ibv_ack_async_event(&event);
-}
-
 static int status_fd;
 
 static int channel_stats(char *b, struct rdma_channel *c, const char *interface, const char *type)
@@ -4432,7 +3422,7 @@ static unsigned show_multicast(char *b)
 			inet_ntoa(m->addr),
 			mc_text[m->interface[INFINIBAND].status],
 			m->interface[INFINIBAND].sendonly ? "Sendonly " : "",
-			m->mgid_mode->id,
+			mgid_text(m),
 			m->interface[INFINIBAND].pending,
 			mc_text[m->interface[ROCE].status],
 			m->interface[ROCE].sendonly ? "Sendonly" : "",
@@ -5188,7 +4178,6 @@ skip:
 static void exec_opt(int op, char *optarg)
 {
 	int ret = 0;
-	int n;
 
 	switch (op) {
 		case 'b':
@@ -5221,20 +4210,11 @@ static void exec_opt(int op, char *optar
 
 		case 'l':
 			if (optarg) {
-				mgid_mode = find_mgid_mode(optarg);
-				if (mgid_mode)
+				if (find_mgid_mode(optarg))
 					break;
-			}
-			printf("List of supported MGID formats via -l<id>\n");
-			printf("=================================\n");
-			printf(" ID    | Signature | Port in MGID\n");
-			printf("-------+-----------+-------------\n");
-			for (n = 0; n < nr_mgid_signatures; n++) {
-				struct mgid_signature *m = mgid_signatures + n;
+			} else
+				mgids_out();
 
-				printf("%7s|    0x%04x | %s\n",
-					m->id, m->signature, m->port ? "true" : "false");
-			}
 			exit(1);
 			break;
 
@@ -5465,7 +4445,7 @@ static void multicast_cmd(char *paramete
 				interfaces_text[in], m->text,
 			mc_text[m->interface[in].status],
 			m->interface[in].sendonly ? "Sendonly " : "",
-			in == INFINIBAND ? m->mgid_mode->id : "",
+			in == INFINIBAND ? mgid_text(m) : "",
 			m->interface[in].packet_time,
 			m->interface[in].max_burst,
 			m->interface[in].delayed,
@@ -5768,7 +4748,7 @@ int main(int argc, char **argv)
 {
 	int op, ret = 0;
 
-	mc_hash = hash_create(offsetof(struct mc, addr), sizeof(struct in_addr));
+	multicast_init();
 
 #ifdef UNICAST
 	sidr_state_init();
@@ -5801,7 +4781,7 @@ int main(int argc, char **argv)
 	logg (LOG_NOTICE, "%s device = %s:%d, %s device = %s:%d. Multicast Groups=%d MGIDs=%s Buffers=%u\n",
 			interfaces_text[INFINIBAND], i2r[INFINIBAND].rdma_name, i2r[INFINIBAND].port,
 			interfaces_text[ROCE], i2r[ROCE].rdma_name, i2r[ROCE].port,
-			nr_mc, mgid_mode->id, nr_buffers);
+			nr_mc, mgid_text(NULL), nr_buffers);
 
 	numa_run_on_node(i2r[INFINIBAND].context ? i2r[INFINIBAND].numa_node : i2r[ROCE].numa_node);
 	init_buf();	/* Setup interface registers memmory */
Index: rdma-core/ib2roce/CMakeLists.txt-NO_MSTFLINT
===================================================================
--- rdma-core.orig/ib2roce/CMakeLists.txt-NO_MSTFLINT
+++ rdma-core/ib2roce/CMakeLists.txt-NO_MSTFLINT
@@ -12,6 +12,8 @@ rdma_executable(ib2roce
   logging.c
   locking.c
   buffers.c
+  multicast.c
+  interfaces.c
 )
 target_link_libraries(ib2roce LINK_PRIVATE
   ibverbs
Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/interfaces.c
@@ -0,0 +1,696 @@
+/*
+ * RDMA Interfaces
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <numa.h>
+#include <stdatomic.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <rdma/rdma_cma.h>
+#include <infiniband/ib.h>
+#include <infiniband/verbs.h>
+#include <poll.h>
+#include <sys/mman.h>
+
+#include <linux/rtnetlink.h>
+#include <net/ethernet.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/if_arp.h>
+#include <linux/if_packet.h>
+#include <infiniband/mad.h>
+#include <infiniband/umad_cm.h>
+#include <infiniband/umad_str.h>
+#include <execinfo.h>
+#include "packet.h"
+#include "errno.h"
+#include "bth_hdr.h"
+#include "ib_hdrs.h"
+#include "fifo.h"
+#include "ring.h"
+#include "hash.h"
+#include "sched.h"
+#include "logging.h"
+#include "locking.h"
+#include "buffers.h"
+#include "multicast.h"
+#include "interfaces.h"
+
+char *ib_name, *roce_name;
+
+int rate = IBV_RATE_10_GBPS;	/* Limit sending rate */
+int rrate = 0;			/* Software delay per message for ROCE */
+int irate = 0;			/* Software delay per message for Infiniband */
+int max_rburst = 10;		/* Dont delay until # of packets for ROCE */
+int max_iburst = 10;		/* Dont delay until # of packets for Infiniband */
+
+bool bridging = true;		/* Allow briding */
+
+struct i2r_interface i2r[NR_INTERFACES];
+
+const char *inet6_ntoa(void *x)
+{
+	char buf[INET6_ADDRSTRLEN];
+
+	return inet_ntop(AF_INET6, x, buf, INET6_ADDRSTRLEN);
+}
+
+void set_rate(struct mc *m)
+{
+	if (irate) {
+			m->interface[INFINIBAND].packet_time = ONE_SECOND / irate;
+			m->interface[INFINIBAND].max_burst = max_iburst;
+	}
+
+	if (rrate) {
+			m->interface[ROCE].packet_time = ONE_SECOND / rrate;
+			m->interface[ROCE].max_burst = max_rburst;
+	}
+
+}
+
+void set_rates(void)
+{
+	int j;
+
+	for (j = 0; j < nr_mc; j++) {
+		struct mc *m = mcs + j;
+
+		set_rate(m);
+		set_rate(m);
+	}
+}
+
+/* Check the RDMA device if it fits what was specified on the command line and store it if it matches */
+int check_rdma_device(enum interfaces i, int port, char *name,
+	       struct ibv_context *c, struct ibv_port_attr *a, struct ibv_device_attr *d)
+{
+	char *s;
+	int p = 1;
+	const char *rdmadev = ibv_get_device_name(c->device);
+
+	if (i2r[i].context)
+		/* Already found a match */
+		return 0;
+
+	if (!name)
+		/* No command line option, take the first port/device */
+		goto success;
+
+	if (strncmp(name, rdmadev, strlen(rdmadev)))
+		return 0;
+
+	/* Port / device specified */
+	s = strchr(name, ':');
+	if (s) {
+		/* Portnumber follows device name */
+		p = atoi(s + 1);
+
+		if (port != p)
+			return 0;
+	}
+
+	s = strchr(name, '/');
+	if (s && i == INFINIBAND) {
+		/* IP device name follows */
+		char *q = s + 1;
+
+		while (isdigit(*q) || isalpha(*q))
+			 q++;
+
+		memcpy(i2r[INFINIBAND].if_name, s + 1, q - s - 1);
+	}
+
+success:
+	if (a->active_mtu == IBV_MTU_4096)
+		i2r[i].mtu = 4096;
+	else if (a->active_mtu == IBV_MTU_2048)
+		i2r[i].mtu = 2048;
+	else if (a->active_mtu == IBV_MTU_1024) 	/* Needed for rxe support */
+		i2r[i].mtu = 1024;
+	else
+		/* Other MTUs are not supported */
+		return 0;
+
+	i2r[i].context = c;
+	i2r[i].port = port;
+	i2r[i].port_attr = *a;
+	i2r[i].device_attr = *d;
+	i2r[i].rdma_name = rdmadev;
+	return 1;
+}
+
+/* Scan through available RDMA devices in order to locate the devices for bridging */
+int find_rdma_devices(void)
+{
+	int nr;
+	int i;
+	struct ibv_device **list;
+
+	i2r[ROCE].rdma_name = i2r[INFINIBAND].rdma_name = "<disabled>";
+	list = ibv_get_device_list(&nr);
+
+	if (nr <= 0) {
+		logg(LOG_EMERG, "No RDMA devices present.\n");
+		return 1;
+	}
+
+	for (i = 0; i < nr; i++) {
+		struct ibv_device *d = list[i];
+		const char *name = ibv_get_device_name(d);
+		struct ibv_context *c;
+		struct ibv_device_attr dattr;
+		int found = 0;
+		int port;
+
+		if (d->node_type != IBV_NODE_CA)
+			continue;
+
+		if (d->transport_type != IBV_TRANSPORT_IB)
+			continue;
+
+		c = ibv_open_device(d);
+		if (!c) {
+			logg(LOG_EMERG, "Cannot open device %s\n", name);
+			return 1;
+		}
+
+		if (ibv_query_device(c, &dattr)) {
+			logg(LOG_EMERG, "Cannot query device %s\n", name);
+			return 1;
+		}
+
+		for (port = 1; port <= dattr.phys_port_cnt; port++) {
+			struct ibv_port_attr attr;
+
+			if (ibv_query_port(c, port, &attr)) {
+				logg(LOG_CRIT, "Cannot query port %s:%d\n", name, port);
+				return 1;
+			}
+
+			if (attr.link_layer == IBV_LINK_LAYER_INFINIBAND) {
+				if (check_rdma_device(INFINIBAND, port, ib_name, c, &attr, &dattr) &&
+					(!i2r[ROCE].mtu || i2r[ROCE].mtu == i2r[INFINIBAND].mtu))
+					found = 1;
+
+			} else if (attr.link_layer == IBV_LINK_LAYER_ETHERNET) {
+				if (check_rdma_device(ROCE, port, roce_name, c, &attr, &dattr) &&
+					(!i2r[INFINIBAND].mtu || i2r[ROCE].mtu == i2r[INFINIBAND].mtu))
+					found = 1;
+			}
+		}
+
+		if (!found)
+			ibv_close_device(c);
+	}
+
+
+	ibv_free_device_list(list);
+
+
+	if (!i2r[ROCE].context) {
+
+		if (roce_name && roce_name[0] == '-')
+			/* Disabled on the command line */
+			bridging = false;
+		else {
+			if (roce_name) {
+				logg(LOG_EMERG, "ROCE device %s not found\n", roce_name);
+				return 1;
+			}
+			/* There is no ROCE device so we cannot bridge */
+			bridging = false;
+		}
+	}
+
+	if (!i2r[INFINIBAND].context) {
+
+		if ((ib_name && ib_name[0] == '-') && bridging)
+			/* Disabled on the command line */
+			bridging = false;
+		else {
+			if (ib_name)
+				/* User specd IB device */
+				logg(LOG_EMERG, "Infiniband device %s not found.\n", ib_name);
+			else {
+				if (!bridging) {
+					logg(LOG_EMERG, "No RDMA Devices available.\n");
+					return 1;
+				}
+				/* We only have a ROCE device but we cannot bridge */
+				bridging = false;
+			}
+		}
+	}
+	return 0;
+}
+
+void handle_rdma_event(void *private)
+{
+	struct i2r_interface *i = private;
+	struct rdma_cm_event *event;
+	int ret;
+	enum interfaces in = i - i2r;
+#ifdef UNICAST
+	struct rdma_unicast *ru = fifo_first(&i->resolve_queue);
+#endif
+
+	ret = rdma_get_cm_event(i->rdma_events, &event);
+	if (ret) {
+		logg(LOG_WARNING, "rdma_get_cm_event()_ failed. Error = %s\n", errname());
+		return;
+	}
+
+	switch(event->event) {
+		/* Connection events */
+		case RDMA_CM_EVENT_MULTICAST_JOIN:
+			{
+				struct rdma_ud_param *param = &event->param.ud;
+				struct mc *m = (struct mc *)param->private_data;
+				struct ah_info *a = &m->interface[in].ai;
+
+				a->remote_qpn = param->qp_num;
+				a->remote_qkey = param->qkey;
+
+				if (rate)
+					param->ah_attr.static_rate = rate;
+
+				if (m->tos_mode)
+					param->ah_attr.grh.traffic_class = m->tos_mode;
+
+				a->ah = ibv_create_ah(i->multicast->pd, &param->ah_attr);
+				if (!a->ah) {
+					logg(LOG_ERR, "Failed to create AH for Multicast group %s on %s \n",
+						m->text, i->text);
+					m->interface[in].status = MC_ERROR;
+					break;
+				}
+				m->interface[in].status = MC_JOINED;
+
+				/* Things actually work if both multicast groups are joined */
+				if (!bridging || m->interface[in^1].status == MC_JOINED)
+					active_mc++;
+
+				logg(LOG_NOTICE, "Joined %s MLID 0x%x tos %u sl %u on %s\n",
+					inet6_ntoa(param->ah_attr.grh.dgid.raw),
+					param->ah_attr.dlid,
+					m->tos_mode,
+					param->ah_attr.sl,
+					i->text);
+				st(i->multicast, join_success);
+
+				set_rate(m);
+			}
+			break;
+
+		case RDMA_CM_EVENT_MULTICAST_ERROR:
+			{
+				struct rdma_ud_param *param = &event->param.ud;
+				struct mc *m = (struct mc *)param->private_data;
+
+				logg(LOG_ERR, "Multicast Error. Group %s on %s\n",
+					m->text, i->text);
+
+				/* If already joined then the bridging may no longer work */
+				if (!bridging || (m->interface[in].status == MC_JOINED && m->interface[in^1].status == MC_JOINED))
+				       active_mc--;
+
+				m->interface[in].status = MC_ERROR;
+				st(i->multicast, join_failure);
+			}
+			break;
+
+#ifdef UNICAST
+		case RDMA_CM_EVENT_ADDR_RESOLVED:
+			logg(LOG_NOTICE, "RDMA_CM_EVENT_ADDR_RESOLVED for %s:%d\n",
+				inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
+
+			if (rdma_resolve_route(ru->c->id, 2000) < 0) {
+
+				logg(LOG_ERR, "rdma_resolve_route error %s on %s  %s:%d. Packet dropped.\n",
+					errname(), ru->c->text,
+					inet_ntoa(ru->sin.sin_addr),
+					ntohs(ru->sin.sin_port));
+					goto err;
+			}
+			ru->state = UC_ROUTE_REQ;
+			break;
+
+		case RDMA_CM_EVENT_ADDR_ERROR:
+			logg(LOG_ERR, "Address resolution error %d on %s  %s:%d. Packet dropped.\n",
+				event->status, ru->c->text,
+				inet_ntoa(ru->sin.sin_addr),
+				ntohs(ru->sin.sin_port));
+
+			goto err;
+			break;
+
+		case RDMA_CM_EVENT_ROUTE_RESOLVED:
+			{
+				struct rdma_conn_param rcp = { };
+
+				logg(LOG_NOTICE, "RDMA_CM_EVENT_ROUTE_RESOLVED for %s:%d\n",
+					inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
+
+				allocate_rdmacm_qp(ru->c, false);
+
+				post_receive(ru->c);
+				ibv_req_notify_cq(ru->c->cq, 0);
+
+				if (rdma_connect(ru->c->id, &rcp) < 0) {
+					logg(LOG_ERR, "rdma_connecte error %s on %s  %s:%d. Packet dropped.\n",
+						errname(), ru->c->text,
+						inet_ntoa(ru->sin.sin_addr),
+						ntohs(ru->sin.sin_port));
+
+					goto err;
+				}
+				ru->state = UC_CONN_REQ;
+			}
+			break;
+
+		case RDMA_CM_EVENT_ROUTE_ERROR:
+			logg(LOG_ERR, "Route resolution error %d on %s  %s:%d. Packet dropped.\n",
+				event->status, ru->c->text,
+				inet_ntoa(ru->sin.sin_addr),
+				ntohs(ru->sin.sin_port));
+
+			goto err;
+			break;
+
+		case RDMA_CM_EVENT_CONNECT_REQUEST:
+			{
+				struct rdma_conn_param rcp = { };
+				struct rdma_channel *c = new_rdma_channel(i, channel_rdmacm);
+
+				logg(LOG_NOTICE, "RDMA_CM_CONNECT_REQUEST id=%p listen_id=%p\n",
+					event->id, event->listen_id);
+
+				c->id->context = c;
+
+				if (!allocate_rdmacm_qp(c, false))
+					goto err;
+
+				post_receive(c);
+
+				ibv_req_notify_cq(c->cq, 0);
+
+				rcp.qp_num = c->id->qp->qp_num;
+				if (rdma_accept(c->id, &rcp)) {
+					logg(LOG_ERR, " rdma_accept error %s\n", errname());
+					channel_destroy(c);
+				}
+				/* Create a structure just for tracking buffers */
+				c->ru = new_rdma_unicast(i, NULL);
+				c->ru->c = c;
+				c->ru->state = UC_CONNECTED;
+
+			}
+			break;
+
+		case RDMA_CM_EVENT_DISCONNECTED:
+			{
+				struct rdma_channel *c = event->id->context;
+
+				logg(LOG_NOTICE, "RDMA_CM_EVENT_DISCONNECTED id=%p %s\n",
+					event->id, c->text);
+
+				if (c->ru)
+					zap_channel(c->ru);
+				else
+					channel_destroy(c);
+			}
+			break;
+
+		case RDMA_CM_EVENT_ESTABLISHED:
+			{
+				struct ah_info *ai = &ru->ai;
+
+				logg(LOG_NOTICE, "RDMA_CM_EVENT_ESTABLISHED for %s:%d\n",
+					inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
+
+				ai->ah = ibv_create_ah(ru->c->pd, &event->param.ud.ah_attr);
+				ai->remote_qpn = event->param.ud.qp_num;
+				ai->remote_qkey = event->param.ud.qkey;
+
+				rdma_ack_cm_event(event);
+				ru->state = UC_CONNECTED;
+				resolve_end(ru);
+				return;
+			}
+			break;
+
+		case RDMA_CM_EVENT_UNREACHABLE:
+			logg(LOG_ERR, "Unreachable Port error %d on %s  %s:%d. Packet dropped.\n",
+				event->status, ru->c->text,
+				inet_ntoa(ru->sin.sin_addr),
+				ntohs(ru->sin.sin_port));
+
+			goto err;
+			break;
+#endif
+
+		default:
+			logg(LOG_NOTICE, "RDMA Event handler:%s status: %d\n",
+				rdma_event_str(event->event), event->status);
+			break;
+	}
+
+	rdma_ack_cm_event(event);
+	return;
+
+#ifdef UNICAST
+err:
+	rdma_ack_cm_event(event);
+	ru->state = UC_ERROR;
+	resolve_end(ru);
+#endif
+}
+
+void handle_async_event(void *private)
+{
+	struct i2r_interface *i = private;
+	struct ibv_async_event event;
+
+	if (!ibv_get_async_event(i->context, &event))
+		logg(LOG_ALERT, "Async event retrieval failed on %s.\n", i->text);
+	else
+		logg(LOG_ALERT, "Async RDMA EVENT %d on %s\n", event.event_type, i->text);
+
+	/*
+	 * Regardless of what the cause is the first approach here
+	 * is to simply terminate the program.
+	 * We can make exceptions later.
+	 */
+
+	terminate(0);
+
+        ibv_ack_async_event(&event);
+}
+
+/*
+ * Handling of RDMA work requests
+ */
+static void post_receive(struct rdma_channel *c)
+{
+	struct ibv_recv_wr recv_wr, *recv_failure;
+	struct ibv_sge sge;
+	int ret = 0;
+
+	if (!c || !nextbuffer)
+		return;
+
+	if (c->active_receive_buffers >= c->nr_receive)
+		return;
+
+	recv_wr.next = NULL;
+	recv_wr.sg_list = &sge;
+	recv_wr.num_sge = 1;
+
+	sge.length = DATA_SIZE;
+	sge.lkey = c->mr->lkey;
+
+	while (c->active_receive_buffers < c->nr_receive) {
+
+		struct buf *buf = alloc_buffer(c);
+
+		if (!buf) {
+			logg(LOG_WARNING, "%s: No free buffers left\n", c->text);
+			return;
+		}
+
+		/* Use the buffer address for the completion handler */
+		recv_wr.wr_id = (uint64_t)buf;
+		sge.addr = (uint64_t)buf->raw;
+		ret = ibv_post_recv(c->qp, &recv_wr, &recv_failure);
+		if (ret) {
+			free_buffer(buf);
+			errno = ret;
+			logg(LOG_ERR, "ibv_post_recv failed: %s:%s\n", c->text, errname());
+			return;
+                }
+		c->active_receive_buffers++;
+	}
+}
+
+static void reset_flags(struct buf *buf)
+{
+	memset(&buf->ip_valid, 0, (void *)&buf->ip_csum_ok - (void *)&buf->ip_valid);
+}
+
+void process_cqes(struct rdma_channel *c, struct ibv_wc *wc, unsigned cqs)
+{
+	unsigned j;
+
+	if (cqs > c->cq_high)
+		c->cq_high = cqs;
+
+	for (j = 0; j < cqs; j++) {
+		struct ibv_wc *w = wc + j;
+		struct buf *buf = (struct buf *)w->wr_id;
+
+		if (w->status == IBV_WC_SUCCESS && w->opcode == IBV_WC_RECV) {
+
+			c->active_receive_buffers--;
+			st(c, packets_received);
+
+			if (c != buf->c) {
+				logg(LOG_CRIT, "%s: RDMA Channel mismatch CQE is from %s.\n", c->text, buf->c->text);
+				st(c, packets_invalid);
+				free(buf);
+				continue;
+			}
+
+			buf->cur = buf->raw;
+			buf->end = buf->raw + w->byte_len;
+			buf->w = w;
+			reset_flags(buf);
+			if (w->wc_flags & IBV_WC_WITH_IMM) {
+
+				buf->imm = w->imm_data;
+				buf->imm_valid = true;
+
+			} else {
+				buf->imm = 0;
+				buf->imm_valid = false;
+			}
+
+			if (w->wc_flags & IBV_WC_GRH) {
+				PULL(buf, buf->grh);
+				buf->grh_valid = true;
+				if (c->i == i2r + ROCE) {
+					/*
+					 * In the ROCE ipv4 case the IP header is
+					 * at the end of the GRH instead of a
+					 * SGID and DGID
+					 */
+					memcpy(&buf->ip, (void *)buf->cur - 20, 20);
+					buf->ip_valid = true;
+				}
+			} else
+				buf->grh_valid = false;
+
+			buf->ip_csum_ok = (w->wc_flags & IBV_WC_IP_CSUM_OK) != 0;
+
+			c->receive(buf);
+			put_buf(buf);
+
+		} else {
+			if (w->status == IBV_WC_SUCCESS && w->opcode == IBV_WC_SEND) {
+				c->active_send_buffers--;
+				/* Completion entry */
+				st(c, packets_sent);
+				put_buf(buf);
+			} else
+				logg(LOG_NOTICE, "Strange CQ Entry %d/%d: Status:%x Opcode:%x Len:%u QP=%x SRC_QP=%x Flags=%x\n",
+					j, cqs, w->status, w->opcode, w->byte_len, w->qp_num, w->src_qp, w->wc_flags);
+
+		}
+	}
+
+	/* Since we freed some buffers up we may be able to post more of them */
+	post_receive(c);
+}
+
+void handle_comp_event(void *private)
+{
+	struct ibv_comp_channel *events = private;
+	struct rdma_channel *c;
+	struct ibv_cq *cq;
+	int cqs;
+	struct ibv_wc wc[10];
+
+	if (ibv_get_cq_event(events, &cq, (void **)&c)) {
+		logg(LOG_ERR, "ibv_get_cq_event failed with %s\n", errname());
+		return;
+	}
+
+	ibv_ack_cq_events(cq, 1);
+	if (ibv_req_notify_cq(cq, 0))
+		panic("ibv_req_notify_cq: Failed\n");
+
+	if (!c || c->cq != cq)
+       		panic("Invalid channel in handle_comp_event() %p\n", c);
+
+	/* Retrieve completion events and process incoming data */
+	cqs = ibv_poll_cq(cq, 10, wc);
+	if (cqs < 0) {
+		logg(LOG_WARNING, "CQ polling failed with: %s on %s\n",
+			errname(), c->text);
+		return;
+	}
+
+	if (cqs)
+		process_cqes(c, wc, cqs);
+}
+
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/interfaces.h
@@ -0,0 +1,175 @@
+#ifndef IB2ROCE_INTERFACES
+#define IB2ROCE_INTERFACES
+/*
+ * RDMA / Socket Interface
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <numa.h>
+#include <stdatomic.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <rdma/rdma_cma.h>
+#include <infiniband/ib.h>
+#include <infiniband/verbs.h>
+#include <poll.h>
+#include <sys/mman.h>
+
+#include <linux/rtnetlink.h>
+#include <net/ethernet.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/if_arp.h>
+#include <linux/if_packet.h>
+#include <infiniband/mad.h>
+#include <infiniband/umad_cm.h>
+#include <infiniband/umad_str.h>
+#include "errno.h"
+#include "fifo.h"
+#include "ring.h"
+#include "hash.h"
+#include "sched.h"
+#include "logging.h"
+#include "locking.h"
+#include "buffers.h"
+#include "multicast.h"
+
+#define MAX_GID 20
+
+extern char *ib_name, *roce_name;
+
+extern bool bridging;
+
+extern int rate;	/* Limit sending rate */
+extern int rrate;	/* Software delay per message for ROCE */
+extern int irate;	/* Software delay per message for Infiniband */
+extern int max_rburst;	/* Dont delay until # of packets for ROCE */
+extern int max_iburst;	/* Dont delay until # of packets for Infiniband */
+
+
+struct i2r_interface {
+	/* Not changed when multithreading */
+	struct ibv_context *context;		/* Not for RDMA CM use */
+	struct rdma_event_channel *rdma_events;
+	struct rdma_channel *multicast;
+#ifdef UNICAST
+	struct rdma_channel *qp1;		/* Channel for QP1 communications but not QP1 (userspace) */
+	struct rdma_channel *ud;		/* Regular data */
+	struct rdma_channel *raw;
+#endif
+	struct ibv_comp_channel *comp_events;
+	struct ibv_cq *cq;
+	struct ibv_pd *pd;
+	struct ibv_mr *mr;
+	unsigned port;
+	unsigned mtu;
+	unsigned maclen;
+	const char *text;
+	char if_name[IFNAMSIZ];
+	const char *rdma_name;
+	uint8_t if_mac[ETH_ALEN];
+	struct sockaddr_in if_addr;
+	struct sockaddr_in if_netmask;
+	unsigned ifindex;
+	unsigned numa_node;			/* NUMA Affinity of the interface */
+	unsigned gid_index;
+	union ibv_gid gid;
+	struct ibv_device_attr device_attr;
+	struct ibv_port_attr port_attr;
+	int iges;
+	struct ibv_gid_entry ige[MAX_GID];
+
+	/* The following may be updated in a multithreaded environment
+	 * from the multicast thread running for each interface.
+ 	 *
+         * Serialization is required but we generally are a bit loose
+	 * by allowing read access without locks.
+         */
+	struct hash *ru_hash;
+	struct fifo resolve_queue;		/* List of send buffers with unresolved addresses */
+	struct hash *ep;			/* Hash of all endpoints reachable here */
+	struct hash *ip_to_ep;			/* Hash based on IP address */
+	unsigned mc_rate_limited;		/* Number of MC groups where rate limiting is ongoing */
+	unsigned long out_of_buffer;		/* Last state of /sys/class/infiniband .../overrun */
+
+	/* PGM information:  Only updated from the multicast channel core */
+	unsigned nr_tsi;
+	struct hash *pgm_tsi_hash;
+	struct hash *pgm_record_hash;
+};
+
+extern struct i2r_interface i2r[];
+
+
+/* Forwards */
+void handle_comp_event(void *private);
+void handle_rdma_event(void *private);
+void handle_async_event(void *private);
+
+static inline struct rdma_cm_id *id(enum interfaces i)
+{
+	return i2r[i].multicast->id;
+}
+
+const char *inet6_ntoa(void *x);
+void set_rate(struct mc *m);
+void set_rates(void);
+
+void process_cqes(struct rdma_channel *c, struct ibv_wc *wc, unsigned cqs);
+
+int check_rdma_device(enum interfaces i, int port, char *name,
+	       struct ibv_context *c, struct ibv_port_attr *a, struct ibv_device_attr *d);
+
+/* Scan through available RDMA devices in order to locate the devices for bridging */
+int find_rdma_devices(void);
+
+#endif
