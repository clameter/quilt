Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- rdma-core.orig/ib2roce/interfaces.c
+++ rdma-core/ib2roce/interfaces.c
@@ -55,6 +55,7 @@
 #include <infiniband/verbs.h>
 #include <sys/ioctl.h>
 #include <numa.h>
+#include <ifaddrs.h>
 
 #include "packet.h"
 #include "errno.h"
@@ -122,6 +123,7 @@ void set_rates(void)
 	}
 }
 
+
 /* Check the RDMA device if it fits what was specified on the command line and store it if it matches */
 int check_rdma_device(enum interfaces i, int port, char *name,
 	       struct ibv_context *c, struct ibv_port_attr *a, struct ibv_device_attr *d)
@@ -386,6 +388,26 @@ static void get_if_info(struct i2r_inter
 	close(fh);
 
 	i->numa_node = atoi(buffer);
+
+	/* Dermine potential alternate interfaces for the IB interface) */
+	if (i - i2r  == INFINIBAND) {
+		struct ifaddrs *ifap;
+
+		getifaddrs(&ifap);
+
+		for (struct ifaddrs *ifa = ifap; ifa; ifa = ifa->ifa_next) {
+			if (ifa->ifa_addr && ifa->ifa_addr->sa_family==AF_INET) {
+
+				if (strcmp(ifa->ifa_name, i->if_name))
+					continue;
+
+				i->alt_addr = *((struct sockaddr_in *)(ifa->ifa_addr));
+				i->alt_netmask = *((struct sockaddr_in *)(ifa->ifa_netmask));
+			}
+        	}
+		free(ifap);
+    	}
+
 	return;
 
 err:
@@ -445,6 +467,7 @@ void setup_interface(enum interfaces in)
 	struct rdma_channel *ud = NULL;
 #endif
 	unsigned channels;
+	char buf[30];
 
 	if (in == INFINIBAND)
 		i->maclen = 20;
@@ -575,13 +598,16 @@ void setup_interface(enum interfaces in)
  	check_out_of_buffer(i);
  	numa_run_on_node(-1);
 
-	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d QPs=%u MTU=%u NUMA=%d.\n",
+	strcpy(buf, inet_ntoa(i->alt_addr.sin_addr));
+
+	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s %s:%d QPs=%u MTU=%u NUMA=%d.\n",
 		i->text,
 		i->rdma_name,
 		i->if_name, i->ifindex,
 		i->port,
 		inet6_ntoa(e->gid.raw), i->gid_index,
-		inet_ntoa(i->if_addr.sin_addr), default_port,
+		inet_ntoa(i->if_addr.sin_addr), buf,
+	       	default_port,
 		channels, i->mtu, i->numa_node
 	);
 }
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- rdma-core.orig/ib2roce/interfaces.h
+++ rdma-core/ib2roce/interfaces.h
@@ -101,6 +101,8 @@ struct i2r_interface {
 	uint8_t if_mac[ETH_ALEN];
 	struct sockaddr_in if_addr;
 	struct sockaddr_in if_netmask;
+	struct sockaddr_in alt_addr;
+	struct sockaddr_in alt_netmask;
 	unsigned ifindex;
 	unsigned mc_per_qp;			/* How many MCs per QP */
 	unsigned numa_node;			/* NUMA Affinity of the interface */
@@ -179,9 +181,22 @@ void shutdown_roce(void);
 
 static inline bool __valid_addr(struct i2r_interface *i, __be32 saddr)
 {
-	unsigned netmask = i->if_netmask.sin_addr.s_addr;
+	unsigned netmask;
 
-	return ((saddr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask));
+	netmask	= i->if_netmask.sin_addr.s_addr;
+
+	if  ((saddr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask))
+		return true;
+
+	netmask = i->alt_netmask.sin_addr.s_addr;
+
+	if (!netmask)
+		return false;
+
+	if  ((saddr & netmask) ==  (i->alt_addr.sin_addr.s_addr & netmask))
+		return true;
+
+	return false;
 }
 
 static inline bool valid_addr(struct i2r_interface *i, struct in_addr addr)
Index: rdma-core/ib2roce/pgm.c
===================================================================
--- rdma-core.orig/ib2roce/pgm.c
+++ rdma-core/ib2roce/pgm.c
@@ -46,7 +46,7 @@
  * PGM RFC3208 Support
  */
 
-enum pgm_mode pgm_mode = pgm_off;
+bool pgm_mode;
 
 struct nak {
 	struct pgm_nak *next;
@@ -67,7 +67,8 @@ enum stream_state {
 	stream_init,
 	stream_sync,
 	stream_repair,
-	stream_error
+	stream_error,
+	stream_drop
 };
 /* Stream information */
 struct pgm_stream {
@@ -282,17 +283,14 @@ bool pgm_process(struct rdma_channel *c,
 
 	header = (void *)pgm_start;
 
-	/* Verify if pgm message originated from our subnet */
+
+//	/* Verify if pgm message originated from our subnet */
 //	if (!valid_addr(c->i, header->addr)) {
 //		logg(LOG_INFO, "Discarded PGM packet originating from %s is from outside our subnet %s\n", inet_ntoa(header->addr), c->i->text);
 //		return false;
 //	}
 
-	if (pgm_mode < pgm_passthrough)
-		return true;
-
 	/* Process common values in PGM header and lookup the sender */
-
 	tsi.mcgroup = m->addr;
 	memcpy(&tsi.sender, header->pgm_gsi, sizeof(struct in_addr));
 	tsi.sport = ntohs(header->pgm_sport);
@@ -309,8 +307,11 @@ bool pgm_process(struct rdma_channel *c,
 			format_tsi(s->text, &tsi);
 			hash_add(i->pgm_tsi_hash, s);
 			i->nr_tsi++;
-
-			logg(LOG_NOTICE, "%s: New Stream TSI %s\n", i->text, s->text);
+			if (!valid_addr(c->i, tsi.sender)) {
+				s->enabled = false;
+				logg(LOG_NOTICE, "%s: New Stream TSI %s (Source addr not on valid add. Traffic will be dropped)\n", i->text, s->text);
+			} else
+				logg(LOG_NOTICE, "%s: New Stream TSI %s\n", i->text, s->text);
 		}
 		unlock();
 	}
@@ -448,8 +449,7 @@ __attribute__((constructor))
 static void pgm_init(void)
 {
 	register_concom("tsi", true, 0, "Show PGM info", tsi_cmd);
-	register_enable("pgm", true, NULL, (int *)&pgm_mode, "2", "off", NULL,
-		"PGM processing mode (0=None, 1= verify source address, 2=Passtrough, 3=DLR, 4=Resend with new TSI");
+	register_enable("pgm", true, &pgm_mode, NULL, "on", "off", NULL, "PGM processing mode");
 
 	init_pgm_streams();
 }
Index: rdma-core/ib2roce/pgm.h
===================================================================
--- rdma-core.orig/ib2roce/pgm.h
+++ rdma-core/ib2roce/pgm.h
@@ -42,9 +42,7 @@
 #include "buffers.h"
 #include "packet.h"
 
-enum pgm_mode { pgm_off, pgm_strict, pgm_llm, pgm_passthrough, pgm_dlr, pgm_resend };
-
-extern enum pgm_mode pgm_mode;
+extern bool pgm_mode;
 
 bool pgm_process(struct rdma_channel *c, struct mc *m, struct buf *buf);
 
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -140,7 +140,7 @@ static void delayed_send(void *private)
 	}
 
 	ret = send_to(c, buf->cur, buf->end - buf->cur, &mi->ai, buf->imm_valid, buf->imm, buf);
-	if (!ret)
+	if (ret <= 0)
 		st(c, packets_bridged);
 	buf->mi = NULL;
 }
@@ -249,7 +249,7 @@ void receive_multicast(struct buf *buf)
 	if (!m->enabled)
 		return;
 
-	if (pgm_mode != pgm_off) {
+	if (pgm_mode && m->mgid_mode == MGID_MODE_CLLM) {
 		uint8_t *saved = buf->cur;
 		if (!pgm_process(c, m, buf))
 			return;
@@ -314,7 +314,7 @@ delayed_packet:
 	get_buf(buf);	/* Packet will not be freed on return from this function */
  
 	ret = send_to(ch_out, buf->cur, buf->end - buf->cur, &mi->ai, buf->imm_valid, buf->imm, buf);
- 	if (ret)
+ 	if (ret > 0)
 		return;
 
 success:
