Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -308,7 +308,7 @@ static struct rdma_unicast *new_rdma_uni
 static void register_callback(void (*callback)(void *), int fd, void *private);
 static void handle_receive_packet(void *private);
 
-static receive_callback receive_main, receive_multicast, receive_raw, receive_ud;
+static receive_callback receive_main, receive_multicast, receive_raw, receive_ud, receive_qp1;
 
 static inline struct rdma_cm_id *id(enum interfaces i)
 {
@@ -1425,11 +1425,6 @@ static struct rdma_channel *create_chann
 	return c;
 }
 
-static struct rdma_channel *create_ud_channel(struct i2r_interface *i, int port, unsigned nr_cq, uint32_t qkey, const char *suffix)
-{
-	return create_channel(i, qkey, port, nr_cq, suffix, IBV_QPT_UD, channel_ud);
-}
-
 static struct rdma_channel *create_packet_socket(struct i2r_interface *i, int port)
 {
 	struct rdma_channel *c;
@@ -1605,9 +1600,12 @@ static void setup_interface(enum interfa
 
 	if (unicast) {
 
-		i->ud = create_ud_channel(i, i->port, nr_buffers / 100, RDMA_UDP_QKEY, "-ud");
-		i->qp1 = create_ud_channel(i, i->port, 10, IB_DEFAULT_QP1_QKEY, "-qp1");
+		i->ud = create_channel(i, RDMA_UDP_QKEY, i->port, nr_buffers / 100, "-ud", IBV_QPT_UD, channel_ud);
+
+		i->qp1 = create_channel(i, IB_DEFAULT_QP1_QKEY, i->port, 10,  "-qp1", IBV_QPT_UD, channel_ud);
 		i->qp1->max_receive_buffers = 9;
+		i->qp1->receive = receive_qp1;
+
 		i->raw = create_raw_channel(i, i->port, 100);
 		i->ip_to_ep = hash_create(offsetof(struct endpoint, addr), sizeof(struct in_addr));
 
@@ -2968,7 +2966,7 @@ static void send_mad(struct endpoint *e,
 	send_ud(e->i->qp1, buf, e->ah, 1, IB_DEFAULT_QP1_QKEY);
 }
 
-static const char *sidr_req(struct buf *buf, void *mad_pos, unsigned short dlid)
+static const char *sidr_req(struct buf *buf, void *mad_pos)
 {
 	struct sidr_state *ss = malloc(sizeof(struct sidr_state));
 	struct sidr_req *sr = (void *)buf->cur;
@@ -3370,7 +3368,7 @@ static void receive_raw(struct buf *buf)
 	}
 
 	if (ntohs(buf->umad.attr_id) == UMAD_CM_ATTR_SIDR_REQ) {
-		reason = sidr_req(buf, mad_pos, lids[1]);
+		reason = sidr_req(buf, mad_pos);
 		if (reason)
 			goto discard;
 		return;
@@ -3465,6 +3463,62 @@ discard:
 	free_buffer(buf);
 }
 
+/*
+ * Receive Channel mostly used to send QP1 traffic.
+ * But it can also be used to receive QP1 traffic when redirected to a gateway
+ */
+static void receive_qp1(struct buf *buf)
+{
+	const char *reason;
+	struct ibv_wc *w = buf->w;
+	void *mad_pos;
+
+	learn_source_address(buf);
+
+	if (!buf->grh_valid)
+		/* Even if there is no GRH there is space reserved at the beginning for UD packets */
+		buf->cur += 40;
+
+	mad_pos = buf->cur;
+
+	PULL(buf, buf->umad);
+
+	logg(LOG_NOTICE, "QP1 packet %s from %s LID %x WC_LEN=%u SQP=%x method=%s status=%s attr_id=%s\n", buf->c->text,
+		inet_ntoa(buf->source_ep->addr), buf->source_ep->lid, w->byte_len,
+		w->src_qp, umad_method_str(buf->umad.mgmt_class, buf->umad.method),
+		umad_common_mad_status_str(buf->umad.status),
+		umad_attribute_str(buf->umad.mgmt_class, buf->umad.attr_id));
+
+	if (buf->umad.mgmt_class != UMAD_CLASS_CM) {
+		reason = "-Only CM Class MADs are supported";
+		goto discard;
+	}
+
+	if (ntohs(buf->umad.attr_id) == UMAD_CM_ATTR_SIDR_REQ) {
+		reason = sidr_req(buf, mad_pos);
+		if (reason)
+			goto discard;
+		return;
+	}
+
+	if (ntohs(buf->umad.attr_id) == UMAD_CM_ATTR_SIDR_REP) {
+		reason = sidr_rep(buf, mad_pos);
+		if (reason)
+			goto discard;
+		return;
+	}
+
+	reason = "Only SIDR_REQ/REP supporte on QP1";
+
+discard:
+	if (reason[0] != '-' || log_packets > 1) 
+		logg(LOG_NOTICE, "QP1: Discard %s %s: Length=%u/pos=%lu\n",
+			buf->c->text, reason, w->byte_len, buf->cur - buf->raw);
+
+	st(buf->c, packets_invalid);
+	free_buffer(buf);
+}
+
 static void reset_flags(struct buf *buf)
 {
 	memset(&buf->ether_valid, 0, (void *)&buf->ip_csum_ok - (void *)&buf->ether_valid);
