Index: rdma-core/ib2roce/pgm.c
===================================================================
--- rdma-core.orig/ib2roce/pgm.c
+++ rdma-core/ib2roce/pgm.c
@@ -83,6 +83,60 @@ struct pgm_stream {
 	char text[60];
 };
 
+/* Generalized function to unpack options. Options are context dependent so these
+ * in general need to be there before the pgm header can be processed.
+ */
+#define MAX_PGM_OPT PGM_OPT_PGMCC_FEEDBACK
+
+#define MAX_PGM_TYPE PGM_ACK
+
+/* This table is only valid for ipv4. From RFC 3208 */
+uint16_t pgm_type_size[MAX_PGM_TYPE] = [
+       	sizeof(struct pgm_spm),		/* PGM_SPM */
+	sizeof(struct pgm_poll),	/* PGM_POLL */
+       	sizeof(struct pgm_polr),	/* PGM_POLR */
+        sizeof(struct pgm_data),	/* PGM_ODATA */
+        sizeof(struct pgm_data),	/* PGM_RDATA */
+	sizeof(struct pgm_nak),		/* PGM_NAK */
+	sizeof(struct pgm_nnak),	/* PGM_NNAK */
+	sizeof(struct pgm_ncf),		/* PGM_NCF */
+	sizeof(struct pgm_spmr),	/* PGM_SPMR */
+	sizeof(struct pgm_ack),		/* PGM_ACK */
+	];
+
+struct pgm_options {
+	void *opt[MAX_PGM_OPT];		/* Points to data for option. The option was not specified if NULL */
+	unsigned unknown_options;		/* Options outside of the range of options supported */
+	unsigned options;		/* Number of options set */
+};
+
+static void scan_pgm_options(struct pgm_options *po, uint8_t *a, struct pgm_header *pgm)
+{
+	unsigned n;
+	struct pgm_opt_header *poh;
+
+	memset(po, 0, sizeof(struct pgm_options));
+
+	if (!(pgm->pgm_options & PGM_OPT_PRESENT))
+		return;
+
+	do {
+		poh = (struct pgm_opt_header *)a;
+	
+		n = poh->opt_type & PGM_OPT_MASK;
+
+		if (n > MAX_PGM_OPT)
+			po->unknown_options++;
+		else {
+			po->opt[n] = a + sizeof(struct pgm_opt_header);
+			po->options++;
+		}
+
+		a +=  poh->opt_length;	
+
+	} while (!(poh->opt_type & PGM_OPT_END));
+}
+
 /* Records (ODATA/RDATA) in a stream */
 struct pgm_record {
 	struct pgm_tsi tsi;
@@ -158,6 +212,7 @@ bool pgm_process(struct rdma_channel *c,
 	struct i2r_interface *i = c->i;
 	struct pgm_tsi tsi;
 	struct pgm_stream *s;
+	struct pgm_options po;
 	uint32_t sqn;
 	uint32_t tdsu;
 	uint16_t total_opt_length = 0;
@@ -199,7 +254,6 @@ bool pgm_process(struct rdma_channel *c,
 	tsi.sport = ntohs(header.pgm.pgm_sport);
 	tsi.dport = ntohs(header.pgm.pgm_dport);
 	format_tsi(text, &tsi);
-
 	s = hash_find(i->pgm_tsi_hash, &tsi);
 
 	switch (header.pgm.pgm_type) {
