Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -156,6 +156,7 @@ struct mgid_signature *mgid_mode = mgid_
 
 #define MAX_GID 20
 #define MAX_INLINE_DATA 64
+#define MAX_UD_CHANNELS 100
 
 static char *ib_name, *roce_name;
 
@@ -179,6 +180,8 @@ static int cq_high = 0;	/* Largest batch
 
 enum channel_type { channel_rdmacm, channel_ud, channel_raw, channel_packet, nr_channel_types };
 
+enum channel_mode { channel_off, channel_init, channel_ready, channel_active };
+
 struct buf;
 
 typedef void receive_callback(struct buf *);
@@ -196,6 +199,7 @@ struct rdma_channel {
 	unsigned int nr_cq;
 	unsigned stats[nr_stats];
 	enum channel_type type;
+	enum channel_mode mode;
 	bool listening;		/* rdmacm Channel is listening for connections */
 	const char *text;
 	struct rdma_unicast *ru;	/* Onlu rdmacm */
@@ -212,6 +216,7 @@ struct rdma_channel {
  */
 struct forward {
 	struct endpoint *dest;
+	struct rdma_channel *c;
 	struct forward *next;
 	uint32_t source_qp, dest_qp;
 	uint32_t dest_qkey;
@@ -239,9 +244,10 @@ static struct i2r_interface {
 	struct ibv_context *context;		/* Not for RDMA CM use */
 	struct rdma_event_channel *rdma_events;
 	struct rdma_channel *multicast;
-	struct rdma_channel *qp1;		/* Channel for QP1 communications but not QP1 (userspace) */
-	struct rdma_channel *ud;		/* Regular data */
 	struct rdma_channel *raw;
+	struct rdma_channel *qp1;		/* Sending to QP1 */
+	struct rdma_channel *ud[MAX_UD_CHANNELS];
+	unsigned nr_ud;
 	struct ibv_comp_channel *comp_events;
 	struct ibv_cq *cq;
 	struct ibv_pd *pd;
@@ -1064,9 +1070,6 @@ static int post_receive_buffers(struct i
 	if (i->qp1)
 		ret = post_receive(i->qp1, 10);
 
-	if (i->ud)
-		ret = post_receive(i->ud, 100);
-
 out:
 	return ret;
 }
@@ -1115,6 +1118,8 @@ static void shutdown_sniffer(int arg) {
 
 static void qp_destroy(struct i2r_interface *i)
 {
+	unsigned j;
+
 #ifdef HAVE_MSTFLINT
 	if (i == i2r + INFINIBAND && i->raw && i->raw->type == channel_raw) {
 		if (clear_ib_sniffer(i->port, i->raw->qp))
@@ -1125,14 +1130,21 @@ static void qp_destroy(struct i2r_interf
 	channel_destroy(i->multicast);
 	i->multicast = NULL;
 
+	channel_destroy(i->qp1);
+	i->qp1 = NULL;
+
 	channel_destroy(i->raw);
 	i->raw = NULL;
 
-	channel_destroy(i->ud);
-	i->ud = NULL;
+	for (j = 0; j < MAX_UD_CHANNELS; j++) {
+
+		if (i->ud[j]->mode > channel_off) {
+			channel_destroy(i->ud[j]);
+			i->ud[j] = NULL;
+		}
+
+	}
 
-	channel_destroy(i->qp1);
-	i->qp1 = NULL;
 }
 
 /* Retrieve Kernel Stack info about the interface */
@@ -1211,19 +1223,25 @@ static void start_channel(struct rdma_ch
 		c->attr.qp_state = IBV_QPS_RTR;
 		/* Only Ethernet can send on a raw socket */
 		ret = ibv_modify_qp(c->qp, &c->attr, IBV_QP_STATE);
-		if (ret)
+
+		if (ret) {
 			logg(LOG_CRIT, "ibv_modify_qp: Error when moving %s to RTR state. %s\n", c->text, errname());
+			return;
+		}
 
 		if (send) {
 			c->attr.qp_state = IBV_QPS_RTS;
 			ret = ibv_modify_qp(c->qp, &c->attr,
 				       c->type == channel_ud ? (IBV_QP_STATE | IBV_QP_SQ_PSN) : IBV_QP_STATE);
 
-			if (ret)
+			if (ret) {
 				logg(LOG_CRIT, "ibv_modify_qp: Error when moving %s to RTS state. %s\n", c->text, errname());
+				return;
+			}
 
 		}
 		logg(LOG_NOTICE, "QP %s moved to state %s: QPN=0x%x\n", c->text,  send ? "RTS/RTR" : "RTR", c->qp->qp_num);
+		c->mode = channel_ready;
 	}
 }
 
@@ -1244,6 +1262,7 @@ static const char *make_ifname(struct i2
 
 	p = malloc(strlen(i->text) + strlen(x) + 1);
 	strcpy(p, i->text);
+	strcat(p, "-");
 	strcat(p, x);
 	return p;
 }
@@ -1254,7 +1273,7 @@ static struct rdma_channel *create_rdma_
 	int ret;
 
 
-	c->text = make_ifname(i, "-multicast");
+	c->text = make_ifname(i, "multicast");
 
 	c->bindaddr = sa;
 	ret = rdma_create_id(i->rdma_events, &c->id, c, RDMA_PS_UDP);
@@ -1403,8 +1422,6 @@ static struct rdma_channel *create_chann
 	c->attr.pkey_index = 0;
 	c->attr.qkey = qkey;
 
-//	c->attr.qkey = 0x12345;		/* Default QKEY from ibdump source code */
-
 	ret = ibv_modify_qp(c->qp, &c->attr,
 		       (i == i2r + ROCE && type == channel_raw) ?
 				(IBV_QP_STATE | IBV_QP_PORT) :
@@ -1432,6 +1449,7 @@ static struct rdma_channel *create_chann
 		signal(SIGABRT, &shutdown_sniffer);
 	}
 #endif
+	c->mode = channel_init;
 	return c;
 }
 
@@ -1461,7 +1479,7 @@ static struct rdma_channel *create_packe
 	fh = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
 
 	if (fh < 0) {
-		logg(LOG_ERR, "Raw Socker creation failed for %s:%s\n", i->text, errname());
+		logg(LOG_ERR, "Raw Socket creation failed for %s:%s\n", i->text, errname());
 		return NULL;
 	}
 
@@ -1484,7 +1502,7 @@ static struct rdma_channel *create_raw_c
 	struct rdma_channel *c = NULL;
 
 	if (!packet_socket) {
-		c = create_channel(i, RDMA_UDP_QKEY, port, nr_cq, "-raw", i == i2r + ROCE  ? IBV_QPT_RAW_PACKET : IBV_QPT_UD, channel_raw);
+		c = create_channel(i, 0x12345, port, nr_cq, "raw", i == i2r + ROCE  ? IBV_QPT_RAW_PACKET : IBV_QPT_UD, channel_raw);
 
 		if (!c)
 			logg(LOG_WARNING, "Falling back to raw socket on %s to monitor traffic\n", i->text);
@@ -1592,17 +1610,27 @@ static void setup_interface(enum interfa
 	}
 
 	if (unicast) {
-		i->ud = create_ud_channel(i, i->port, 100, RDMA_UDP_QKEY, "-ud");
+		unsigned c;
+
 		i->qp1 = create_ud_channel(i, i->port, 10, IB_DEFAULT_QP1_QKEY, "-qp1");
 		i->raw = create_raw_channel(i, i->port, 100);
 		i->ip_to_ep = hash_create(offsetof(struct endpoint, addr), sizeof(struct in_addr));
+
 		if (i == i2r + INFINIBAND)
 			i->ep = hash_create(offsetof(struct endpoint, lid), sizeof(uint16_t));
 		else
-			i->ep = i->ip_to_ep;;
+			i->ep = i->ip_to_ep;
+
+		/* Initialize all channels */
+		for(c = 0; c < MAX_UD_CHANNELS; c++) {
+			char x[5];
+
+			sprintf(x, "%u", c);
+			i->ud[c] = create_ud_channel(i, i->port, 100, RDMA_UDP_QKEY, x);
+		}
 	}
 
-	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u/%u/%u MTU=%u.\n",
+	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u UD %dMTU=%u.\n",
 		i->text,
 		ibv_get_device_name(i->context->device),
 		i->if_name, i->ifindex,
@@ -1610,8 +1638,7 @@ static void setup_interface(enum interfa
 		inet_ntop(AF_INET6, e->gid.raw, buf, INET6_ADDRSTRLEN),i->gid_index,
 		inet_ntoa(i->if_addr.sin_addr), default_port,
 		i->multicast ? i->multicast->nr_cq: 0,
-		i->ud ? i->ud->nr_cq : 0,
-		i->raw ? i->raw->nr_cq : 0,
+		MAX_UD_CHANNELS,
 		i->mtu
 	);
 }
@@ -2265,7 +2292,7 @@ static void list_endpoints(struct i2r_in
  * This function only adds the forward. Check if there is an existing
  * forward before calling this function.
  */
-static void add_forward(struct endpoint *source, uint32_t source_qp, struct endpoint *dest, uint32_t dest_qp, uint32_t qkey)
+static struct forward *add_forward(struct endpoint *source, uint32_t source_qp, struct endpoint *dest, uint32_t dest_qp, uint32_t qkey)
 {
 	struct forward *f = calloc(1, sizeof(struct forward));
 
@@ -2276,6 +2303,8 @@ static void add_forward(struct endpoint
 
 	f->next = source->forwards;
 	source->forwards = f;
+
+	return f;
 }
 
 /*
@@ -2958,8 +2987,6 @@ static const char *sidr_req(struct buf *
 	struct in_addr dest;
 	struct endpoint *dest_ep = NULL;
 
-	buf->c = dest_i->ud;
-
 	/* Establish Destination */
 	if (buf->ip_valid) {	/* ROCE */
 
@@ -3068,6 +3095,7 @@ static const char * sidr_rep(struct buf
 	uint32_t qpn_word = ntohl(sr->qpn);
 	uint32_t sr_qpn = qpn_word >> 8;
 	uint32_t sr_qkey = ntohl(sr->q_key);
+	struct forward *f;
 
 	
 	logg(LOG_NOTICE, "SIDR_REP: %s method=%s status=%s attr_id=%s attr_mod=%x ServiceId=%lx ReqId=%x Q_KEY=%x QPN=0x%x Status=%x\n",
@@ -3088,9 +3116,12 @@ static const char * sidr_rep(struct buf
 	if (ss->dest != buf->source_ep)
 		abort();
 
-	add_forward(ss->source, 0, ss->dest, sr_qpn, sr_qkey);
+	f = add_forward(ss->source, 0, ss->dest, sr_qpn, sr_qkey);
+	
+	/* Need to assign a channel here to use */
+
 
-	qpn_word = (ss->source->i->ud->qp->qp_num << 8) | (qpn_word & 0xff);
+	qpn_word = (f->c->qp->qp_num << 8) | (qpn_word & 0xff);
 	sr->qpn = htonl(qpn_word);
 
 	if (bridging)
@@ -3397,12 +3428,12 @@ static void receive_ud(struct buf *buf)
  	}	
 
 	/* This is to satisfy udaddy. Other apps that may use the immediate data differently may not work */
-	buf->imm = htonl(f->dest->i->ud->qp->qp_num);
+	buf->imm = htonl(f->c->qp->qp_num);
 
 	logg(LOG_NOTICE, "receive_ud %s Packet len=%u 0x%x lid=%d forwarded to %s %s:0x%x lid=%d qkey=%x\n", c->text,
-			w->byte_len, w->src_qp, e->lid, f->dest->i->ud->text, inet_ntoa(f->dest->addr), f->dest_qp, f->dest->lid, f->dest_qkey);
+			w->byte_len, w->src_qp, e->lid, f->c->text, inet_ntoa(f->dest->addr), f->dest_qp, f->dest->lid, f->dest_qkey);
 
-	send_ud(f->dest->i->ud, buf, f->dest->ah, f->dest_qp, f->dest_qkey);
+	send_ud(f->c, buf, f->dest->ah, f->dest_qp, f->dest_qkey);
  	return;
  
 discard:
@@ -3604,6 +3635,7 @@ static void status_write(void)
 	static char b[10000];
 	struct i2r_interface *i;
 	int n = 0;
+	unsigned j = 0;
 	int free = 0;
 	struct buf *buf;
 	int fd = status_fd;
@@ -3646,11 +3678,22 @@ static void status_write(void)
 
 		if (i->multicast)
 			n += channel_stats(b + n, i->multicast, i->text, "Multicast");
-		if (i->ud)
-			n += channel_stats(b + n, i->ud, i->text, "UD");
+
 		if (i->raw)
 			n += channel_stats(b + n, i->raw, i->text, "Raw");
 
+		for (j = 0; j < MAX_UD_CHANNELS; j++) {
+			struct rdma_channel *c = i->ud[j];
+			char x[10];
+
+			if (c->mode < channel_active)
+				continue;
+
+			sprintf(x, "UD%u", j);
+
+			n += channel_stats(b + n, c, i->text, x);
+		}
+
 	}
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
@@ -3662,7 +3705,6 @@ static void status_write(void)
 
 		printf("\nEndpoints on %s", i->text);
 		while ((nr = hash_get_objects(i->ep, offset, 20, (void **)e))) {
-			int j;
 
 			for (j = 0; j < nr; j++) {
 				struct endpoint *ep = e[j];
@@ -3965,12 +4007,10 @@ static void logging(void)
 	n = 0;
 	for(struct i2r_interface *i = i2r; i < i2r + NR_INTERFACES;i++)
       	   if (i->context)	{
-		n+= sprintf(counts + n, "%s(MC %d/%d, UD %d/%d, %s %d) ",
+		n+= sprintf(counts + n, "%s(MC %d/%d, %s %d) ",
 			i->text,
 			i->multicast->stats[packets_received],
 			i->multicast->stats[packets_sent],
-			i->ud ? i->ud->stats[packets_received] : 0,
-			i->ud ?	i->ud->stats[packets_sent] : 0,
 			i->raw ? (i->raw->type == channel_raw ? "RAW" : "PACKET") : "-",
 			i->raw ? i->raw->stats[packets_received]: 0);
 	}
@@ -4018,7 +4058,7 @@ static void register_poll_events(void)
 		register_callback(handle_comp_event, i->multicast->comp_events->fd, i->multicast->comp_events);
 		register_callback(handle_async_event, i->context->async_fd, i);
 
-		if (i->raw || i->ud)	/* They share the interface comp_events notifier */
+		if (i->raw)	/* They share the interface comp_events notifier */
 			register_callback(handle_comp_event, i->comp_events->fd, i->comp_events);
 
 	}
@@ -4058,11 +4098,6 @@ static void arm_channels(void)
 			setup_flow(i->raw);
 		}
 
-		if (i->ud) {
-			start_channel(i->ud);
-			ibv_req_notify_cq(i->ud->cq, 0);
-		}
-
 		if (i->qp1) {
 			start_channel(i->qp1);
 			ibv_req_notify_cq(i->qp1->cq, 0);
