Index: rdma-core/ib2roce/CMakeLists.txt-NO_MSTFLINT
===================================================================
--- rdma-core.orig/ib2roce/CMakeLists.txt-NO_MSTFLINT
+++ rdma-core/ib2roce/CMakeLists.txt-NO_MSTFLINT
@@ -15,6 +15,7 @@ target_link_libraries(ib2roce LINK_PRIVA
   ${SYSTEMD_LIBRARIES}
   ${CMAKE_THREAD_LIBS_INIT}
   ${CMAKE_DL_LIBS}
+  numa
   )
 rdma_man_pages(
   man/ib2roce.1
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -49,6 +49,7 @@
 #include <fcntl.h>
 #include <ctype.h>
 #include <pthread.h>
+#include <numa.h>
 
 #include <arpa/inet.h>
 #include <sys/socket.h>
@@ -220,7 +221,7 @@ typedef void receive_callback(struct buf
 
 struct rdma_channel {
 	struct i2r_interface *i;	/* The network interface of this channel */
-	struct core *core;		/* Core the channel is on or NULL if comp_events is used */
+	struct core_info *core;		/* Core the channel is on or NULL if comp_events is used */
 	receive_callback *receive;
 	struct ibv_cq *cq;		/* Every channel has a distinct CQ */
 	struct ibv_qp *qp;		/* All of the ibv_xxes are pointing to the interface versions if this is not a rdmacm channel */
@@ -293,6 +294,7 @@ static struct i2r_interface {
 	struct sockaddr_in if_netmask;
 	unsigned ifindex;
 	unsigned numa_node;			/* NUMA Affinity of the interface */
+	struct bitmask *cpus;
 	unsigned gid_index;
 	union ibv_gid gid;
 	struct ibv_device_attr device_attr;
@@ -1026,19 +1028,23 @@ struct core_info {
 	unsigned nr_channels;
 	struct ibv_cq *cq[MAX_CQS_PER_CORE];	/* The CQs to monitor */
 	enum core_state state;
-	struct rdma_channel channel[MAX_CQS_PER_CORE];
-	pthread_t thread;					/* Thread */
+	unsigned processor;			/* Affinity to which proc */
+	pthread_t thread;			/* Thread */
 	pthread_attr_t attr;
-	thread_callback *callback;
+	struct rdma_channel channel[MAX_CQS_PER_CORE];
 } core_infos[MAX_CORE];
 
 static struct rdma_channel *new_rdma_channel(struct i2r_interface *i, enum channel_type type)
 {
 	struct rdma_channel *c;
-	struct channel_info *ci = channel_infos + type;
+	struct channel_info *ci;
 	char *p;
 	short core;
-	int channel_nr = -1;
+	int channel_nr;
+
+retry:
+	ci = channel_infos + type;
+	channel_nr = -1;
 
 	/* Change affinity to the one fo the interface */
 	core = core_lookup(i, type);
@@ -1048,19 +1054,16 @@ static struct rdma_channel *new_rdma_cha
 		channel_nr = coi->nr_channels;
 		c = coi->channel + channel_nr;
 		coi->nr_channels++;
+		c->core = coi;
 
 	} else
 		c = calloc(1, sizeof(struct rdma_channel));
 
 	c->i = i;
 
-retry:
-	if (type == channel_err) {
-		if (channel_nr < 0)
-			free(c);
-		return NULL;
-	}
 
+	if (type == channel_err)
+		goto err;
 	c->type = type;
 	c->receive = ci->receive;
 
@@ -1084,9 +1087,19 @@ retry:
 		return c;
 	}
 
-	printf("ci->setup failed for %s\n", c->text);
-	type = ci->fallback;
-	goto retry;
+	if (type != ci->fallback) {
+		type = ci->fallback;
+		free(p);
+		if (channel_nr < 0)
+			free(c);
+		goto retry;
+	}
+
+err:
+	if (channel_nr < 0)
+		free(c);
+
+	return NULL;
 }
 
 static void process_cqes(struct rdma_channel *c, struct ibv_wc *w, unsigned cqs);
@@ -1146,12 +1159,22 @@ process_cq:
 /* Called after all the channels have been setup */
 static void start_cores(void)
 {
-	int i;
+	struct i2r_interface *i;
+	int j;
 
-	for(i = 0; i < cores; i++) {
-		struct core_info *ci = core_infos + i;
+	for(j = 0; j < cores; j++) {
+		struct core_info *ci = core_infos + j;
+
+		if (cores > 1) {
+			if (j < cores / 2) 
+				i = i2r + INFINIBAND;
+			else
+				i = i2r + ROCE;
+
+			pthread_attr_setaffinity_np(&ci->attr, i->cpus->size, (const cpu_set_t *)i->cpus->maskp);
+		}
 
-		if (pthread_create(&ci->thread, &ci->attr, &busyloop, core_infos + i)) {
+		if (pthread_create(&ci->thread, &ci->attr, &busyloop, core_infos + j)) {
 			logg(LOG_CRIT, "Pthread create failed: %s\n", errname());
 			abort();
 		}
@@ -1411,6 +1434,7 @@ static void get_if_info(struct i2r_inter
 {
 	int fh = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
 	struct ifreq ifr;
+	char buffer[80];
 	const char *reason = "socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)";
 
 	if (fh < 0)
@@ -1459,16 +1483,26 @@ static void get_if_info(struct i2r_inter
 	memcpy(&i->if_netmask, &ifr.ifr_netmask, sizeof(struct sockaddr_in));
 	ioctl(fh, SIOCGIFHWADDR, &ifr);
 	memcpy(&i->if_mac, &ifr.ifr_hwaddr.sa_data, ETH_ALEN);
-	goto out;
+	close(fh);
+
+	/* Read NUMA node of the IF */
+	snprintf(buffer, sizeof(buffer), "/sys/class/net/%s/device/numa_node", i->if_name);
+	fh = open(buffer, O_RDONLY);
+	read(fh, buffer, sizeof(buffer));
+	close(fh);
+
+	i->numa_node = atoi(buffer);
+
+	/* Determine CPUs that are local to the IF */
+	i->cpus = numa_allocate_cpumask();
+	numa_node_to_cpus(i->numa_node, i->cpus);
+	return;
 
 err:
 	logg(LOG_CRIT, "Cannot determine IP interface setup for %s %s : %s\n",
 		     ibv_get_device_name(i->context->device), reason, errname());
 
 	abort();
-
-out:
-	close(fh);
 }
 
 static void start_channel(struct rdma_channel *c)
@@ -1717,7 +1751,7 @@ static bool setup_packet(struct rdma_cha
 	fh = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
 
 	if (fh < 0) {
-		logg(LOG_ERR, "Raw Socker creation failed for %s:%s\n", i->text, errname());
+		logg(LOG_ERR, "Raw Socket creation failed for %s:%s\n", i->text, errname());
 		return false;
 	}
 
@@ -1868,7 +1902,7 @@ static void setup_interface(enum interfa
 	}
 
 	/* Affinity can change back */
-	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u/%u/%u MTU=%u.\n",
+	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u/%u/%u MTU=%u NUMA=%d.\n",
 		i->text,
 		ibv_get_device_name(i->context->device),
 		i->if_name, i->ifindex,
@@ -1878,7 +1912,8 @@ static void setup_interface(enum interfa
 		i->multicast ? i->multicast->nr_cq: 0,
 		i->ud ? i->ud->nr_cq : 0,
 		i->raw ? i->raw->nr_cq : 0,
-		i->mtu
+		i->mtu,
+		i->numa_node
 	);
 }
 
