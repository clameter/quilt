Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -336,6 +336,24 @@ struct endpoint {
 	struct forward *forwards;
 };
 
+/*
+ * A destination on an endpoint which can be addressed
+ * through a QP and requires a QKEY. A port number is
+ * usually used for non RDMA dests so include that too
+ */
+struct dest {
+	struct endpoint *ep;
+	uint32_t remote_qpn;	/* Address on the Endpoint */
+	uint32_t remote_qkey;
+};
+
+static inline void setup_dest(struct dest *d, struct endpoint *ep, uint32_t remote_qpn, uint32_t remote_qkey)
+{
+	d->ep = ep;
+	d->remote_qpn = remote_qpn;
+	d->remote_qkey = remote_qkey;
+}
+
 static struct i2r_interface {
 	/* Not changed when multithreading */
 	struct ibv_context *context;		/* Not for RDMA CM use */
@@ -385,17 +403,6 @@ static struct i2r_interface {
 } i2r[NR_INTERFACES];
 
 /*
- * Information provided by RDMA subsystem for how
- * to send a stream to an endpoint that
- * maybe multicast or unicast.
- */
-struct ah_info {
-	struct ibv_ah *ah;	/* Endpoint Identification */
-	uint32_t remote_qpn;	/* Address on the Endpoint */
-	uint32_t remote_qkey;
-};
-
-/*
  * A Unicastconnection to a certain port and host with
  * a list of pending I/O items and an rdma channel
  */
@@ -408,7 +415,7 @@ struct rdma_unicast {
 	struct sockaddr_in sin;		/* Target address */
 	struct rdma_channel *c;		/* Channel for resolution and I/O */
 	struct fifo pending;		/* Buffers waiting on resolution to complete */
-	struct ah_info ai;		/* If ai.ah != NULL then the address info is valid */
+	struct dest dest;
 };
 
 static inline void st(struct rdma_channel *c, enum stats s)
@@ -425,6 +432,7 @@ static void handle_receive_packet(void *
 static void handle_comp_event(void *private);
 static void handle_rdma_event(void *private);
 static void handle_async_event(void *private);
+static struct endpoint *mc_to_ep(struct i2r_interface *i, struct in_addr addr, struct ibv_pd *pd, struct ibv_ah_attr *at);
 
 
 static inline struct rdma_cm_id *id(enum interfaces i)
@@ -621,7 +629,7 @@ const char *mc_text[NR_MC_STATUS] = { "I
 struct mc_interface {
 	enum mc_status status;
 	bool sendonly;
-	struct ah_info ai;
+	struct dest dest;
 	struct sockaddr *sa;
 	uint32_t packet_time;		/* How much time must elapse for a packet to be sent 0 = disabled */
 	uint32_t max_burst;		/* How long can a burst last */
@@ -2382,12 +2390,10 @@ static void handle_rdma_event(void *priv
 			{
 				struct rdma_ud_param *param = &event->param.ud;
 				struct mc *m = (struct mc *)param->private_data;
-				struct ah_info *a = &m->interface[in].ai;
+				struct dest *d = &m->interface[in].dest;
 
-				a->remote_qpn = param->qp_num;
-				a->remote_qkey = param->qkey;
-				a->ah = ibv_create_ah(i->multicast->pd, &param->ah_attr);
-				if (!a->ah) {
+				setup_dest(d, mc_to_ep(i, m->addr, i->multicast->pd, &param->ah_attr), param->qkey, param->qkey);
+				if (!d->ep->ah) {
 					logg(LOG_ERR, "Failed to create AH for Multicast group %s on %s \n",
 						m->text, i->text);
 					m->interface[in].status = MC_ERROR;
@@ -2539,14 +2545,12 @@ static void handle_rdma_event(void *priv
 
 		case RDMA_CM_EVENT_ESTABLISHED:
 			{
-				struct ah_info *ai = &ru->ai;
+				struct dest *d = &ru->dest;
 
 				logg(LOG_NOTICE, "RDMA_CM_EVENT_ESTABLISHED for %s:%d\n",
 					inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
 
-				ai->ah = ibv_create_ah(ru->c->pd, &event->param.ud.ah_attr);
-				ai->remote_qpn = event->param.ud.qp_num;
-				ai->remote_qkey = event->param.ud.qkey;
+				setup_dest(d, mc_to_ep(i, ru->sin.sin_addr, ru->c->pd, &event->param.ud.ah_attr), event->param.ud.qp_num, event->param.ud.qkey);
 
 				rdma_ack_cm_event(event);
 				ru->state = UC_CONNECTED;
@@ -2589,7 +2593,7 @@ err:
  *
  * Space in the WR is limited, so it only works for very small packets.
  */
-static int send_inline(struct rdma_channel *c, void *addr, unsigned len, struct ah_info *ai, bool imm_used, unsigned imm)
+static int send_inline(struct rdma_channel *c, void *addr, unsigned len, struct dest *d, bool imm_used, unsigned imm)
 {
 	struct ibv_sge sge = {
 		.length = len,
@@ -2604,9 +2608,9 @@ static int send_inline(struct rdma_chann
 		.wr = {
 			/* Get addr info  */
 			.ud = {
-				.ah = ai->ah,
-				.remote_qpn = ai->remote_qpn,
-				.remote_qkey = ai->remote_qkey
+				.ah = d->ep->ah,
+				.remote_qpn = d->remote_qpn,
+				.remote_qkey = d->remote_qkey
 			}
 		}
 
@@ -2753,14 +2757,14 @@ static void send_queue_add(struct rdma_c
  * to be able to free up resources when done.
  */
 static int send_to(struct rdma_channel *c,
-	void *addr, unsigned len, struct ah_info *ai,
+	void *addr, unsigned len, struct dest *d,
 	bool imm_used, unsigned imm,
 	struct buf *buf)
 {
 	int ret;
 	struct ibv_send_wr *bad_send_wr;
 
-	if (!ai->ah)
+	if (!d->ep->ah)
 		abort();	/* Send without a route */
 
 	buf->c = c;	/* Change ownership to sending channel */
@@ -2775,9 +2779,9 @@ static int send_to(struct rdma_channel *
 	buf->wr.imm_data = imm;
 
 	/* Get addr info  */
-	buf->wr.wr.ud.ah = ai->ah;
-	buf->wr.wr.ud.remote_qpn = ai->remote_qpn;
-	buf->wr.wr.ud.remote_qkey = ai->remote_qkey;
+	buf->wr.wr.ud.ah = d->ep->ah;
+	buf->wr.wr.ud.remote_qpn = d->remote_qpn;
+	buf->wr.wr.ud.remote_qkey = d->remote_qkey;
 
 	buf->sge.length = len;
 	buf->sge.lkey = c->mr->lkey;
@@ -2822,9 +2826,9 @@ static int send_buf(struct buf *buf, str
 	int ret;
 
 	if (len < MAX_INLINE_DATA) {
-		ret = send_inline(ra->c, buf->cur, len, &ra->ai, buf->imm_valid, buf->imm);
+		ret = send_inline(ra->c, buf->cur, len, &ra->dest, buf->imm_valid, buf->imm);
 	} else
-		ret = send_to(ra->c, buf->cur, len, &ra->ai, buf->imm_valid, buf->imm, buf);
+		ret = send_to(ra->c, buf->cur, len, &ra->dest, buf->imm_valid, buf->imm, buf);
 
 	return ret;
 }
@@ -3667,7 +3671,28 @@ redo:
 	return ep;
 }
 
+static struct endpoint *mc_to_ep(struct i2r_interface *i, struct in_addr addr, struct ibv_pd *pd, struct ibv_ah_attr *at)
+{	
+	struct ibv_ah *ah;
+	struct endpoint *ep;
+
+	if (rate)
+		at->static_rate = rate;
+ 
+	ah = ibv_create_ah(pd, at);
+	if (!ah) {
+		logg(LOG_ERR, "mc_to_ep: Failed to create Endpoint on %s: %s. IP=%s\n",
+			i->text, errname(), inet_ntoa(addr));
+		return NULL;
+	}
 
+	ep = calloc(1, sizeof(struct endpoint));
+	ep->i = i;
+	ep->addr = addr;
+	ep->lid = at->dlid;
+	ep->ah = ah;
+	return ep;
+}
 
 /* Create Endpoint just from the IP address */
 static struct endpoint *ip_to_ep(struct i2r_interface *i, struct in_addr addr)
@@ -3794,7 +3819,7 @@ static void delayed_send(void *private)
 		logg(LOG_NOTICE, "%s: End of enforcing sending rate\n", c->i->text);
 	}
 
-	ret = send_to(c, buf->cur, buf->end - buf->cur, &mi->ai, buf->imm_valid, buf->imm, buf);
+	ret = send_to(c, buf->cur, buf->end - buf->cur, &mi->dest, buf->imm_valid, buf->imm, buf);
 	if (!ret)
 		st(c, packets_bridged);
 	buf->mi = NULL;
@@ -3942,11 +3967,11 @@ delayed_packet:
 		mi->last_sent = t;
 	}
 
-	if (!mi->ai.ah)		/* After a join it may take awhile for the ah pointer to propagate */
+	if (!mi->dest.ep->ah)		/* After a join it may take awhile for the ah pointer to propagate */
  		sleep(1);
 	get_buf(buf);	/* Packet will not be freed on return from this function */
  
-	ret = send_to(ch_out, buf->cur, buf->end - buf->cur, &mi->ai, buf->imm_valid, buf->imm, buf);
+	ret = send_to(ch_out, buf->cur, buf->end - buf->cur, &mi->dest, buf->imm_valid, buf->imm, buf);
  	if (ret)
 		return;
 
@@ -5221,9 +5246,9 @@ static void beacon_send(void *private)
 				if (sizeof(b) > MAX_INLINE_DATA) {
 					buf = alloc_buffer(i->multicast);
 					memcpy(buf->raw, &b, sizeof(b));
-					send_to(i->multicast, buf, sizeof(b), &beacon_mc->interface[in].ai, false, 0, buf);
+					send_to(i->multicast, buf, sizeof(b), &beacon_mc->interface[in].dest, false, 0, buf);
 				} else
-					send_inline(i->multicast, &b, sizeof(b), &beacon_mc->interface[in].ai, false, 0);
+					send_inline(i->multicast, &b, sizeof(b), &beacon_mc->interface[in].dest, false, 0);
 			}
 		}
 
