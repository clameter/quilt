Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -93,6 +93,8 @@
 // #define HAVE_MSTFLINT
 // #define DEBUG
 
+// #define RAW
+
 /* Globals */
 
 static unsigned default_port = 0;	/* Port to use to bind to devices  */
@@ -104,7 +106,9 @@ static bool update_requested = false;	/*
 static bool beacon = false;		/* Announce our presence (and possibly coordinate between multiple instances in the future */
 static bool bridging = true;		/* Allow briding */
 static bool unicast = false;		/* Bridge unicast packets */
+#ifdef RAW
 static bool raw = false;		/* Use raw channels */
+#endif
 static bool flow_steering = false;	/* Use flow steering to filter packets */
 static int log_packets = 0;		/* Show details on discarded packets */
 static bool testing = false;		/* Run some tests on startup */
@@ -350,7 +354,9 @@ static struct i2r_interface {
 	struct rdma_channel *multicast;
 	struct rdma_channel *qp1;		/* Channel for QP1 communications but not QP1 (userspace) */
 	struct rdma_channel *ud;		/* Regular data */
+#ifdef RAW
 	struct rdma_channel *raw;
+#endif
 	struct ibv_comp_channel *comp_events;
 	struct ibv_cq *cq;
 	struct ibv_pd *pd;
@@ -428,7 +434,9 @@ static void add_event(uint64_t  when, ev
 static uint64_t run_events(void);
 static struct rdma_unicast *new_rdma_unicast(struct i2r_interface *i, struct sockaddr_in *sin);
 static void register_callback(void (*callback)(void *), int fd, void *private);
+#ifdef RAW
 static void handle_receive_packet(void *private);
+#endif
 static void handle_comp_event(void *private);
 static void handle_rdma_event(void *private);
 static void handle_async_event(void *private);
@@ -1109,8 +1117,17 @@ static void init_buf(void)
 }
 
 typedef bool setup_callback(struct rdma_channel *c);
-static receive_callback receive_main, receive_multicast, receive_raw, receive_ud, receive_qp1;
-static setup_callback setup_multicast, setup_channel, setup_raw, setup_packet, setup_incoming;
+static receive_callback receive_main, receive_multicast,
+#ifdef RAW
+			receive_raw,
+#endif
+			receive_ud, receive_qp1;
+
+static setup_callback setup_multicast, setup_channel,
+#ifdef RAW
+		      setup_raw, setup_packet,
+#endif
+		      setup_incoming;
 
 #define NO_CORE (-1)
 /*
@@ -1134,9 +1151,11 @@ struct channel_info {
 	{ "multicast",	0, 0,	true,	10,	20,	0,		IBV_QPT_UD,		setup_multicast, receive_multicast, channel_err },
 	{ "ud",		1, 1,	true,	100,	200,	RDMA_UDP_QKEY,	IBV_QPT_UD,		setup_channel,	receive_ud,	channel_err }, 
 	{ "qp1",	2, 1,	false, 	10,	5,	IB_DEFAULT_QP1_QKEY, IBV_QPT_UD,	setup_channel,	receive_qp1,	channel_err },
+#ifdef RAW
 	{ "raw",	3, 1,	false,	1000, 	5,	0x12345,	IBV_QPT_RAW_PACKET,	setup_raw,	receive_raw,	channel_packet },
 	{ "ibraw",	3, 1,	false,	1000,	5,	0x12345,	IBV_QPT_UD,		setup_raw,	receive_raw,	channel_packet },
 	{ "packet",	-1, -1,	false,	0,	0,	0,		0,			setup_packet,	receive_raw,	channel_err },
+#endif
 	{ "incoming",	-1, -1,	false,	100,	50,	0,		0,			setup_incoming,	receive_main,	channel_err },
 	{ "error",	-1, -1,	false,	0,	0,	0,		0,			NULL,		NULL,		channel_err },
 };
@@ -1618,7 +1637,9 @@ static void post_receive_buffers(void)
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++) {
 		post_receive(i->multicast);
+#ifdef RAW
 		post_receive(i->raw);
+#endif
 		post_receive(i->qp1);
 		post_receive(i->ud);
 	}
@@ -1669,18 +1690,22 @@ static void shutdown_sniffer(int arg) {
 
 static void qp_destroy(struct i2r_interface *i)
 {
+#ifdef RAW
 #ifdef HAVE_MSTFLINT
 	if (i == i2r + INFINIBAND && i->raw && i->raw->type == channel_ibraw) {
 		if (clear_ib_sniffer(i->port, i->raw->qp))
 			logg(LOG_ERR, "Failed to switch off sniffer mode on %s\n", i->raw->text);
 	}
 #endif
+#endif
 
 	channel_destroy(i->multicast);
 	i->multicast = NULL;
 
+#ifdef RAW
 	channel_destroy(i->raw);
 	i->raw = NULL;
+#endif
 
 	channel_destroy(i->ud);
 	i->ud = NULL;
@@ -1999,6 +2024,7 @@ static bool setup_channel(struct rdma_ch
 	return true;
 }
 
+#ifdef RAW
 static bool setup_packet(struct rdma_channel *c)
 {
 	struct i2r_interface *i = c->i;
@@ -2057,6 +2083,7 @@ static bool setup_raw(struct rdma_channe
 #endif
 	return true;
 }
+#endif
 
 static void setup_interface(enum interfaces in)
 {
@@ -2161,6 +2188,7 @@ static void setup_interface(enum interfa
 
 		i->ud = new_rdma_channel(i, channel_ud);
 		i->qp1 = new_rdma_channel(i, channel_qp1);
+#ifdef RAW
 
 		if (raw) {
 			if (i == i2r + INFINIBAND) {
@@ -2173,6 +2201,7 @@ static void setup_interface(enum interfa
 					i->raw = new_rdma_channel(i, channel_raw);
 			}
 		}
+#endif
 	}
 
 	numa_run_on_node(-1);
@@ -2186,7 +2215,11 @@ static void setup_interface(enum interfa
 		inet_ntoa(i->if_addr.sin_addr), default_port,
 		i->multicast ? i->multicast->nr_cq: 0,
 		i->ud ? i->ud->nr_cq : 0,
+#ifdef RAW
 		i->raw ? i->raw->nr_cq : 0,
+#else
+		0,
+#endif
 		i->mtu,
 		i->numa_node
 	);
@@ -2737,6 +2770,7 @@ static struct rdma_unicast *new_rdma_uni
 	return ra;
 }
 
+#ifdef RAW
 static void setup_flow(struct rdma_channel *c)
 {
 	if (!c)
@@ -2787,6 +2821,7 @@ static void setup_flow(struct rdma_chann
 	if (!c->flow)
 		logg(LOG_ERR, "Failure to create flow on %s. Errno %s\n", c->text, errname());
 }
+#endif
 
 static void unicast_packet(struct rdma_channel *c, struct buf *buf, struct in_addr dest_addr)
 {
@@ -3415,9 +3450,11 @@ static bool valid_addr(struct i2r_interf
 	return ((addr.s_addr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask));
 }
 
+#ifdef RAW
 static bool multicast_lid(uint16_t lid) {
 	return lid & 0xc000;
 }
+#endif
 
 static bool unicast_lid(uint16_t lid) {
 	return lid > 0 && lid < 0xc000;
@@ -3915,6 +3952,7 @@ static void receive_main(struct buf *buf
 	st(c, packets_invalid);
 }
 
+#ifdef RAW
 /*
  * Simple listener to quickly gather IP/ GID information off the wire
  */
@@ -3989,6 +4027,7 @@ static const char *process_arp(struct i2
 	}
 	return NULL;
 }
+#endif
 
 /* SIDR handshake with gateway involved. This is based on the assumption
  * that we are dealing with rdmacm data streams where an
@@ -4301,6 +4340,7 @@ static const char * sidr_rep(struct buf
 	return NULL;
 }
 
+#ifdef RAW
 static void receive_raw(struct buf *buf)
 {
 	struct rdma_channel *c = buf->c;
@@ -4550,6 +4590,7 @@ discard:
 
 	st(c, packets_invalid);
 }
+#endif
 
 /* Unicast packet reception */
 static void receive_ud(struct buf *buf)
@@ -4794,6 +4835,7 @@ static void handle_comp_event(void *priv
 		process_cqes(c, wc, cqs);
 }
 
+#ifdef RAW
 /* Special handling using raw socket */
 static void handle_receive_packet(void *private)
 {
@@ -4842,7 +4884,7 @@ static void handle_receive_packet(void *
 	c->receive(buf);
 	put_buf(buf);
 }
-
+#endif
 
 static void handle_async_event(void *private)
 {
@@ -4893,8 +4935,10 @@ static unsigned show_interfaces(char *b)
 			n += channel_stats(b + n, i->multicast, i->text, "Multicast");
 		if (i->ud)
 			n += channel_stats(b + n, i->ud, i->text, "UD");
+#ifdef RAW
 		if (i->raw)
 			n += channel_stats(b + n, i->raw, i->text, "Raw");
+#endif
 
 	}
 	return n;
@@ -5384,8 +5428,10 @@ static void brief_status(void)
 			n+= sprintf(counts + n, ", UD %d/%d",
 				i->ud->stats[packets_received],
 				i->ud->stats[packets_sent]);
+#ifdef RAW
 		if (i->raw && i->raw->stats[packets_received])
 			n+= sprintf(counts + n, ", RAW %d", i->raw->stats[packets_received]);
+#endif
 
 		n+= sprintf(counts + n, ") ");
 	}
@@ -5453,6 +5499,7 @@ static void arm_channels(struct core_inf
 			ibv_req_notify_cq(i->multicast->cq, 0);
 		}
 
+#ifdef RAW
 		if (i->raw && core == i->raw->core &&
 			       (i->raw->type == channel_raw || i->raw->type == channel_ibraw)) {
 			start_channel(i->raw);
@@ -5460,6 +5507,7 @@ static void arm_channels(struct core_inf
 
 			setup_flow(i->raw);
 		}
+#endif
 
 		if (i->ud && core == i->ud->core) {
 			start_channel(i->ud);
@@ -5662,7 +5710,9 @@ struct enable_option {
 { "latency", true,		&latency, NULL,		"on", "off",	"Monitor latency of busyloop and event processing and provide stats" },
 { "iburst", true,		NULL, &max_iburst,	"100", "0",	"Infiniband: Exempt the first N packets from swrate (0=off)" },
 { "rburst", true,		NULL, &max_rburst,	"100", "0",	"ROCE: Exempt the first N packets from swrate (0=off)" },
+#ifdef RAW
 { "raw", false,			&raw, NULL,		"on", "off",	"Use of RAW sockets to capture SIDR Requests. Avoids having to use a patched kernel" },
+#endif
 { "statint", true,		NULL, &stat_interval,	"60", "1",	"Sampling interval to calculate pps values" },
 { "unicast", false,		&unicast, NULL,		"on", "off",	"Processing of unicast packets with QP1 handling of SIDR REQ/REP" },
 { NULL, false, NULL, NULL, NULL, NULL, NULL }
@@ -6140,8 +6190,10 @@ static void channels_cmd(char *parameter
 			channel_stat(i->multicast);
 		if (i->ud)
 			channel_stat(i->ud);
+#ifdef RAW
 		if (i->raw)
 			channel_stat(i->raw);
+#endif
 		if (i->qp1)
 			channel_stat(i->qp1);
 	}
@@ -6167,8 +6219,10 @@ static void zap_cmd(char *parameters)
 			channel_zap(i->multicast);
 		if (i->ud)
 			channel_zap(i->ud);
+#ifdef RAW
 		if (i->raw)
 			channel_zap(i->raw);
+#endif
 		if (i->qp1)
 			channel_zap(i->qp1);
 	}
