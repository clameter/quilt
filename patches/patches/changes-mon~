Index: rdma-core/ib2roce/cma-hdr.h
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/cma-hdr.h
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+/*
+ * Copyright (c) 2005 Voltaire Inc.  All rights reserved.
+ * Copyright (c) 2002-2005, Network Appliance, Inc. All rights reserved.
+ * Copyright (c) 1999-2019, Mellanox Technologies, Inc. All rights reserved.
+ * Copyright (c) 2005-2006 Intel Corporation.  All rights reserved.
+ */
+
+union cma_ip_addr {
+	struct in6_addr ip6;
+	struct {
+		__be32 pad[3];
+		__be32 addr;
+	} ip4;
+};
+
+struct cma_hdr {
+	uint8_t cma_version;
+	uint8_t ip_version;	/* IP version: 7:4 */
+	__be16 port;
+	union cma_ip_addr src_addr;
+	union cma_ip_addr dst_addr;
+};
+
+#define CMA_VERSION 0x00
+
+static inline uint8_t cma_get_ip_ver(const struct cma_hdr *hdr)
+{
+	return hdr->ip_version >> 4;
+}
+
+static inline void cma_set_ip_ver(struct cma_hdr *hdr, uint8_t ip_ver)
+{
+	hdr->ip_version = (ip_ver << 4) | (hdr->ip_version & 0xF);
+}
+
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -75,6 +75,7 @@
 #include "fifo.h"
 #include "hash.h"
 #include "ibraw.h"
+#include "cma-hdr.h"
 
 #define VERSION "2022.0220"
 
@@ -85,7 +86,7 @@
 
 #define BEACON_SIGNATURE 0xD3ADB33F
 
-// #define HAVE_MSTFLINT
+#define HAVE_MSTFLINT
 // #define DEBUG
 
 /* Globals */
@@ -2730,7 +2731,6 @@ struct sidr_req {
 	uint16_t	pkey;
 	uint16_t	reserved;
 	uint64_t	service_id;
-	char private[100];
 } __packed;
 
 #if 0
@@ -2748,6 +2748,7 @@ static void print_sidr(void)
 		header, buf->bth.apsn, umad_method_str(buf->umad.mgmt_class, buf->umad.method),
 		umad_common_mad_status_str(buf->umad.status),
 		umad_attribute_str(buf->umad.mgmt_class, buf->umad.attr_id), ntohl(buf->umad.attr_mod),
+t
 		be64toh(sr.service_id), ntohl(sr.request_id), ntohs(sr.pkey),
 		payload);
 }
@@ -2849,6 +2850,7 @@ static const char *process_arp(struct i2
 		if (!ep)
 			return "Cannot create Endpoint";
 
+		logg(LOG_NOTICE, "ARP: Created Endpoint IP=%s LID=%d\n", inet_ntoa(ep->addr), ep->lid);
 		memcpy(&ep->gid, mac, arp.ar_hln);
 		if (lids[j]) {
 			if (ep->lid) {
@@ -2882,12 +2884,27 @@ static const char *sidr_req(struct buf *
 	} else { /* Infiniband */
 		struct in_addr source;
 		struct sidr_req sr;
+		struct cma_hdr ch; 
 
 		PULL(buf, sr);
+		PULL(buf, ch);
 
-		dest.s_addr = 0;
-		if (!scan_private(sr.private + 36, &source, &dest))
-			return "SIDR REQ: Dest and Source IP not determined";
+		if (ch.cma_version != CMA_VERSION)
+			return "SIDR REQ: Unsupported CMA version";
+
+		if (cma_get_ip_ver(&ch) != 4)
+			return "SIDR REQ: Only IPv4 private data supported";
+
+
+		/* For some reason this is being crossed here */
+		source.s_addr = ch.dst_addr.ip4.addr;
+		dest.s_addr = ch.src_addr.ip4.addr;
+
+		if (!valid_addr(source_i, source))
+			return "SIDR REQ: Invalid Source address";
+
+		if (!valid_addr(dest_i, dest))
+			return "SIDR REQ: Invalid Destination address";
 
 		if (source_ep->addr.s_addr == 0 && source.s_addr) {
 			source_ep->addr = source;
@@ -2904,8 +2921,6 @@ static const char *sidr_req(struct buf *
 	if (!dest_ep)
 		return "Cannot forward MAD packet. AH is not known";
 
-	logg(LOG_NOTICE, "SIDR REQ: Dest %s on %s QP=%d\n", inet_ntoa(dest_ep->addr), dest_i->text, w->src_qp);
-
 	if (bridging) {
 
 		remove_forward(dest_ep, 1);
@@ -3052,13 +3067,13 @@ static void receive_raw(struct buf *buf)
 
 			if (buf->ip.protocol != IPPROTO_UDP) {
 
-				reason = "-Only UDP packets";
+				reason = "Only UDP packets";
 				goto discard;
 
 			}
 
 			if (buf->e.ether_dhost[0] & 0x1) {
-				reason = "-Multicast on RAW channel";
+				reason = "Multicast on RAW channel";
 				goto discard;
 			}
 
@@ -3119,7 +3134,7 @@ static void receive_raw(struct buf *buf)
 		if (ec_header.type == ETHERTYPE_ARP)
 			process_arp(i, buf, lids);
 		else
-			reason = "Only ARPs when QP > 1";
+			reason = "-Only ARPs when QP > 1";
 
 		if (reason)
 			goto discard;
@@ -3132,8 +3147,14 @@ static void receive_raw(struct buf *buf)
 	/* Start MAD payload */
 	PULL(buf, buf->umad);
 
+	logg(LOG_NOTICE, "QP1 packet %s from %s LID %d SQP=%x DQP=%x method=%s status=%s attr_id=%s\n", i->text,
+		inet_ntoa(ep->addr), ep->lid, w->src_qp, __bth_qpn(&bth),
+ 		umad_method_str(buf->umad.mgmt_class, buf->umad.method),
+		umad_common_mad_status_str(buf->umad.status),
+		umad_attribute_str(buf->umad.mgmt_class, buf->umad.attr_id));
+
 	if (buf->umad.mgmt_class != UMAD_CLASS_CM) {
-		reason = "Only CM Class MADs are supported";
+		reason = "-Only CM Class MADs are supported";
 		goto discard;
 	}
 
@@ -3148,10 +3169,9 @@ static void receive_raw(struct buf *buf)
 
 discard:
 	if (reason[0] != '-' || log_packets > 1) 
-		logg(LOG_NOTICE, "Discard %s %s: %s Length=%u/prot=%u/pos=%lu Packet=%s\n",
+		logg(LOG_NOTICE, "Discard %s %s: %s Length=%u/prot=%u/pos=%lu\n",
 			c->text, reason, header,
-			len, buf->w->byte_len, buf->cur - buf->raw,
-			_hexbytes(buf->raw, buf->w->byte_len));
+			buf->w->byte_len, len, buf->cur - buf->raw);
 
 	st(c, packets_invalid);
 packet_done:
