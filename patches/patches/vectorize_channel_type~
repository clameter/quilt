Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -179,7 +179,10 @@ static const char *stats_text[nr_stats]
 
 static int cq_high = 0;	/* Largest batch of CQs encountered */
 
-enum channel_type { channel_rdmacm, channel_ud, channel_qp1, channel_raw, channel_packet, nr_channel_types };
+enum channel_type { channel_rdmacm, channel_ud, channel_qp1,
+	channel_raw, channel_ibraw,
+	channel_packet, channel_incoming,
+	channel_err, nr_channel_types };
 
 struct buf;
 
@@ -195,8 +198,8 @@ struct rdma_channel {
 	struct ibv_pd *pd;
 	struct ibv_flow *flow;
 	unsigned int active_receive_buffers;
-	unsigned int max_receive_buffers;
 	unsigned int nr_cq;
+	unsigned int nr_receive;
 	unsigned stats[nr_stats];
 	enum channel_type type;
 	bool listening;		/* rdmacm Channel is listening for connections */
@@ -308,8 +311,6 @@ static struct rdma_unicast *new_rdma_uni
 static void register_callback(void (*callback)(void *), int fd, void *private);
 static void handle_receive_packet(void *private);
 
-static receive_callback receive_main, receive_multicast, receive_raw, receive_ud, receive_qp1;
-
 static inline struct rdma_cm_id *id(enum interfaces i)
 {
 	return i2r[i].multicast->id;
@@ -888,6 +889,72 @@ static struct buf *alloc_buffer(struct r
 	return buf;
 }
 
+typedef bool setup_callback(struct rdma_channel *c);
+static receive_callback receive_main, receive_multicast, receive_raw, receive_ud, receive_qp1;
+static setup_callback setup_multicast, setup_channel, setup_raw, setup_packet, setup_incoming;
+
+/*
+ * Matrix of channel types and their characteristics
+ */
+struct channel_info {
+
+	const char *suffix;
+	uint32_t nr_cq;		/* NR of CQ entries to allocate allocate to this channel */
+	uint32_t nr_receive;	/* NR buffers for receive queue */
+	uint32_t fractional;	/* NR is a fraction of all available buffers */
+	uint32_t qkey;
+	uint16_t qp_type;
+	setup_callback *setup;
+	receive_callback *receive;
+	enum channel_type fallback;
+
+} channel_infos[nr_channel_types] = {
+	{ "multicast",	true,	10,	20,	0,		IBV_QPT_UD,		setup_multicast, receive_multicast, channel_err },
+	{ "ud",		true,	100,	200,	RDMA_UDP_QKEY,	IBV_QPT_UD,		setup_channel,	receive_ud,	channel_err }, 
+	{ "qp1",	false, 	10,	5,	IB_DEFAULT_QP1_QKEY, IBV_QPT_UD,	setup_channel,	receive_qp1,	channel_err },
+	{ "raw",	false,	1000, 	5,	0x12345,	IBV_QPT_RAW_PACKET,	setup_raw,	receive_raw,	channel_packet },
+	{ "ibraw",	false,	1000,	5,	0x12345,	IBV_QPT_UD,		setup_raw,	receive_raw,	channel_packet },
+	{ "packet",	false,	0,	0,	0,		0,			setup_packet,	receive_raw,	channel_err },
+	{ "incoming",	false,	100,	50,	0,		0,			setup_incoming,	receive_main,	channel_err },
+	{ "error",	false,	0,	0,	0,		0,			NULL,		NULL,		channel_err },
+};
+
+static struct rdma_channel *new_rdma_channel(struct i2r_interface *i, enum channel_type type)
+{
+	struct rdma_channel *c = calloc(1, sizeof(struct rdma_channel));
+	struct channel_info *ci = channel_infos + type;
+	char *p;
+
+	c->i = i;
+retry:
+	c->type = type;
+	c->receive = ci->receive;
+
+	p = malloc(strlen(i->text) + strlen(ci->suffix) + 2);
+	strcpy(p, i->text);
+	strcat(p, "-");
+	strcat(p, ci->suffix);
+	c->text = p;
+
+	if (ci->fractional) {
+		c->nr_cq = nr_buffers / ci->nr_cq;
+		c->nr_receive = nr_buffers / ci->nr_receive;
+	} else {
+		c->nr_cq = ci->nr_cq;
+		c->nr_receive = ci->nr_receive;
+	}	
+
+	if (ci->setup(c))
+		return c;
+
+	if (type != channel_err) {
+		type = ci->fallback;
+		goto retry;
+	}
+	return NULL;
+}
+
+
 static char hexbyte(unsigned x)
 {
 	if (x < 10)
@@ -1015,7 +1082,7 @@ static void post_receive(struct rdma_cha
 	if (!c || !nextbuffer)
 		return;
 
-	if (c->active_receive_buffers >= c->max_receive_buffers)
+	if (c->active_receive_buffers >= c->nr_receive)
 		return;
 
 	recv_wr.next = NULL;
@@ -1025,7 +1092,7 @@ static void post_receive(struct rdma_cha
 	sge.length = DATA_SIZE;
 	sge.lkey = c->mr->lkey;
 
-	while (c->active_receive_buffers < c->max_receive_buffers) {
+	while (c->active_receive_buffers < c->nr_receive) {
 
 		struct buf *buf = alloc_buffer(c);
 
@@ -1100,7 +1167,7 @@ static void shutdown_sniffer(int arg) {
 static void qp_destroy(struct i2r_interface *i)
 {
 #ifdef HAVE_MSTFLINT
-	if (i == i2r + INFINIBAND && i->raw && i->raw->type == channel_raw) {
+	if (i == i2r + INFINIBAND && i->raw && i->raw->type == channel_ibraw) {
 		if (clear_ib_sniffer(i->port, i->raw->qp))
 			logg(LOG_ERR, "Failed to switch off sniffer mode on %s\n", i->raw->text);
 	}
@@ -1229,53 +1296,7 @@ static void stop_channel(struct rdma_cha
 	logg(LOG_NOTICE, "QP %s moved to state QPS_INIT\n", c->text);
 }
 
-static const char *make_ifname(struct i2r_interface *i, const char *x)
-{
-	char *p;
-
-	p = malloc(strlen(i->text) + strlen(x) + 2);
-	strcpy(p, i->text);
-	strcat(p, "-");
-	strcat(p, x);
-	return p;
-}
-
-static struct rdma_channel *new_rdma_channel(struct i2r_interface *i,
-	receive_callback receive, enum channel_type type, const char *suffix)
-{
-	struct rdma_channel *c = calloc(1, sizeof(struct rdma_channel));
-
-	c->i = i;
-	c->type = type;
-	c->receive = receive;
-	c->text = make_ifname(i, suffix);
-
-	return c;
-}
-
-static struct rdma_channel *create_rdma_id(struct i2r_interface *i, struct sockaddr *sa)
-{
-	struct rdma_channel *c = new_rdma_channel(i, receive_multicast, channel_rdmacm, "multicast");
-	int ret;
-
-	c->bindaddr = sa;
-	ret = rdma_create_id(i->rdma_events, &c->id, c, RDMA_PS_UDP);
-	if (ret) {
-		logg(LOG_CRIT, "Failed to allocate RDMA CM ID for %s failed (%s).\n",
-			c->text, errname());
-		return NULL;
-	}
-
-	ret = rdma_bind_addr(c->id, c->bindaddr);
-	if (ret) {
-		logg(LOG_CRIT, "Failed to bind %s interface. Error %s\n",
-			c->text, errname());
-		return NULL;
-	}
-	return c;
-}
-
-static int allocate_rdmacm_qp(struct rdma_channel *c, unsigned nr_cq, bool multicast)
+static int allocate_rdmacm_qp(struct rdma_channel *c, bool multicast)
 {
 	struct ibv_qp_init_attr_ex init_qp_attr_ex;
 	int ret;
@@ -1303,17 +1324,16 @@ static int allocate_rdmacm_qp(struct rdm
 		abort();
 	}
 
-	c->nr_cq = nr_cq;
-	c->cq = ibv_create_cq(c->id->verbs, nr_cq, c, c->comp_events, 0);
+	c->cq = ibv_create_cq(c->id->verbs, c->nr_cq, c, c->comp_events, 0);
 	if (!c->cq) {
 		logg(LOG_CRIT, "ibv_create_cq failed for %s : %s nr_cq=%d.\n",
-			c->text, errname(), nr_cq);
+			c->text, errname(), c->nr_cq);
 		return 1;
 	}
 
 	memset(&init_qp_attr_ex, 0, sizeof(init_qp_attr_ex));
-	init_qp_attr_ex.cap.max_send_wr = nr_cq;
-	init_qp_attr_ex.cap.max_recv_wr = nr_cq;
+	init_qp_attr_ex.cap.max_send_wr = c->nr_cq;
+	init_qp_attr_ex.cap.max_recv_wr = c->nr_cq;
 	init_qp_attr_ex.cap.max_send_sge = 1;	/* Highly sensitive settings that can cause -EINVAL if too large (10 f.e.) */
 	init_qp_attr_ex.cap.max_recv_sge = 1;
 	init_qp_attr_ex.cap.max_inline_data = MAX_INLINE_DATA;
@@ -1339,7 +1359,7 @@ static int allocate_rdmacm_qp(struct rdm
 
 	if (ret) {
 		logg(LOG_CRIT, "rdma_create_qp_ex failed for %s. Error %s. #CQ=%d\n",
-				c->text, errname(), nr_cq);
+				c->text, errname(), c->nr_cq);
 		return 1;
 	}
 
@@ -1353,9 +1373,42 @@ static int allocate_rdmacm_qp(struct rdm
 	return 0;
 }
 
+bool setup_multicast(struct rdma_channel *c)
+{
+	struct i2r_interface *i = c->i;
+	struct sockaddr_in *sin;
+	int ret;
+
+	sin = calloc(1, sizeof(struct sockaddr_in));
+	sin->sin_family = AF_INET;
+	sin->sin_addr = i->if_addr.sin_addr;
+	sin->sin_port = htons(default_port);
+	c->bindaddr = (struct sockaddr *)sin;
+
+	ret = rdma_create_id(i->rdma_events, &c->id, c, RDMA_PS_UDP);
+	if (ret) {
+		logg(LOG_CRIT, "Failed to allocate RDMA CM ID for %s failed (%s).\n",
+			c->text, errname());
+		return false;
+	}
+
+	ret = rdma_bind_addr(c->id, c->bindaddr);
+	if (ret) {
+		logg(LOG_CRIT, "Failed to bind %s interface. Error %s\n",
+			c->text, errname());
+		return false;
+	}
+
+	return allocate_rdmacm_qp(c, true);
+}
+
+bool setup_incoming(struct rdma_channel *c)
+{
+	return allocate_rdmacm_qp(c, true);
+}
+
 /* Not using rdmacm so this is easier on the callbacks */
-static void init_channel(struct rdma_channel *c, uint32_t qkey,
-		int port, unsigned nr_cq, int qp_type)
+static bool setup_channel(struct rdma_channel *c)
 {
 	struct i2r_interface *i = c->i;
 	int ret;
@@ -1365,25 +1418,23 @@ static void init_channel(struct rdma_cha
 	c->comp_events = i->comp_events;
 	c->pd = i->pd;
 
-	c->nr_cq = nr_cq;
-	c->max_receive_buffers = nr_cq / 2;
 
-	c->cq = ibv_create_cq(i->context, nr_cq, c, i->comp_events, 0);
+	c->cq = ibv_create_cq(i->context, c->nr_cq, c, i->comp_events, 0);
 	if (!c->cq) {
 		logg(LOG_CRIT, "ibv_create_cq failed for %s.\n",
 			c->text);
-		return;
+		return false;
 	}
 
 	memset(&init_qp_attr_ex, 0, sizeof(init_qp_attr_ex));
-	init_qp_attr_ex.cap.max_send_wr = nr_cq;
-	init_qp_attr_ex.cap.max_recv_wr = nr_cq;
+	init_qp_attr_ex.cap.max_send_wr = c->nr_cq;
+	init_qp_attr_ex.cap.max_recv_wr = c->nr_cq;
 	init_qp_attr_ex.cap.max_send_sge = 1;	/* Highly sensitive settings that can cause -EINVAL if too large (10 f.e.) */
 	init_qp_attr_ex.cap.max_recv_sge = 1;
 	init_qp_attr_ex.cap.max_inline_data = MAX_INLINE_DATA;
 	init_qp_attr_ex.qp_context = c;
 	init_qp_attr_ex.sq_sig_all = 0;
-	init_qp_attr_ex.qp_type = qp_type,
+	init_qp_attr_ex.qp_type = channel_infos[c->type].qp_type,
 	init_qp_attr_ex.send_cq = c->cq;
 	init_qp_attr_ex.recv_cq = c->cq;
 
@@ -1394,14 +1445,14 @@ static void init_channel(struct rdma_cha
 	c->qp = ibv_create_qp_ex(i->context, &init_qp_attr_ex);
 	if (!c->qp) {
 		logg(LOG_CRIT, "ibv_create_qp_ex failed for %s. Error %s. Port=%d #CQ=%d\n",
-				c->text, errname(), port, nr_cq);
-		return;
+				c->text, errname(), i->port, c->nr_cq);
+		return false;
 	}
 
-	c->attr.port_num = port;
+	c->attr.port_num = i->port;
 	c->attr.qp_state = IBV_QPS_INIT;
 	c->attr.pkey_index = 0;
-	c->attr.qkey = qkey;
+	c->attr.qkey = channel_infos[c->type].qkey;
 
 	ret = ibv_modify_qp(c->qp, &c->attr,
 	       (i == i2r + ROCE && c->type == channel_raw) ?
@@ -1414,17 +1465,19 @@ static void init_channel(struct rdma_cha
 		ibv_destroy_qp(c->qp);
 		ibv_destroy_cq(c->cq);
 		c->qp = NULL;
+		return false;
 	}
+	return true;
 }
 
-static struct rdma_channel *create_packet_socket(struct i2r_interface *i, int port)
+static bool setup_packet(struct rdma_channel *c)
 {
-	struct rdma_channel *c;
+	struct i2r_interface *i = c->i;
 	int fh;
 	struct sockaddr_ll ll  = {
 		.sll_family = AF_PACKET,
 		.sll_protocol = htons(ETH_P_ALL),
-		.sll_ifindex = port,
+		.sll_ifindex = i->ifindex,
 		.sll_hatype = ARPHRD_ETHER,
 		.sll_pkttype = PACKET_BROADCAST | PACKET_HOST | PACKET_OTHERHOST,
 		.sll_halen = sizeof(struct in_addr),
@@ -1432,95 +1485,48 @@ static struct rdma_channel *create_packe
 
 	if (i == i2r + INFINIBAND) {
 		logg(LOG_ERR, "Packet Sockets do not work right on Infiniband");
-		return NULL;
+		return false;
 	}
 
 	fh = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
 
 	if (fh < 0) {
 		logg(LOG_ERR, "Raw Socker creation failed for %s:%s\n", i->text, errname());
-		return NULL;
+		return false;
 	}
 
 	if (bind(fh, (struct sockaddr *)&ll, sizeof(struct sockaddr_ll))) {
 		logg(LOG_ERR, "Cannot bind raw socket for %s:%s\n", i->text, errname());
-		return NULL;
+		return false;
 	}
 
-	c = new_rdma_channel(i, receive_raw, channel_packet, "packet");
 	c->fh = fh;
 	register_callback(handle_receive_packet, fh, c);
-	return c;
+	return true;
 }
 
-static struct rdma_channel *create_raw_channel(struct i2r_interface *i)
+static bool setup_raw(struct rdma_channel *c)
 {
-	struct rdma_channel *c = NULL;
-
-	if (!packet_socket) {
-		c = new_rdma_channel(i, receive_raw, channel_raw, "raw");
-
-		init_channel(c, 0x12345, i->port, 100, i == i2r + ROCE  ? IBV_QPT_RAW_PACKET : IBV_QPT_UD);
+	if (!setup_channel(c))
+		return false;
 
-		if (!c->qp) {
-			free(c);
-			return NULL;
-		}
 #ifdef HAVE_MSTFLINT
+	if (i == i2r + INFINIBAND) {
+		if (set_ib_sniffer(ibv_get_device_name(i->context->device), i->port, c->qp)) {
 
-		if (c && i == i2r + INFINIBAND) {
-			if (set_ib_sniffer(ibv_get_device_name(i->context->device), i->port, c->qp)) {
+			logg(LOG_ERR, "Failure to set sniffer mode on %s\n", c->text);
+			ibv_destroy_qp(c->qp);
+			ibv_destroy_cq(c->cq);
+			return false;
 
-				logg(LOG_ERR, "Failure to set sniffer mode on %s\n", c->text);
-				ibv_destroy_qp(c->qp);
-				ibv_destroy_cq(c->cq);
-				free(c);
-				c = NULL;
-
-			} else 
-
-			/* Install abort handler so that we can be sure that the capture mode is switched off */
-			signal(SIGABRT, &shutdown_sniffer);
-			signal(SIGSEGV, &shutdown_sniffer);
-		}
+		} else 
+
+		/* Install abort handler so that we can be sure that the capture mode is switched off */
+		signal(SIGABRT, &shutdown_sniffer);
+		signal(SIGSEGV, &shutdown_sniffer);
 	}
 #endif
-		if (c) {
-			/* There is no sending on raw sockets so use most of them for receive */
-			c->max_receive_buffers = c->nr_cq - 2;
-		} else
-			logg(LOG_WARNING, "Falling back to raw socket on %s to monitor traffic\n", i->text);
-	}
-
-	if (!c)
-		c = create_packet_socket(i, i->ifindex);
-
-	return c;
-}
-
-static struct rdma_channel *create_ud_channel(struct i2r_interface *i)
-{
-	struct rdma_channel *c;
-
-	c = new_rdma_channel(i, receive_ud, channel_ud, "ud");
-	init_channel(c, RDMA_UDP_QKEY, i->port, nr_buffers / 100, IBV_QPT_UD);
-	if (c->qp)
-		return c;
-	free(c);
-	return NULL;
-}
-
-static struct rdma_channel *create_qp1_channel(struct i2r_interface *i)
-{
-	struct rdma_channel *c;
-
-	c = new_rdma_channel(i, receive_qp1, channel_qp1, "qp1");
-	init_channel(c, IB_DEFAULT_QP1_QKEY, i->port, 10,  IBV_QPT_UD);
-	c->max_receive_buffers = 9;
-	if (c->qp)
-		return c;
-	free(c);
-	return NULL;
+	return true;
 }
 
 static void setup_interface(enum interfaces in)
@@ -1528,7 +1534,6 @@ static void setup_interface(enum interfa
 	struct i2r_interface *i = i2r + in;
 	struct ibv_gid_entry *e;
 	char buf[INET6_ADDRSTRLEN];
-	struct sockaddr_in *sin;
 
 	if (in == INFINIBAND)
 		i->maclen = 20;
@@ -1577,6 +1582,15 @@ static void setup_interface(enum interfa
 	/* Get more info about the IP network attached to the RDMA device */
 	get_if_info(i);
 
+	/* Hashes for this interface. Should be allocate in the context of the thread using them */
+	i->ru_hash = hash_create(offsetof(struct rdma_unicast, sin), sizeof(struct sockaddr_in));
+	i->ip_to_ep = hash_create(offsetof(struct endpoint, addr), sizeof(struct in_addr));
+	if (i == i2r + INFINIBAND)
+		i->ep = hash_create(offsetof(struct endpoint, lid), sizeof(uint16_t));
+	else
+		i->ep = i->ip_to_ep;;
+
+
 	/* Create RDMA interface setup */
 	i->rdma_events = rdma_create_event_channel();
 	if (!i->rdma_events) {
@@ -1585,19 +1599,8 @@ static void setup_interface(enum interfa
 		abort();
 	}
 
-	sin = calloc(1, sizeof(struct sockaddr_in));
-	sin->sin_family = AF_INET;
-	sin->sin_addr = i->if_addr.sin_addr;
-	sin->sin_port = htons(default_port);
 
-	i->multicast = create_rdma_id(i, (struct sockaddr *)sin);
-	i->ru_hash = hash_create(offsetof(struct rdma_unicast, sin), sizeof(struct sockaddr_in));
-
-	if (!i->multicast)
-		abort();
-
-	if (allocate_rdmacm_qp(i->multicast, nr_buffers / 10, true))
-		abort();
+	i->multicast = new_rdma_channel(i, channel_rdmacm);
 
 	i->pd = ibv_alloc_pd(i->context);
 	if (!i->pd) {
@@ -1620,15 +1623,18 @@ static void setup_interface(enum interfa
 
 	if (unicast) {
 
-		i->ud = create_ud_channel(i);
-		i->qp1 = create_qp1_channel(i);
-		i->raw = create_raw_channel(i);
-
-		i->ip_to_ep = hash_create(offsetof(struct endpoint, addr), sizeof(struct in_addr));
-		if (i == i2r + INFINIBAND)
-			i->ep = hash_create(offsetof(struct endpoint, lid), sizeof(uint16_t));
-		else
-			i->ep = i->ip_to_ep;;
+		i->ud = new_rdma_channel(i, channel_ud);
+		i->qp1 = new_rdma_channel(i, channel_qp1);
+
+		if (i == i2r + INFINIBAND) {
+			i->raw = new_rdma_channel(i, channel_ibraw);
+			/* Sadly fallback is not working here */
+		} else {
+			if (packet_socket)
+				i->raw = new_rdma_channel(i, channel_packet);
+			else
+				i->raw = new_rdma_channel(i, channel_raw);
+		}
 	}
 
 	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u/%u/%u MTU=%u.\n",
@@ -1770,7 +1776,7 @@ static void resolve_start(struct rdma_un
 		sin->sin_family = AF_INET;
 		sin->sin_addr = i->if_addr.sin_addr;
 		sin->sin_port = 0;
-		ru->c = create_rdma_id(i, (struct sockaddr *)sin);
+		ru->c = new_rdma_channel(i, channel_incoming);
 		ru->c->ru = ru;
 	}
 
@@ -1891,7 +1897,7 @@ static void handle_rdma_event(void *priv
 				logg(LOG_NOTICE, "RDMA_CM_EVENT_ROUTE_RESOLVED for %s:%d\n",
 					inet_ntoa(ru->sin.sin_addr), ntohs(ru->sin.sin_port));
 
-				allocate_rdmacm_qp(ru->c, 100, false);
+				allocate_rdmacm_qp(ru->c, false);
 
 				post_receive(ru->c);
 				ibv_req_notify_cq(ru->c->cq, 0);
@@ -1920,14 +1926,14 @@ static void handle_rdma_event(void *priv
 		case RDMA_CM_EVENT_CONNECT_REQUEST:
 			{
 				struct rdma_conn_param rcp = { };
-				struct rdma_channel *c = new_rdma_channel(i, receive_main, channel_rdmacm, "incoming-ud_qp");
+				struct rdma_channel *c = new_rdma_channel(i, channel_rdmacm);
 
 				logg(LOG_NOTICE, "RDMA_CM_CONNECT_REQUEST id=%p listen_id=%p\n",
 					event->id, event->listen_id);
 
 				c->id->context = c;
 
-				if (allocate_rdmacm_qp(c, 100, false))
+				if (allocate_rdmacm_qp(c, false))
 					goto err;
 
 				post_receive(c);
@@ -4091,7 +4097,7 @@ static void logging(void)
 			i->multicast->stats[packets_sent],
 			i->ud ? i->ud->stats[packets_received] : 0,
 			i->ud ?	i->ud->stats[packets_sent] : 0,
-			i->raw ? (i->raw->type == channel_raw ? "RAW" : "PACKET") : "-",
+			i->raw ? channel_infos[i->raw->type].suffix : "--",
 			i->raw ? i->raw->stats[packets_received]: 0);
 	}
 
@@ -4171,7 +4177,7 @@ static void arm_channels(void)
 			ibv_req_notify_cq(i->multicast->cq, 0);
 		}
 
-		if (i->raw && i->raw->type == channel_raw) {
+		if (i->raw && (i->raw->type == channel_raw || i->raw->type == channel_ibraw)) {
 			start_channel(i->raw);
 			ibv_req_notify_cq(i->raw->cq, 0);
 
