Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -159,6 +159,7 @@ struct mgid_signature *mgid_mode = mgid_
 static char *ib_name, *roce_name;
 
 enum interfaces { INFINIBAND, ROCE, NR_INTERFACES };
+enum interface_types { if_off, if_rdma, if_socket, nr_interface_types };
 
 static const char *interfaces_text[NR_INTERFACES] = { "Infiniband", "ROCE" };
 
@@ -176,7 +177,8 @@ static const char *stats_text[nr_stats]
 
 static int cq_high = 0;	/* Largest batch of CQs encountered */
 
-enum channel_type { channel_rdmacm, channel_ud, channel_raw, channel_packet, nr_channel_types };
+enum channel_type { channel_rdmacm, channel_ud, channel_raw,
+       			channel_packet, channel_socket, nr_channel_types };
 
 struct buf;
 
@@ -246,6 +248,8 @@ static struct i2r_interface {
 	unsigned port;
 	unsigned mtu;
 	unsigned maclen;
+	enum interface_types if_type;
+	int fh;				/* FH for multicast socket for if_socket */
 	const char *text;
 	char if_name[IFNAMSIZ];
 	uint8_t if_mac[ETH_ALEN];
@@ -309,6 +313,72 @@ static inline struct rdma_cm_id *id(enum
 	return i2r[i].multicast->id;
 }
 
+/* Retrieve Kernel Stack info about the interface */
+static void get_if_info(struct i2r_interface *i)
+{
+	int fh = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
+	struct ifreq ifr;
+	const char *reason = "socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)";
+
+	if (fh < 0)
+		goto err;
+
+	/*
+	 * Work around the quirk of ifindex always being zero for
+	 * INFINIBAND interfaces. Just assume its ib0.
+	 */
+	if (!i->ifindex && i - i2r == INFINIBAND) {
+
+		if (i->if_name[0] == 0) {
+			logg(LOG_WARNING, "Assuming ib0 is the IP device name for %s\n",
+			     ibv_get_device_name(i->context->device));
+			strcpy(i->if_name, "ib0");
+		}
+
+		memcpy(ifr.ifr_name, i->if_name, IFNAMSIZ);
+
+		/* Find if_index */
+		reason = "ioctl SIOCGIFINDEX";
+		if (ioctl(fh, SIOCGIFINDEX, &ifr) < 0)
+			goto err;
+
+		i->ifindex = ifr.ifr_ifindex;
+
+	} else {
+
+		ifr.ifr_ifindex = i->ifindex;
+
+		reason= "ioctl SIOGCIFNAME";
+		if (ioctl(fh, SIOCGIFNAME, &ifr) < 0)
+			goto err;
+
+		memcpy(i->if_name, ifr.ifr_name, IFNAMSIZ);
+	}
+
+	reason="ioctl SIOCGIFADDR";
+	if (ioctl(fh, SIOCGIFADDR, &ifr) < 0)
+		goto err;
+
+	memcpy(&i->if_addr, &ifr.ifr_addr, sizeof(struct sockaddr_in));
+
+	ioctl(fh, SIOCGIFNETMASK, &ifr);
+	memcpy(&i->if_netmask, &ifr.ifr_netmask, sizeof(struct sockaddr_in));
+	ioctl(fh, SIOCGIFHWADDR, &ifr);
+	memcpy(&i->if_mac, &ifr.ifr_hwaddr.sa_data, ETH_ALEN);
+	ioctl(fh, SIOCGIFMTU, &ifr);
+	i->mtu = ifr.ifr_mtu;
+	goto out;
+
+err:
+	logg(LOG_CRIT, "Cannot determine IP interface setup for %s %s : %s\n",
+		     ibv_get_device_name(i->context->device), reason, errname());
+
+	abort();
+
+out:
+	close(fh);
+}
+
 /* Check the RDMA device if it fits what was specified on the command line and store it if it matches */
 static int check_rdma_device(enum interfaces i, int port, char *name,
 	       struct ibv_context *c, struct ibv_port_attr *a, struct ibv_device_attr *d)
@@ -316,7 +386,7 @@ static int check_rdma_device(enum interf
 	char *s;
 	int p = 1;
 
-	if (i2r[i].context)
+	if (i2r[i].if_type)
 		/* Already found a match */
 		return 0;
 
@@ -347,6 +417,7 @@ success:
 		/* Other MTUs are not supported */
 		return 0;
 
+	i2r[i].if_type = if_rdma;
 	i2r[i].context = c;
 	i2r[i].port = port;
 	i2r[i].port_attr = *a;
@@ -420,7 +491,7 @@ static int find_rdma_devices(void)
 	ibv_free_device_list(list);
 
 
-	if (!i2r[ROCE].context) {
+	if (!i2r[ROCE].if_type) {
 
 		if (roce_name && roce_name[0] == '-')
 			/* Disabled on the command line */
@@ -435,15 +506,16 @@ static int find_rdma_devices(void)
 		}
 	}
 
-	if (!i2r[INFINIBAND].context) {
+	if (!i2r[INFINIBAND].if_type) {
 
-		if (ib_name && isdigit(ib_name[0])) {
-			struct i2r_interface *i = i2r + INFINIBAND;
+		if (ib_name) {
+			struct i2r_interface *si = i2r + INFINIBAND;
 
-			i2r[i].context = NULL;
-			strncpy(i2r[i].if_name, ib_name, IFNAMSIZ);
-			get_if_info(i);
-			i2r[i].port = i->ifindex;
+			si->if_type = if_socket;
+			strncpy(si->if_name, ib_name, IFNAMSIZ);
+			get_if_info(si);
+			si->port = si->ifindex;
+			
 			logg(LOG_NOTICE, "Using Socket API instead of Infiniband\n");
 			return 0;
 		}
@@ -1113,72 +1185,6 @@ static void qp_destroy(struct i2r_interf
 	i->ud = NULL;
 }
 
-/* Retrieve Kernel Stack info about the interface */
-static void get_if_info(struct i2r_interface *i)
-{
-	int fh = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
-	struct ifreq ifr;
-	const char *reason = "socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)";
-
-	if (fh < 0)
-		goto err;
-
-	/*
-	 * Work around the quirk of ifindex always being zero for
-	 * INFINIBAND interfaces. Just assume its ib0.
-	 */
-	if (!i->ifindex && i - i2r == INFINIBAND) {
-
-		if (i->if_name[0] == 0) {
-			logg(LOG_WARNING, "Assuming ib0 is the IP device name for %s\n",
-			     ibv_get_device_name(i->context->device));
-			strcpy(i->if_name, "ib0");
-		}
-
-		memcpy(ifr.ifr_name, i->if_name, IFNAMSIZ);
-
-		/* Find if_index */
-		reason = "ioctl SIOCGIFINDEX";
-		if (ioctl(fh, SIOCGIFINDEX, &ifr) < 0)
-			goto err;
-
-		i->ifindex = ifr.ifr_ifindex;
-
-	} else {
-
-		ifr.ifr_ifindex = i->ifindex;
-
-		reason= "ioctl SIOGCIFNAME";
-		if (ioctl(fh, SIOCGIFNAME, &ifr) < 0)
-			goto err;
-
-		memcpy(i->if_name, ifr.ifr_name, IFNAMSIZ);
-	}
-
-	reason="ioctl SIOCGIFADDR";
-	if (ioctl(fh, SIOCGIFADDR, &ifr) < 0)
-		goto err;
-
-	memcpy(&i->if_addr, &ifr.ifr_addr, sizeof(struct sockaddr_in));
-
-	ioctl(fh, SIOCGIFNETMASK, &ifr);
-	memcpy(&i->if_netmask, &ifr.ifr_netmask, sizeof(struct sockaddr_in));
-	ioctl(fh, SIOCGIFHWADDR, &ifr);
-	memcpy(&i->if_mac, &ifr.ifr_hwaddr.sa_data, ETH_ALEN);
-	ioctl(fh, SIOCGIFMTU, &ifr);
-	i->mtu = i->ifr_mtu;
-	goto out;
-
-err:
-	logg(LOG_CRIT, "Cannot determine IP interface setup for %s %s : %s\n",
-		     ibv_get_device_name(i->context->device), reason, errname());
-
-	abort();
-
-out:
-	close(fh);
-}
-
 static void start_channel(struct rdma_channel *c)
 {
 	if (c->type == channel_rdmacm) {
@@ -1450,6 +1456,36 @@ static struct rdma_channel *create_packe
 	return c;
 }
 
+static struct rdma_channel *create_multicast_socket(struct i2r_interface *i,struct sockaddr_in *sin)
+{
+	struct rdma_channel *c;
+	int fh;
+	int flag0 = false;
+
+	fh = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+
+	if (fh < 0) {
+		logg(LOG_ERR, "Multicast Socket creation failed for %s:%s\n", i->text, errname());
+		return NULL;
+	}
+
+	if (bind(fh, (struct sockaddr *)sin, sizeof(struct sockaddr_in))) {
+		logg(LOG_ERR, "Cannot bind multicast socket for %s:%s\n", i->text, errname());
+		return NULL;
+	}
+
+	setsockopt(fh, SOL_IP, IP_MULTICAST_ALL, &flag0, sizeof(flag0));
+	setsockopt(fh, SOL_IP, IP_MULTICAST_LOOP, &flag0, sizeof(flag0));
+
+	c = new_rdma_channel(i, receive_multicast, channel_packet);
+	c->i = i;
+	c->text = make_ifname(i, "-mcsocket");
+	c->type = channel_socket;
+	c->fh = fh;
+	register_callback(handle_receive_packet, fh, c);
+	return c;
+}
+
 static struct rdma_channel *create_raw_channel(struct i2r_interface *i, int port, unsigned nr_cq)
 {
 	struct rdma_channel *c = NULL;
@@ -1470,17 +1506,16 @@ static struct rdma_channel *create_raw_c
 static void setup_interface(enum interfaces in)
 {
 	struct i2r_interface *i = i2r + in;
-	struct ibv_gid_entry *e;
+	struct ibv_gid_entry *e = NULL;
 	char buf[INET6_ADDRSTRLEN];
 	struct sockaddr_in *sin;
-	bool socket = !i->context && i->port;
 
 	i->maclen = 6;
 
-	if (in == INFINIBAND && !socket)
+	if (in == INFINIBAND && i->if_type == if_rdma)
 		i->maclen = 20;
 
-	if (!i->context && !i->port)
+	if (!i->if_type)
 		return;
 
 	sin = calloc(1, sizeof(struct sockaddr_in));
@@ -1492,10 +1527,10 @@ static void setup_interface(enum interfa
 	i->ip_to_ep = hash_create(offsetof(struct endpoint, addr), sizeof(struct in_addr));
 	
 
-	if (socket) {
+	if (i->if_type == if_socket) {
 
 		i->text = "SOCKET";
-		i->multicast = create_multicast_socket(i);
+		i->multicast = create_multicast_socket(i, sin);
 		i->raw = create_packet_socket(i, i->ifindex);
 		i->ep = i->ip_to_ep;
 
@@ -1592,10 +1627,10 @@ static void setup_interface(enum interfa
 out:
 	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u/%u/%u MTU=%u.\n",
 		i->text,
-		ibv_get_device_name(i->context->device),
+		i->if_type == if_rdma ? ibv_get_device_name(i->context->device) : "socket",
 		i->if_name, i->ifindex,
 		i->port,
-		inet_ntop(AF_INET6, e->gid.raw, buf, INET6_ADDRSTRLEN),i->gid_index,
+		e ? inet_ntop(AF_INET6, e->gid.raw, buf, INET6_ADDRSTRLEN) : "N/A ", i->gid_index,
 		inet_ntoa(i->if_addr.sin_addr), default_port,
 		i->multicast ? i->multicast->nr_cq: 0,
 		i->ud ? i->ud->nr_cq : 0,
@@ -1606,7 +1641,7 @@ out:
 
 static void shutdown_ib(void)
 {
-	if (!i2r[INFINIBAND].context)
+	if (i2r[INFINIBAND].if_type)
 		return;
 
 	leave_mc(INFINIBAND);
@@ -1617,7 +1652,7 @@ static void shutdown_ib(void)
 
 static void shutdown_roce(void)
 {
-	if (!i2r[ROCE].context)
+	if (!i2r[ROCE].if_type)
 		return;
 
 	leave_mc(ROCE);
@@ -1632,24 +1667,51 @@ static void shutdown_roce(void)
  */
 static void join_processing(void)
 {
-	int i;
+	int mc;
 	enum interfaces in;
 	int mcs_per_call = 0;
 
-	for (i = 0; i < nr_mc; i++) {
-		struct mc *m = mcs + i;
+	for (mc = 0; mc < nr_mc; mc++) {
+		struct mc *m = mcs + mc;
 		unsigned port = ntohs(((struct sockaddr_in *)(m->sa[ROCE]))->sin_port);
 
 		if (m->status[ROCE] == MC_JOINED && m->status[INFINIBAND] == MC_JOINED)
 			continue;
 
-		for(in = 0; in < 2; in++)
-			if (i2r[in].context) {
-				switch(m->status[in]) {
+		for(in = 0; in < 2; in++) {
+			struct i2r_interface *i = i2r + in;
+			enum interface_types type = i->if_type;
+
+			if (!type)
+				continue;
+
+			switch(m->status[in]) {
 
 				case MC_OFF:
-					if (_join_mc(m->addr, m->sa[in], port, in, m->sendonly[in], m) == 0)
-						m->status[in] = MC_JOINING;
+
+					if (type == if_rdma) {
+
+						if (_join_mc(m->addr, m->sa[in], port, in, m->sendonly[in], m) == 0)
+							m->status[in] = MC_JOINING;
+
+					} else { /* if_socket */
+						struct ip_mreqn mr = {
+							.imr_multiaddr =	m->addr,
+							.imr_address =  i->if_addr.sin_addr,
+							.imr_ifindex = i->ifindex
+						};
+
+
+						if (!m->sendonly[in] && setsockopt(i->multicast->fh, SOL_IP, IP_ADD_MEMBERSHIP, &mr, sizeof(mr)) < 0) {
+							logg(LOG_WARNING, "Failed to join %s on %s:%s\n",
+								inet_ntoa(m->addr), i->text, errname());
+							break;
+						}
+
+						m->status[in] = MC_JOINED;
+						logg(LOG_NOTICE, "Joined %s on %s\n",
+								inet_ntoa(m->addr), i->text);
+					}
 					break;
 
 				case MC_ERROR:
@@ -2208,7 +2270,7 @@ static void list_endpoints(struct i2r_in
 	unsigned offset = 0;
 	unsigned nr;
 
-	if (!i->context || !i->ep)
+	if (!i->if_type || !i->ud)
 		return;
 
 	while ((nr = hash_get_objects(i->ep, offset, 10, (void **)e))) {
@@ -3410,6 +3472,7 @@ static void handle_receive_packet(void *
 
 	if (len < 0) {
 		logg(LOG_ERR, "recv error on %s:%s\n", c->text, errname());
+		free(buf);
 		return;
 	}
 
@@ -3538,7 +3601,8 @@ static void status_write(void)
 	}
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-		if (i->context && i->ep) {
+	   if (i->if_type) {
+
 		struct endpoint *e[20];
 		char xbuf[30];
 		unsigned nr;
@@ -3638,7 +3702,7 @@ static struct i2r_interface *find_interf
 	struct i2r_interface *i;
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-	    if (i->context) {
+	    if (i->if_type) {
 		unsigned netmask = i->if_netmask.sin_addr.s_addr;
 
 		if ((sin->sin_addr.s_addr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask))
@@ -3701,7 +3765,7 @@ static void beacon_send(void)
 		for(in = 0; in < NR_INTERFACES; in++) {
 			struct i2r_interface *i = i2r + in;
 
-			if (i->context && beacon_mc->status[in] == MC_JOINED) {
+			if (i->if_type && beacon_mc->status[in] == MC_JOINED) {
 				if (sizeof(b) > MAX_INLINE_DATA) {
 					buf = alloc_buffer(i->multicast);
 					memcpy(buf->raw, &b, sizeof(b));
@@ -3809,7 +3873,7 @@ static void check_joins(void)
 		 * are able to subscribe to Multicast groups
 		 */
 		for(i = i2r; i < i2r + NR_INTERFACES; i++)
-		   if (i->context)	{
+		   if (i->if_type == if_rdma) {
 			struct rdma_channel *c = i->multicast;
 
 			if (rdma_listen(c->id, 50))
@@ -3848,7 +3912,7 @@ static void logging(void)
 
 	n = 0;
 	for(struct i2r_interface *i = i2r; i < i2r + NR_INTERFACES;i++)
-      	   if (i->context)	{
+      	   if (i->if_type) {
 		n+= sprintf(counts + n, "%s(MC %d/%d, UD %d/%d, %s %d) ",
 			i->text,
 			i->multicast->stats[packets_received],
@@ -3896,7 +3960,7 @@ static void register_poll_events(void)
 	struct i2r_interface *i;
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++) {
-		if (i->context) {
+		if (i->if_type == if_rdma) {
 
 			register_callback(handle_rdma_event, i->rdma_events->fd, i);
 			register_callback(handle_comp_event, i->multicast->comp_events->fd, i->multicast->comp_events);
@@ -3904,10 +3968,8 @@ static void register_poll_events(void)
 		}
 
 		if (i->raw || i->ud) {	/* They share the interface comp_events notifier */
-			if (i->context)
+			if (i->if_type == if_rdma)
 				register_callback(handle_comp_event, i->comp_events->fd, i->comp_events);
-			else /* Socket */
-				register_callback(handle_multicast_event, i->fh, NULL);
 		}
 
 	}
@@ -3932,7 +3994,7 @@ static void arm_channels(void)
 	struct i2r_interface *i;
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-	   if (i->context) {
+	   if (i->if_type == if_rdma) {
 		/* Receive Buffers */
 		post_receive_buffers(i);
 		/* And request notifications if something happens */
@@ -4353,9 +4415,10 @@ int main(int argc, char **argv)
 	if (ret && !testing)
 		return ret;
 
-	syslog (LOG_NOTICE, "Infiniband device = %s:%d, ROCE device = %s:%d. Multicast Groups=%d MGIDs=%s Buffers=%u\n",
-			i2r[INFINIBAND].context ? ibv_get_device_name(i2r[INFINIBAND].context->device) :
-		       		(i2r[INFINIBAND].port ? i2r->if_name : "<disabled>"),
+	syslog (LOG_NOTICE, "%s device = %s:%d, ROCE device = %s:%d. Multicast Groups=%d MGIDs=%s Buffers=%u\n",
+			i2r[INFINIBAND].if_type == if_socket ? "Socket" : "Infiniband", 
+			i2r[INFINIBAND].if_type == if_rdma ? ibv_get_device_name(i2r[INFINIBAND].context->device) :
+		       		(i2r[INFINIBAND].if_type == if_socket ? i2r->if_name : "<disabled>"),
 			i2r[INFINIBAND].port,
 			i2r[ROCE].context ? ibv_get_device_name(i2r[ROCE].context->device) : "<disabled>",
 			i2r[ROCE].port,
