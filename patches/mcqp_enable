Index: rdma-core/ib2roce/channel.c
===================================================================
--- rdma-core.orig/ib2roce/channel.c
+++ rdma-core/ib2roce/channel.c
@@ -129,7 +129,7 @@ struct rdma_channel *new_rdma_channel(st
 	char *p;
 	short core;
 	int channel_nr;
-	unsigned rdma_channel_size = sizeof(struct rdma_channel) + i->device_attr.max_mcast_qp_attach * sizeof(struct mc *);
+	unsigned rdma_channel_size = sizeof(struct rdma_channel) + i->mc_per_qp * sizeof(struct mc *);
 
 retry:
 	ci = channel_infos + type;
@@ -715,7 +715,7 @@ int channel_stats(char *b, struct rdma_c
 	int n = 0;
 	int j;
 
-	n += sprintf(b + n, "\nChannel %s(%s):\n", interface, type);
+	n += sprintf(b + n, "\nChannel %s:\n", type);
 
 	for(j =0; j < nr_stats; j++)
 		if (c->stats[j]) {
Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- rdma-core.orig/ib2roce/interfaces.c
+++ rdma-core/ib2roce/interfaces.c
@@ -80,9 +80,10 @@ int max_iburst = 10;		/* Dont delay unti
 
 bool bridging = true;		/* Allow briding */
 bool unicast = false;		/* Bridge unicast packets */
-static bool raw = false;		/* Use raw channels */
+static bool raw = false;	/* Use raw channels */
 static bool packet_socket = false;	/* Do not use RAW QPs, use packet socket instead */
 
+static int mc_per_qp = 0;	/* 0 = Unlimited */
 
 struct i2r_interface i2r[NR_INTERFACES];
 
@@ -512,11 +513,19 @@ void setup_interface(enum interfaces in)
 	if (!i->mr)
 		panic("ibv_reg_mr failed for %s:%s.\n", i->text, errname());
 
+	i->mc_per_qp = i->device_attr.max_mcast_qp_attach;
+	if (mc_per_qp && mc_per_qp < i->mc_per_qp)
+		i->mc_per_qp = mc_per_qp;
+
 	/* Calculate number of required RDMA channels for multicast */
-	channels = 1 + nr_mc / i->device_attr.max_mcast_qp_attach;
+	channels = 1 + nr_mc / i->mc_per_qp;
+
+	if (channels > 1)
+		logg(LOG_INFO, "Multi RDMA group mode %s: %u multicast groups on %d channels. Maximum %d multicast groups per qp\n", i->text, nr_mc, channels, i->mc_per_qp);
+
 
-	if (channels > 0)
-		logg(LOG_INFO, "Multi RDMA group mode: %u multicast rdma channels to support %u multicast groups\n", channels, nr_mc);
+	if (channels > MAX_CHANNELS_PER_INTERFACE)
+		panic("Too many channels for interface %s. Maximum supported = %u\n", i->text, MAX_CHANNELS_PER_INTERFACE);
 
 	for (int j = 0; j < channels; j++) {
 		char buf[5];
@@ -834,20 +843,97 @@ void handle_async_event(void *private)
 	struct i2r_interface *i = private;
 	struct ibv_async_event event;
 
-	if (!ibv_get_async_event(i->context, &event))
-		logg(LOG_ALERT, "Async event retrieval failed on %s.\n", i->text);
-	else
-		logg(LOG_ALERT, "Async RDMA EVENT %d on %s\n", event.event_type, i->text);
-
-	/*
-	 * Regardless of what the cause is the first approach here
-	 * is to simply terminate the program.
-	 * We can make exceptions later.
-	 */
-
-	terminate(0);
-
-        ibv_ack_async_event(&event);
+	while (!ibv_get_async_event(i->context, &event)) {
+		switch (event.event_type) {
+			case IBV_EVENT_QP_FATAL:
+				logg(LOG_INFO, "Async RDMA EVENT: QP transitioned to error state on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_QP_REQ_ERR:
+				logg(LOG_INFO, "Async RDMA EVENT: QP Invalid Request on Work Queue on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_QP_ACCESS_ERR:
+				logg(LOG_INFO, "Async RDMA EVENT: QP Local Access Violation on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_COMM_EST:
+				logg(LOG_INFO, "Async RDMA EVENT: QP Communication Established on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_SQ_DRAINED:
+				logg(LOG_INFO, "Async RDMA EVENT: Send Queue Drained on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_PATH_MIG:
+				logg(LOG_INFO, "Async RDMA EVENT: Path Migration on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_PATH_MIG_ERR:
+				logg(LOG_INFO, "Async RDMA EVENT: Path Migration failed on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_QP_LAST_WQE_REACHED:
+				logg(LOG_INFO, "Async RDMA EVENT: SRQ Last WQE reched on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_CQ_ERR:
+				logg(LOG_INFO, "Async RDMA EVENT: CQ in Error state on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_SRQ_ERR:
+				logg(LOG_INFO, "Async RDMA EVENT: SRQ in error state on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_SRQ_LIMIT_REACHED:
+				logg(LOG_INFO, "Async RDMA EVENT: SRQ limit reached on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_PORT_ACTIVE:
+				logg(LOG_INFO, "Async RDMA EVENT: Link entered active state on %s\n", i->text);
+				break;
+
+			case IBV_EVENT_PORT_ERR:
+				logg(LOG_CRIT, "Async RDMA EVENT: Link entered error state on %s\n", i->text);\
+				terminate(0);
+				break;
+
+			case IBV_EVENT_LID_CHANGE:
+				logg(LOG_CRIT, "Async RDMA EVENT: LID Change on %s\n", i->text);
+				terminate(0);
+				break;
+
+			case IBV_EVENT_PKEY_CHANGE:
+				logg(LOG_CRIT, "Async RDMA EVENT: PKey change on %s\n", i->text);
+				terminate(0);
+				break;
+
+			case IBV_EVENT_SM_CHANGE:
+				logg(LOG_CRIT, "Async RDMA EVENT: SM change on %s\n", i->text);
+				terminate(0);
+				break;
+
+			case IBV_EVENT_CLIENT_REREGISTER:
+				logg(LOG_CRIT, "Async RDMA EVENT: Client REREG on %s\n", i->text);
+				terminate(0);
+				break;
+
+			case IBV_EVENT_GID_CHANGE:
+				logg(LOG_CRIT, "Async RDMA EVENT: GID Change on %s\n", i->text);
+				terminate(0);
+				break;
+
+			case IBV_EVENT_DEVICE_FATAL:
+				logg(LOG_CRIT, "Async RDMA EVENT: NIC in fatal state on %s\n", i->text);
+				terminate(0);
+				break;
+
+			default:
+				logg(LOG_INFO, "Unknown Async RDMA EVENT %d on %s\n", event.event_type, i->text);
+				break;
+		}
+		ibv_ack_async_event(&event);
+	}
 }
 
 /*
@@ -1115,7 +1201,7 @@ unsigned show_interfaces(char *b)
 
 	interface_foreach(i)
 		channel_foreach(c, &i->channels)
-			n += channel_stats(b + n, c, i->text, c->type == channel_rdmacm ? "Multicast" : c->text);
+			n += channel_stats(b + n, c, i->text, c->text);
 
 	return n;
 }
@@ -1259,5 +1345,6 @@ static void interfaces_init(void)
 		"Use of RAW sockets to capture SIDR Requests. Avoids having to use a patched kernel");
 	register_enable("unicast", false, &unicast, NULL, "on", "off",	NULL,
 		"Processing of unicast packets with QP1 handling of SIDR REQ/REP");
+	register_enable("mcqp", true, NULL, &mc_per_qp, "0", "10", NULL, "Max # of MCs per QP");
 }
 
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- rdma-core.orig/ib2roce/interfaces.h
+++ rdma-core/ib2roce/interfaces.h
@@ -102,6 +102,7 @@ struct i2r_interface {
 	struct sockaddr_in if_addr;
 	struct sockaddr_in if_netmask;
 	unsigned ifindex;
+	unsigned mc_per_qp;			/* How many MCs per QP */
 	unsigned numa_node;			/* NUMA Affinity of the interface */
 	unsigned gid_index;
 	union ibv_gid gid;
Index: rdma-core/ib2roce/multicast.c
===================================================================
--- rdma-core.orig/ib2roce/multicast.c
+++ rdma-core/ib2roce/multicast.c
@@ -367,7 +367,6 @@ static int _join_mc(struct in_addr addr,
 {
 	int ret;
 	int i;
-	unsigned max_mc_per_qp = c->i->device_attr.max_mcast_qp_attach;
 	struct rdma_cm_join_mc_attr_ex mc_attr = {
 		.comp_mask = RDMA_CM_JOIN_MC_ATTR_ADDRESS | RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS,
 		.join_flags = sendonly ? RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER
@@ -376,12 +375,12 @@ static int _join_mc(struct in_addr addr,
 	};
 
 	/* Find first free slot */
-	for(i = 0; i < max_mc_per_qp; i++)
+	for(i = 0; i < c->i->mc_per_qp; i++)
 		if (!c->mc[i])
 			break;
 
-	if (i == max_mc_per_qp) {
-		logg(LOG_CRIT, "Can only join %u multicast groups on rdma_channel %s\n", max_mc_per_qp, c->text);
+	if (i == c->i->mc_per_qp) {
+		logg(LOG_CRIT, "Can only join %u multicast groups on rdma_channel %s\n", c->i->mc_per_qp, c->text);
 		return 1;
 	}
 
@@ -409,14 +408,13 @@ static int _leave_mc(struct in_addr addr
 {
 	int ret;
 	int i;
-	unsigned max_mc_per_qp = c->i->device_attr.max_mcast_qp_attach;
 
-	for(i = 0; i < max_mc_per_qp; i++) {
+	for(i = 0; i < c->i->mc_per_qp; i++) {
 		if (c->mc[i] == m) {
 			break;
 		}
 	}
-	if (i == max_mc_per_qp)
+	if (i == c->i->mc_per_qp)
 		panic("Multicast structure not found in _leave_mc");
 
 	ret = rdma_leave_multicast(c->id, si);
@@ -500,7 +498,7 @@ static void send_joins(void)
 					case MC_OFF:
 						/* Find rdma channel with available multicast slots  */
 						channel_foreach(c, gjs.channels[in]) {
-							if (c->type == channel_rdmacm && c->nr_mcs < c->i->device_attr.max_mcast_qp_attach) {
+							if (c->type == channel_rdmacm && c->nr_mcs < c->i->mc_per_qp) {
 								if (_join_mc(m->addr, mi->sa, port, tos, c, mi->sendonly, m) == 0) {
 									mi->status = MC_JOINING;
 									mi->channel = c;
