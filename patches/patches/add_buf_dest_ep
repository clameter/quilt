Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -771,6 +771,7 @@ struct buf {
 			struct rdma_channel *c;	/* Which Channels does this buffer belong to */
 			struct ibv_wc *w;	/* Work Completion struct */
 			struct endpoint *source_ep;
+			struct endpoint *dest_ep;
 
 			bool ether_valid;	/* Ethernet header valid */
 			bool ip_valid;		/* IP header valid */
@@ -2591,15 +2592,24 @@ static struct endpoint *buf_to_ep(struct
  * for multicast connections will connect later and then we already have the
  * addresses cached
  */
-static void learn_source_address(struct buf *buf)
+static void learn_address(struct buf *buf)
 {
-	struct in_addr addr = ip_none;
+	struct in_addr addr;
 
 	if (!unicast)	/* If unicast is not enabled then dont bother to gather addresses */
 		return;
 
-	if (buf->ip_valid)
+	if (buf->ip_valid) {
+		addr.s_addr = buf->ip.daddr;
+
+		if (!IN_MULTICAST(ntohl(buf->ip.daddr)))
+			buf->dest_ep = ip_to_ep(i, addr);
+
 		addr.s_addr = buf->ip.saddr;
+	} else {
+		buf->dest_ep = NULL;
+		addr = ip_none;
+	}
 
 	buf->source_ep = buf_to_ep(buf, addr);
 }
@@ -2619,7 +2629,7 @@ static void receive_multicast(struct buf
 	int ret;
 	struct pgm_header pgm;
 
-	learn_source_address(buf);
+	learn_address(buf);
 
 	if (!buf->grh_valid) {
 		logg(LOG_WARNING, "No GRH on %s. Packet discarded: %s\n",
@@ -3141,6 +3151,7 @@ static void receive_raw(struct buf *buf)
 		}
 
 		buf->source_ep = buf_to_ep(buf, ip_none);
+		buf->dest_ep = NULL;
 
 		snprintf(header, sizeof(header), "SLID=%x/%s DLID=%x SL=%d LVer=%d",
 			w->slid, inet_ntoa(buf->source_ep->addr), dlid, w->sl, ib_get_lver(ih));
@@ -3244,6 +3255,8 @@ static void receive_raw(struct buf *buf)
 				goto discard;
 			}
 
+			buf->dest_ep = ip_to_ep(dest_i, dest);
+
 			if (!buf->ip_csum_ok)
 				logg(LOG_NOTICE, "TCP/UDP CSUM not valid on raw RDMA channel %s\n", c->text);
 
@@ -3360,7 +3373,7 @@ static void receive_ud(struct buf *buf)
 	struct forward *f;
 	struct ibv_wc *w = buf->w;
 
-	learn_source_address(buf);
+	learn_address(buf);
 
 	if (!buf->grh_valid)
 		/* Even if there is no GRH there is space reserved at the beginning for UD packets */
