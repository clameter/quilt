Index: rdma-core/ib2roce/pgm.c
===================================================================
--- rdma-core.orig/ib2roce/pgm.c
+++ rdma-core/ib2roce/pgm.c
@@ -98,10 +98,10 @@ struct pgm_record {
 #define MAX_PGM_OPT PGM_OPT_PGMCC_FEEDBACK
 
 /* This is only valid for IPv4 */
-static uint8_t pgm_type_sizes[MAX_PGM_TYPE] = {
+static uint8_t pgm_type_size[MAX_PGM_TYPE] = {
         sizeof(struct pgm_spm), 	/* PGM_SPM         = 0x00 */
-        sizeof(struct pgm_poll),	/* PGM_POLL        = 0x01 */
-        sizeof(struct pgm_polr),	/* PGM_POLR        = 0x02 */
+        0,				/* PGM_POLL        = 0x01 Not supported */
+        0,				/* PGM_POLR        = 0x02 Not supported*/
 	0,
         sizeof(struct pgm_data),	/* PGM_ODATA       = 0x04 */
         sizeof(struct pgm_data),	/* PGM_RDATA       = 0x05 */
@@ -111,7 +111,7 @@ static uint8_t pgm_type_sizes[MAX_PGM_TY
         sizeof(struct pgm_nak),	/* PGM_NNAK        = 0x09 */
         sizeof(struct pgm_nak),	/* PGM_NCF         = 0x0a */
 	0,
-        0,			/* PGM_SPMR        = 0x0c ??? Not defined */
+        0,			/* PGM_SPMR        = 0x0c ??? Not defined and not supported */
 	/* the next one is a bit strange since not covered by the RFC. We simply use the nak structure */
         sizeof(struct pgm_nak)	/* PGM_ACK         = 0x0d */
 };
@@ -121,31 +121,38 @@ static uint8_t pgm_type_sizes[MAX_PGM_TY
  *
  * opt is an array indexed by the option type pointing to the data associated with that option.
  *
- * The function returns a pointer at the end of options where the data would start
+ * The function returns a pointer at the end of options where the data would start. It returns
+ * NULL if the pgm_type is invalid or the options consistency check fails.
  *
  */
-static uint8_t *pgm_opt_parse(struct pgm_header *h, void **opt)
+static uint8_t *pgm_opt_parse(struct pgm_header *h, uint8_t **opt)
 {
-	uint8_t *a = (uint8_t *)h;
+	uint8_t *a;
+	uint8_t *opt_start;
 	struct pgm_opt_header *poh;
+	uint16_t *v;
+	unsigned total_opt_length;
 	unsigned n;
 
 	memset(opt, 0, sizeof(void *) * MAX_PGM_OPT);
 
 	n = h->pgm_type & PGM_TYPE_MASK;
 
-	if (n >= MAX_PGM_TYPE || !pgm_type_sizes[n])
+	if (n >= MAX_PGM_TYPE || !pgm_type_size[n])
 		/* Unsupported PGM type */
 		return NULL;
 
 	/* move to the beginning of the options */
-	a += pgm_type_sizes[n];
+	a = (uint8_t *)h + pgm_type_size[n];
 
 	if (!(h->pgm_type & PGM_OPT_PRESENT))
 		/* No options available */
 		return a;
 
+	opt_start = a;
+
 	do {
+
 		poh = (struct pgm_opt_header *)a;
 		n = poh->opt_type & PGM_OPT_MASK;
 
@@ -157,8 +164,20 @@ static uint8_t *pgm_opt_parse(struct pgm
 			opt[n] = a + sizeof(struct pgm_opt_header);
 
 		a += poh->opt_length;
+
 	} while (!(poh->opt_type & PGM_OPT_END));
 
+	v = (uint16_t *)opt[PGM_OPT_LENGTH];
+
+	if (!v)
+		/* No OPT_LENGTH specified */
+		return a;
+
+	total_opt_length = ntohs(*v);
+	if (a - opt_start != total_opt_length)
+		/* Corrupted option list */
+		return NULL;
+
 	return a;
 }
 
@@ -229,8 +248,6 @@ bool pgm_process(struct rdma_channel *c,
 	struct pgm_stream *s;
 	uint32_t sqn;
 	uint32_t tdsu;
-	uint16_t total_opt_length = 0;
-	uint8_t *options_start;
 	union {
 		struct pgm_header pgm;
 		struct {
@@ -238,40 +255,44 @@ bool pgm_process(struct rdma_channel *c,
 			struct in_addr addr;
 			uint16_t port;
 		};
-	} header;
+	} *header;
 	char text[60];
 	struct pgm_spm spm;
 	struct pgm_data data;
 	struct pgm_nak nak;
-#if 0
-	struct pgm_poll poll;
-	struct pgm_polr polr;
-#endif
 	struct pgm_ack ack;
 	int ret = true;
+	uint8_t *a;
+	uint8_t *opt[MAX_PGM_OPT];
 
-	PULL(buf, header);
+	header = (void *)buf->cur;
 
 	/* Verify if pgm message originated from our subnet */
-	if (!valid_addr(c->i, header.addr)) {
-		logg(LOG_INFO, "Discarded PGM packet originating from %s is from outside our subnet %s\n", inet_ntoa(header.addr), c->i->text);
+	if (!valid_addr(c->i, header->addr)) {
+		logg(LOG_INFO, "Discarded PGM packet originating from %s is from outside our subnet %s\n", inet_ntoa(header->addr), c->i->text);
 		return false;
 	}
 
 	if (pgm_mode < pgm_passthrough)
 		return true;
 
-	tdsu = ntohs(header.pgm.pgm_tsdu_length);
+	tdsu = ntohs(header->pgm.pgm_tsdu_length);
 
 	tsi.mcgroup = m->addr;
-	memcpy(&tsi.sender, header.pgm.pgm_gsi, sizeof(struct in_addr));
-	tsi.sport = ntohs(header.pgm.pgm_sport);
-	tsi.dport = ntohs(header.pgm.pgm_dport);
+	memcpy(&tsi.sender, header->pgm.pgm_gsi, sizeof(struct in_addr));
+	tsi.sport = ntohs(header->pgm.pgm_sport);
+	tsi.dport = ntohs(header->pgm.pgm_dport);
 	format_tsi(text, &tsi);
 
 	s = hash_find(i->pgm_tsi_hash, &tsi);
 
-	switch (header.pgm.pgm_type) {
+	a = pgm_opt_parse(&header->pgm, opt);
+	if (!a) {
+		logg(LOG_NOTICE, "%s: Invalid PGM type/Options %x. Packet Skipped.\n", text, header->pgm.pgm_type);
+		return false;
+	}
+
+	switch (header->pgm.pgm_type & PGM_TYPE_MASK) {
 		case PGM_SPM:		/* Multicast downstream */
 			PULL(buf, spm);
 			if (!s)
@@ -289,17 +310,12 @@ bool pgm_process(struct rdma_channel *c,
 			}
 			break;
 
-/* 		These may not exist although described in the RFC. There is no definition of the spmr struct available
-		case PGM_SPMR:		Unicast upstream
-			PULL(buf, spmr);
-			break;
-*/
 		case PGM_ODATA:		/* Multicast downstream */
 		case PGM_RDATA:		/* Multicast downstream */
 			PULL(buf, data);
 
 			logg(LOG_DEBUG, "%s: %cDATA SQN=%d TRAIL=%d\n", text,
-				header.pgm.pgm_type == PGM_RDATA ? 'R' : 'O', ntohl(data.data_sqn), ntohl(data.data_trail));
+				header->pgm.pgm_type == PGM_RDATA ? 'R' : 'O', ntohl(data.data_sqn), ntohl(data.data_trail));
 
 			sqn = ntohl(data.data_sqn);
 
@@ -325,7 +341,7 @@ bool pgm_process(struct rdma_channel *c,
 				unlock();
 			}
 
-			if (header.pgm.pgm_type == PGM_RDATA)
+			if (header->pgm.pgm_type == PGM_RDATA)
 				s->rdata++;
 			else
 				s->odata++;
@@ -361,7 +377,7 @@ bool pgm_process(struct rdma_channel *c,
 
 			if (pgm_mode <= pgm_passthrough) {
 
-				if (header.pgm.pgm_type == PGM_ODATA) {
+				if (header->pgm.pgm_type == PGM_ODATA) {
 					if (sqn != s->last +1)
 						logg(LOG_NOTICE, "%s: Sequence error SQN %d->SQN %d diff %d\n", s->text, s->last, sqn, sqn-s->last);
 					s->last = sqn;
@@ -425,18 +441,6 @@ bool pgm_process(struct rdma_channel *c,
 				inet_ntoa(nak.nak_grp_nla));
 			break;
 
-#if 0
-		/* Is POLL really used I do not know of a DLR */
-		case PGM_POLL:		/* DLR downstream multicast */
-			PULL(buf, poll);
-			logg(LOG_NOTICE, "%s: POLL\n", s->text);
-			break;
-
-		case PGM_POLR:		/* Unicast response upstream to DLR */
-			PULL(buf, polr);
-			logg(LOG_NOTICE, "%s: POLR\n", s->text);
-			break;
-#endif
 		/* Not RFC compliant but it seems to be used sometimes */
 		case PGM_ACK:		/* Unicast upstream */
 			PULL(buf, ack);
@@ -445,129 +449,9 @@ bool pgm_process(struct rdma_channel *c,
 			break;
 
 		default:
-			logg(LOG_NOTICE, "%s: Invalid PGM type=%x. Packet Skipped.\n", text, header.pgm.pgm_type);
 			break;
 	}
 
-	options_start = buf->cur;
-	if (header.pgm.pgm_options & 0x1) {
-		bool last = false;
-
-		do {
-			struct pgm_opt_header opt;
-			struct pgm_opt_length length;
-			struct pgm_opt_fragment fragment;
-			struct pgm_opt_nak_list nak_list;
-			struct pgm_opt_join join;
-			struct pgm_opt_redirect redirect;
-			struct pgm_opt_fin fin;
-			struct pgm_opt_syn syn;
-			struct pgm_opt_rst rst;
-			uint8_t *start_option = buf->cur;
-
-			PULL(buf, opt);
-
-			if (opt.opt_length == 0) {
-				logg(LOG_NOTICE, "Invalid option length zero\n");
-				break;
-			}
-
-			last = opt.opt_type & PGM_OPT_END;
-			switch (opt.opt_type & PGM_OPT_MASK) {
-				case PGM_OPT_LENGTH:
-					buf->cur = start_option;
-					PULL(buf, length);
-					total_opt_length = ntohs(length.opt_total_length);
-					break;
-				case PGM_OPT_FRAGMENT:
-					PULL(buf, fragment);
-					logg(LOG_INFO, "%s: OPT Fragment SQN=%x offset=%d len=%d\n", text,
-							ntohl(fragment.opt_sqn), ntohl(fragment.opt_frag_off), ntohl(fragment.opt_frag_len));
-					break;
-				case PGM_OPT_NAK_LIST:
-					PULL(buf, nak_list);
-					logg(LOG_INFO, "%s: OPT NAK list #%d\n", text, (opt.opt_length - 1) /4 );
-
-					break;
-				case PGM_OPT_JOIN:
-					PULL(buf, join);
-					logg(LOG_INFO, "%s: OPT Join MIN SQN=%d\n",
-								text, ntohl(join.opt_join_min));
-					break;
-				case PGM_OPT_REDIRECT:
-					PULL(buf, redirect);
-
-					logg(LOG_INFO, "%s: OPT Redirect NLA=%s\n", text, inet_ntoa(redirect.opt_nla));
-					break;
-
-				/* Not sure if these options are in use.  They are mostly not necessary (?) */
-				case PGM_OPT_SYN:
-					PULL(buf, syn);
-					logg(LOG_INFO, "%s: OPT SYN\n", text);
-					s->last_seq = sqn;
-					s->last = sqn;
-					s->oldest = sqn;
-					break;
-				case PGM_OPT_FIN:
-					PULL(buf, fin);
-					logg(LOG_NOTICE, "%s: End of Stream TSI %s\n", i->text, text);
-					if (s) {
-						/* Remove all records */
-						hash_del(i->pgm_tsi_hash, &tsi);
-						free(s);
-						i->nr_tsi--;
-						s = NULL;
-					}
-					break;
-				case PGM_OPT_RST:
-					PULL(buf, rst);
-					logg(LOG_NOTICE, "%s: OPT RST\n", text);
-					break;
-
-				case 0x21:
-				case 0x22:
-				case 0x23:
-				case 0x24:
-					break;
-
-				/* NAK Intervals */
-				case PGM_OPT_NAK_BO_IVL:
-				case PGM_OPT_NAK_BO_RNG:
-
-				/* NLA redirection */
-				case PGM_OPT_PATH_NLA:
-
-				/* Broken Multicast ??? */
-				case PGM_OPT_NBR_UNREACH:
-
-				case PGM_OPT_INVALID:
-
-				/* Congestion "Control" and avoidance. Traffic load feedback */
-				case PGM_OPT_CR:
-				case PGM_OPT_CRQST:
-
-				/* Forward Error correction.... How would this work ??? */
-				case PGM_OPT_PARITY_PRM:
-				case PGM_OPT_PARITY_GRP:
-				case PGM_OPT_CURR_TGSIZE:
-
-				/* Extensions by PGMCC */
-				case PGM_OPT_PGMCC_DATA:
-				case PGM_OPT_PGMCC_FEEDBACK:
-
-				default:
-					logg(LOG_NOTICE, "%s: Invalid PGM option=%x Option Skipped. D=%s\n",
-						text, opt.opt_type & PGM_OPT_MASK,
-						_hexbytes(start_option, opt.opt_length));
-					break;
-			}
-			buf->cur = start_option + opt.opt_length;
-		} while (!last);
-
-		if (total_opt_length != buf->cur - options_start)
-			logg(LOG_NOTICE, "%s: Option length mismatch. Expected %d but it is %ld\n", s->text, total_opt_length, buf->cur - options_start);
-	}
-
 	return ret;
 }
 
