Index: rdma-core/ib2roce/cma-hdr.h
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/cma-hdr.h
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+/*
+ * Copyright (c) 2005 Voltaire Inc.  All rights reserved.
+ * Copyright (c) 2002-2005, Network Appliance, Inc. All rights reserved.
+ * Copyright (c) 1999-2019, Mellanox Technologies, Inc. All rights reserved.
+ * Copyright (c) 2005-2006 Intel Corporation.  All rights reserved.
+ */
+
+union cma_ip_addr {
+	struct in6_addr ip6;
+	struct {
+		__be32 pad[3];
+		__be32 addr;
+	} ip4;
+};
+
+struct cma_hdr {
+	uint8_t cma_version;
+	uint8_t ip_version;	/* IP version: 7:4 */
+	__be16 port;
+	union cma_ip_addr src_addr;
+	union cma_ip_addr dst_addr;
+};
+
+#define CMA_VERSION 0x00
+
+static inline uint8_t cma_get_ip_ver(const struct cma_hdr *hdr)
+{
+	return hdr->ip_version >> 4;
+}
+
+static inline void cma_set_ip_ver(struct cma_hdr *hdr, uint8_t ip_ver)
+{
+	hdr->ip_version = (ip_ver << 4) | (hdr->ip_version & 0xF);
+}
+
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -75,6 +75,7 @@
 #include "fifo.h"
 #include "hash.h"
 #include "ibraw.h"
+#include "cma-hdr.h"
 
 #define VERSION "2022.0220"
 
@@ -2730,7 +2731,6 @@ struct sidr_req {
 	uint16_t	pkey;
 	uint16_t	reserved;
 	uint64_t	service_id;
-	char private[100];
 } __packed;
 
 #if 0
@@ -2754,47 +2754,6 @@ static void print_sidr(void)
 
 #endif
 
-static bool scan_private(char *s, struct in_addr *tx, struct in_addr *rx)
-{
-	struct {
-		struct in_addr x;
-		char ip[4];
-	} addr;
-	unsigned short port;
-	int r;
-	char *p = s;
-	char type[2];
-
-	tx->s_addr = 0;
-	rx->s_addr = 0;
-	while (*p) {
-		/* Find the beginning of the rmmXXX */
-		while (*p != 'r')
-			p++;
-
-		if (!*p)
-			goto exit;
-
-		r = sscanf(p, "rmm%cx at %hhu.%hhu.%hhu.%hhu|%hu", type, addr.ip, addr.ip + 1, addr.ip + 2, addr.ip + 3, &port);
-
-		logg(LOG_NOTICE, "Scan result = %d Type=%s IP=%s port=%d offset=%ld\n", r, type, inet_ntoa(addr.x), port, p - s);
-
-		if (r != 6)
-			return false;
-
-		if (*type == 'R')
-			*rx = addr.x;
-		else if (*type == 'T')
-			*tx = addr.x;
-		else
-			goto exit;
-
-		p += 10;
-	}
-exit:
-	return tx->s_addr || rx->s_addr;
-}
-
 /*
  * Simple listener to quickly gather IP/ GID information off the wire
  */
@@ -2883,12 +2842,27 @@ static const char *sidr_req(struct buf *
 	} else { /* Infiniband */
 		struct in_addr source;
 		struct sidr_req sr;
+		struct cma_hdr ch; 
 
 		PULL(buf, sr);
+		PULL(buf, ch);
 
-		dest.s_addr = 0;
-		if (!scan_private(sr.private + 36, &source, &dest))
-			return "SIDR REQ: Dest and Source IP not determined";
+		if (ch.cma_version != CMA_VERSION)
+			return "SIDR REQ: Unsupported CMA version";
+
+		if (cma_get_ip_ver(&ch) != 4)
+			return "SIDR REQ: Only IPv4 private data supported";
+
+
+		/* For some reason this is being crossed here */
+		source.s_addr = ch.dst_addr.ip4.addr;
+		dest.s_addr = ch.src_addr.ip4.addr;
+
+		if (!valid_addr(source_i, source))
+			return "SIDR REQ: Invalid Source address";
+
+		if (!valid_addr(dest_i, dest))
+			return "SIDR REQ: Invalid Destination address";
 
 		if (source_ep->addr.s_addr == 0 && source.s_addr) {
 			source_ep->addr = source;
@@ -2905,8 +2879,6 @@ static const char *sidr_req(struct buf *
 	if (!dest_ep)
 		return "Cannot forward MAD packet. AH is not known";
 
-	logg(LOG_NOTICE, "SIDR REQ: Dest %s on %s QP=%d\n", inet_ntoa(dest_ep->addr), dest_i->text, w->src_qp);
-
 	if (bridging) {
 
 		remove_forward(dest_ep, 1);
