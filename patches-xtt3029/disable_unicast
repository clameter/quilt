Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -65,9 +65,12 @@
 #include "beacon.h"
 #include "cli.h"
 #include "pgm.h"
+
+#ifdef UNICAST
 #include "endpoint.h"
 #include "unicast.h"
 #include "ibraw.h"
+#endif
 
 /* Globals */
 
@@ -155,7 +158,9 @@ void receive_multicast(struct buf *buf)
 	int ret;
 	const char *reason = NULL;
 
+#ifdef UNICAST
 	learn_source_address(buf);
+#endif
 
 	if (!buf->grh_valid) {
 		logg(LOG_WARNING, "No GRH on %s. Packet discarded: %s\n",
@@ -315,59 +320,18 @@ invalid_packet:
 	st(c, packets_invalid);
 }
 
-static int status_fd;
-
-static void status_write(void *private)
-{
-	static char b[10000];
-	int n = 0;
-	int fd = status_fd;
-
-	if (update_requested) {
-
-		char name[40];
-		time_t t = time(NULL);
-		struct tm *tm;
-
-		tm = localtime(&t);
-
-		snprintf(name, 40, "ib2roce-%d%02d%02dT%02d%02d%02d",
-				tm->tm_year + 1900, tm->tm_mon +1, tm->tm_mday,
-				tm->tm_hour, tm->tm_min, tm->tm_sec);
-		fd = open(name, O_CREAT | O_RDWR,  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
-
-	} else
-		lseek(fd, SEEK_SET, 0);
-
-	n+= show_multicast(n + b);
-	n+= show_interfaces(n + b);
-	n+= show_endpoints(n+b);
-	
-	n += sprintf(n + b, "\n\n\n\n\n\n\n\n");
-	if (write(fd, b, n) < 0)
-		logg(LOG_ERR, "Status write failed with %s\n", errname());
-
-	if (update_requested) {
-		close(fd);
-		update_requested = false;
-	}
-	add_event(timestamp() + seconds(60), status_write, NULL,  "Status File Write");
-}
-
 static void logging(void *private)
 {
 	brief_status(stdout);
-	add_event(timestamp() + seconds(10), logging, NULL, "Brief Status");
+	add_event(timestamp() + seconds(60), logging, NULL, "Brief Status");
 }
 
 static void setup_timed_events(void)
 {
 	now = timestamp();
 
-	if (background) {
-		add_event(now + seconds(30), status_write, NULL, "Write Status File");
+	if (background)
 		logging(NULL);
-	}
 
 	calculate_pps(NULL);
 
@@ -566,8 +530,10 @@ int main(int argc, char **argv)
 	if (cores)
 		show_core_config();
 
+#ifdef UNICAST
 	if (background)
 		status_fd = open("ib2roce-status", O_CREAT | O_RDWR | O_TRUNC,  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+#endif
 
 	beacon_setup();
 
@@ -592,8 +558,10 @@ int main(int argc, char **argv)
 	beacon_shutdown();
 	stop_cores();
 
+#ifdef UNICAST
 	if (background)
 		close(status_fd);
+#endif
 
 	shutdown_roce();
 	shutdown_ib();
Index: rdma-core/ib2roce/buffers.c
===================================================================
--- rdma-core.orig/ib2roce/buffers.c
+++ rdma-core/ib2roce/buffers.c
@@ -41,10 +41,13 @@
 #include "locking.h"
 #include "logging.h"
 #include "buffers.h"
-#include "endpoint.h"
 #include "cli.h"
 #include "hash.h"
 
+#ifdef UNICAST
+#include "endpoint.h"
+#endif
+
 #include <sys/mman.h>
 #include <stdatomic.h>
 #include <stdint.h>
@@ -437,6 +440,7 @@ queue:
 	return 0;
 }
 
+#ifdef UNICAST
 /* Send buffer based on state in struct buf. Unicast only */
 int send_buf(struct buf *buf, struct rdma_unicast *ra)
 {
@@ -539,6 +543,7 @@ void send_buf_to(struct i2r_interface *i
 			return;
 	}
 }
+#endif
 
 static void buffers_cmd(FILE *out, char *parameters)
 {
Index: rdma-core/ib2roce/channel.c
===================================================================
--- rdma-core.orig/ib2roce/channel.c
+++ rdma-core/ib2roce/channel.c
@@ -41,7 +41,6 @@
 #include <linux/if_arp.h>
 #include <infiniband/mad.h>
 
-
 #include "fifo.h"
 #include "interfaces.h"
 #include "channel.h"
@@ -327,6 +326,7 @@ static bool setup_multicast(struct rdma_
 	return allocate_rdmacm_qp(c, true);
 }
 
+#ifdef UNICAST
 static bool setup_incoming(struct rdma_channel *c)
 {
 	return allocate_rdmacm_qp(c, true);
@@ -454,18 +454,22 @@ static bool setup_packet(struct rdma_cha
 	register_callback(handle_receive_packet, fh, c);
 	return true;
 }
+#endif
 
 struct channel_info channel_infos[nr_channel_types] = {
 	{ "multicast",	0, 0,	10000,	1000,	0,		IBV_QPT_UD,		setup_multicast, receive_multicast, channel_err },
+#ifdef UNICAST
 	{ "ud",		1, 1,	500,	200,	RDMA_UDP_QKEY,	IBV_QPT_UD,		setup_channel,	receive_ud,	channel_err },
 	{ "qp1",	2, 1,	10,	5,	IB_DEFAULT_QP1_QKEY, IBV_QPT_UD,	setup_channel,	receive_qp1,	channel_err },
 	{ "raw",	3, 1,	1000, 	5,	0x12345,	IBV_QPT_RAW_PACKET,	setup_raw,	receive_raw,	channel_packet },
 	{ "ibraw",	3, 1,	1000,	5,	0x12345,	IBV_QPT_UD,		setup_raw,	receive_raw,	channel_packet },
 	{ "packet",	-1, -1,	0,	0,	0,		0,			setup_packet,	receive_raw,	channel_err },
 	{ "incoming",	-1, -1,	100,	50,	0,		0,			setup_incoming,	NULL,		channel_err },
+#endif
 	{ "error",	-1, -1,	0,	0,	0,		0,			NULL,		NULL,		channel_err },
 };
 
+#ifdef UNICAST
 static bool flow_steering = false;	/* Use flow steering to filter packets */
 
 static void setup_flow(struct rdma_channel *c)
@@ -518,7 +522,7 @@ static void setup_flow(struct rdma_chann
 	if (!c->flow)
 		logg(LOG_ERR, "Failure to create flow on %s. Errno %s\n", c->text, errname());
 }
-
+#endif
 
 void channel_destroy(struct rdma_channel *c)
 {
@@ -632,6 +636,7 @@ void arm_channels(struct core_info *core
 					}
 					break;
 
+#ifdef UNICAST
 				case channel_raw:
 				case channel_ibraw:
 					start_channel(c);
@@ -646,6 +651,7 @@ void arm_channels(struct core_info *core
 						ibv_req_notify_cq(c->cq, 0);
 					}
 					break;
+#endif
 				default:
 					break;
 			}
@@ -753,12 +759,13 @@ static void channel_init(void)
 	register_concom("zap", true, 0, "Clear counters", zap_cmd );
 	register_concom("channels", true, 0, "Print information about communication channels", channels_cmd);
 
-	register_enable("flow", false, &flow_steering, NULL, "on", "off", NULL,
-		"Enable flow steering to limit the traffic on the RAW sockets [Experimental, Broken]");
-
 	register_enable("loopbackprev", false, &loopback_blocking, NULL, "on", "off", NULL,
 		"Multicast loopback prevention of the NIC");
 
+#ifdef UNICAST
+	register_enable("flow", false, &flow_steering, NULL, "on", "off", NULL,
+		"Enable flow steering to limit the traffic on the RAW sockets [Experimental, Broken]");
+#endif
 	register_option("port", required_argument, 'p', port_set,
 		       "<number>", "Set default port number to use if none is specified");
 
Index: rdma-core/ib2roce/channel.h
===================================================================
--- rdma-core.orig/ib2roce/channel.h
+++ rdma-core/ib2roce/channel.h
@@ -161,7 +161,11 @@ void calculate_pps(void *private);
 
 void show_core_config(void);
 
-receive_callback receive_multicast, receive_main, receive_raw, receive_ud, receive_qp1;
+receive_callback receive_multicast;
+
+#ifdef UNICAST
+receive_callback receive_main, receive_raw, receive_ud, receive_qp1;
+#endif
 
 #endif
 
Index: rdma-core/ib2roce/endpoint.h
===================================================================
--- rdma-core.orig/ib2roce/endpoint.h
+++ rdma-core/ib2roce/endpoint.h
@@ -115,18 +115,6 @@ static inline bool unicast_lid(uint16_t
 	return lid > 0 && lid < 0xc000;
 }
 
-static inline bool __valid_addr(struct i2r_interface *i, __be32 saddr)
-{
-	unsigned netmask = i->if_netmask.sin_addr.s_addr;
-
-	return ((saddr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask));
-}
-
-static inline bool valid_addr(struct i2r_interface *i, struct in_addr addr)
-{
-	return __valid_addr(i, addr.s_addr);
-}
-
 void learn_source_address(struct buf *buf);
 struct endpoint *ip_to_ep(struct i2r_interface *i, struct in_addr addr);
 struct endpoint *buf_to_ep(struct buf *buf, struct in_addr addr);
Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- rdma-core.orig/ib2roce/interfaces.c
+++ rdma-core/ib2roce/interfaces.c
@@ -68,7 +68,9 @@
 #include "multicast.h"
 #include "interfaces.h"
 #include "cli.h"
+#ifdef UNICAST
 #include "endpoint.h"
+#endif
 
 char *ib_name, *roce_name;
 
@@ -79,9 +81,11 @@ int max_rburst = 10;		/* Dont delay unti
 int max_iburst = 10;		/* Dont delay until # of packets for Infiniband */
 
 bool bridging = true;		/* Allow briding */
+#ifdef UNICAST
 bool unicast = false;		/* Bridge unicast packets */
 static bool raw = false;	/* Use raw channels */
 static bool packet_socket = false;	/* Do not use RAW QPs, use packet socket instead */
+#endif
 
 static int mc_per_qp = 0;	/* 0 = Unlimited */
 
@@ -426,9 +430,11 @@ void setup_interface(enum interfaces in)
 	struct i2r_interface *i = i2r + in;
 	struct ibv_gid_entry *e;
 	struct rdma_channel *multicast= NULL;
+#ifdef UNICAST
 	struct rdma_channel *qp1 = NULL;
 	struct rdma_channel *raw_channel = NULL;
 	struct rdma_channel *ud = NULL;
+#endif
 	unsigned channels;
 
 	if (in == INFINIBAND)
@@ -482,13 +488,14 @@ void setup_interface(enum interfaces in)
 
 	numa_run_on_node(i->numa_node);
 
+#ifdef UNICAST
 	i->ru_hash = hash_create(offsetof(struct rdma_unicast, sin), sizeof(struct sockaddr_in));
 	i->ip_to_ep = hash_create(offsetof(struct endpoint, addr), sizeof(struct in_addr));
 	if (i == i2r + INFINIBAND)
 		i->ep = hash_create(offsetof(struct endpoint, lid), sizeof(uint16_t));
 	else
 		i->ep = i->ip_to_ep;;
-
+#endif
 
 	/* Create RDMA elements that are interface wide */
 	i->rdma_events = rdma_create_event_channel();
@@ -538,6 +545,7 @@ void setup_interface(enum interfaces in)
 
 	}
 
+#ifdef UNICAST
 	if (unicast) {
 
 		i->channels.c[channels++] = ud = new_rdma_channel(i, channel_ud, NULL);
@@ -558,12 +566,15 @@ void setup_interface(enum interfaces in)
 
 	if (channels > MAX_CHANNELS_PER_INTERFACE)
 		panic("Too many channels for interface %s\n", i->text);
+#endif
 
  	check_out_of_buffer(i);
  	numa_run_on_node(-1);
 
 	logg(LOG_NOTICE, "%s interface %s/%s(%d) port %d GID=%s/%d IPv4=%s:%d CQs=%u"
+#ifdef UNICAST
 		"/%u/%u"
+#endif
 			" MTU=%u NUMA=%d.\n",
 		i->text,
 		i->rdma_name,
@@ -572,8 +583,10 @@ void setup_interface(enum interfaces in)
 		inet6_ntoa(e->gid.raw), i->gid_index,
 		inet_ntoa(i->if_addr.sin_addr), default_port,
 		multicast ? multicast->nr_cq: 0,
+#ifdef UNICAST
 		ud ? ud->nr_cq : 0,
 		raw_channel ? raw_channel->nr_cq : 0,
+#endif
 		i->mtu,
 		i->numa_node
 	);
@@ -1342,13 +1355,15 @@ static void interfaces_init(void)
 		"<if[:portnumber][/<netdev>]", "Infiniband device. Uses the first available if not specified");
 	register_option("roce", required_argument, 'r', roce_set,
 	       "<if[:portnumber]>","ROCE device. Uses the first available if not specified.");
+	register_enable("mcqp", true, NULL, &mc_per_qp, "0", "10", NULL, "Max # of MCs per QP");
 
+#ifdef UNICAST
 	register_enable("packetsocket", false, &packet_socket, NULL, "on", "off", NULL,
 		"Use a packet socket instead of a RAW QP to capure IB/ROCE traffic");
 	register_enable("raw", false, &raw, NULL, "on", "off",	NULL,
 		"Use of RAW sockets to capture SIDR Requests. Avoids having to use a patched kernel");
 	register_enable("unicast", false, &unicast, NULL, "on", "off",	NULL,
 		"Processing of unicast packets with QP1 handling of SIDR REQ/REP");
-	register_enable("mcqp", true, NULL, &mc_per_qp, "0", "10", NULL, "Max # of MCs per QP");
+#endif
 }
 
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- rdma-core.orig/ib2roce/interfaces.h
+++ rdma-core/ib2roce/interfaces.h
@@ -177,4 +177,16 @@ void shutdown_roce(void);
 
 unsigned show_interfaces(char *b);
 
+static inline bool __valid_addr(struct i2r_interface *i, __be32 saddr)
+{
+	unsigned netmask = i->if_netmask.sin_addr.s_addr;
+
+	return ((saddr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask));
+}
+
+static inline bool valid_addr(struct i2r_interface *i, struct in_addr addr)
+{
+	return __valid_addr(i, addr.s_addr);
+}
+
 #endif
Index: rdma-core/ib2roce/logging.c
===================================================================
--- rdma-core.orig/ib2roce/logging.c
+++ rdma-core/ib2roce/logging.c
@@ -55,7 +55,9 @@
 #include "logging.h"
 #include "cli.h"
 #include "pgm.h"
+#ifdef UNICAST
 #include "endpoint.h"
+#endif
 
 int loglevel = LOG_INFO;
 bool background;
@@ -243,8 +245,10 @@ void brief_status(FILE *out)
 	else
 		fprintf(out, "%s. Groups=%d/%d. Packets=%s\n", events, active_mc, nr_mc, counts);
 
+#ifdef UNICAST
 	list_endpoints(i2r + INFINIBAND);
 	list_endpoints(i2r + ROCE);
+#endif
 }
 
 /*
Index: rdma-core/ib2roce/pgm.c
===================================================================
--- rdma-core.orig/ib2roce/pgm.c
+++ rdma-core/ib2roce/pgm.c
@@ -38,7 +38,9 @@
 #include "interfaces.h"
 #include "pgm.h"
 #include "packet.h"
+#ifdef UNICAST
 #include "endpoint.h"
+#endif
 #include "cli.h"
 
 /*
Index: rdma-core/ib2roce/CMakeLists.txt
===================================================================
--- rdma-core.orig/ib2roce/CMakeLists.txt
+++ rdma-core/ib2roce/CMakeLists.txt
@@ -13,10 +13,8 @@ rdma_executable(ib2roce
   locking.c
   buffers.c
   multicast.c
-  unicast.c
   interfaces.c
   cli.c
-  endpoint.c
   pgm.c
 )
 target_link_libraries(ib2roce LINK_PRIVATE
