Index: rdma-core/ib2roce/beacon.c
===================================================================
--- rdma-core.orig/ib2roce/beacon.c
+++ rdma-core/ib2roce/beacon.c
@@ -90,7 +90,7 @@ struct bridge_state {
 	unsigned beacons_missed;
 	unsigned beacons_received;
 	long  distance[3];
-	struct rdma_channel *channel[NR_INTERFACES][MAX_CHANNELS_PER_INTERFACE];
+	struct channel_list *channels[NR_INTERFACES];
 	struct beacon_info last;
 };
 
@@ -120,10 +120,10 @@ void run_bridge_channels(FILE *out, void
 	for(i = 0; i < nr_bridges; i++) {
 		struct bridge_state *br = remote_bridge + i;
 
-		channel_raw_foreach(c, br->channel[INFINIBAND])
+		channel_foreach(c, br->channels[INFINIBAND])
 			func(out, c);
 
-		channel_raw_foreach(c, br->channel[ROCE])
+		channel_foreach(c, br->channels[ROCE])
 			func(out,c );
 	}
 }
@@ -139,7 +139,7 @@ static void enable_bridge(struct bridge_
 
 	/* Create new MC channels */
 	for (i = 0; i < NR_INTERFACES; i++) {
-		b->channel[i][0] = new_rdma_channel(i2r + i, channel_rdmacm);
+		b->channels[i]->c[0] = new_rdma_channel(i2r + i, channel_rdmacm);
 	}
 
 
@@ -182,17 +182,17 @@ static void enable_bridge(struct bridge_
 		m->enabled = true;
 	}
 
-	channel_raw_foreach(c, b->channel[INFINIBAND])
+	channel_foreach(c, b->channels[INFINIBAND])
 		post_receive(c);
-	channel_raw_foreach(c, b->channel[ROCE])
+	channel_foreach(c, b->channels[ROCE])
 		post_receive(c);
 
-	channel_raw_foreach(c, b->channel[INFINIBAND])
+	channel_foreach(c, b->channels[INFINIBAND])
 		arm_channel(c);
-	channel_raw_foreach(c, b->channel[ROCE])
+	channel_foreach(c, b->channels[ROCE])
 		arm_channel(c);
 
-	check_joins(b->channel[INFINIBAND], b->channel[ROCE]);
+	check_joins(b->channels[INFINIBAND], b->channels[ROCE]);
 	b->active = true;
 }
 
@@ -205,14 +205,14 @@ static void disable_bridge(struct bridge
  * If there are errors: Do not worry. Destroying the
  * QP is also an implied leave
  */
-	channel_raw_foreach(c, b->channel[INFINIBAND])
+	channel_foreach(c, b->channels[INFINIBAND])
 		leave_mc(INFINIBAND, c);
-	channel_raw_foreach(c, b->channel[ROCE])
+	channel_foreach(c, b->channels[ROCE])
 		leave_mc(ROCE, c);
 
-	channel_raw_foreach(c, b->channel[INFINIBAND])
+	channel_foreach(c, b->channels[INFINIBAND])
 		channel_destroy(c);
-	channel_raw_foreach(c, b->channel[ROCE])
+	channel_foreach(c, b->channels[ROCE])
 		channel_destroy(c);
 }
 
@@ -253,7 +253,7 @@ static void prep_beacon_struct(struct i2
 	for(m = mcs; m < mcs + nr_mc; m++) {
 		struct beacon_multicast *bm = b->mc + groups;
 
-		if (m->admin || !m->enabled || !is_a_channel_of(m->interface[i - i2r].channel, i - i2r))
+		if (m->admin || !m->enabled || !is_a_channel_of(m->interface[i - i2r].channel, &i->channels))
 			continue;
 
 		bm->group = m->addr;
@@ -384,7 +384,7 @@ static void beacon_send(void *private)
 				return;
 			}
 			/* Just some channel */
-			buf = alloc_buffer(i->channel[0]);
+			buf = alloc_buffer(i->channels.c[0]);
 			prep_beacon_struct(i, buf);
 
 			reset_flags(buf);
Index: rdma-core/ib2roce/channel.c
===================================================================
--- rdma-core.orig/ib2roce/channel.c
+++ rdma-core/ib2roce/channel.c
@@ -313,6 +313,7 @@ static bool setup_multicast(struct rdma_
 
 	register_callback(handle_async_event, i->context->async_fd, i);
 
+	/* XXX This is not going to work for multi channel RDMA */
 	ret = rdma_bind_addr(c->id, c->bindaddr);
 	if (ret) {
 		logg(LOG_CRIT, "Failed to bind %s interface. Error %s\n",
@@ -594,7 +595,7 @@ void stop_channel(struct rdma_channel *c
 void all_channels(FILE *out, void (*func)(FILE *out, struct rdma_channel *))
 {
 	for(struct i2r_interface *i = i2r; i <i2r + NR_INTERFACES; i++) if (i->context) {
-		channel_foreach(c, i) {
+		channel_foreach(c, &i->channels) {
 			if (c)
 				func(out, c);
 		}
@@ -602,9 +603,9 @@ void all_channels(FILE *out, void (*func
 	run_bridge_channels(NULL, func);
 }
 
-bool is_a_channel_of(struct rdma_channel *c, enum interfaces in)
+bool is_a_channel_of(struct rdma_channel *c, struct channel_list *cl)
 {
-	channel_foreach(c2, i2r + in)
+	channel_foreach(c2, cl)
 		if (c2 == c)
 			return true;
 	return false;
@@ -621,7 +622,7 @@ void arm_channels(struct core_info *core
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
 	   if (i->context) {
-		   channel_foreach(c, i) {
+		   channel_foreach(c, &i->channels) {
 
 			switch (c->type) {
 		   		case  channel_rdmacm:
Index: rdma-core/ib2roce/channel.h
===================================================================
--- rdma-core.orig/ib2roce/channel.h
+++ rdma-core/ib2roce/channel.h
@@ -114,6 +114,7 @@ struct rdma_channel {
 	unsigned last_received, last_sent;
 	unsigned pps_in, pps_out;	/* Rate in the last interval */
 	unsigned max_pps_in, max_pps_out; /* Max Rate seen */
+	unsigned nr_mcs;		/* Number of Multicast groups attached to this channel */
 	struct mc *mc[];		/* Dynamically sized structure depending on the number of allowed MC groups for an interface */
 };
 
@@ -155,7 +156,6 @@ void arm_channel(struct rdma_channel *);
 void channel_destroy(struct rdma_channel *c);
 
 void all_channels(FILE *out, void (*func)(FILE *out, struct rdma_channel *));
-bool is_a_channel_of(struct rdma_channel *, enum interfaces);
 
 void calculate_pps(void *private);
 
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -389,7 +389,7 @@ static void setup_timed_events(void)
 
 	calculate_pps(NULL);
 
-	check_joins(i2r[INFINIBAND].channel, i2r[ROCE].channel);
+	check_joins(&i2r[INFINIBAND].channels, &i2r[ROCE].channels);
 }
 
 static void update_status(int x)
Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- rdma-core.orig/ib2roce/interfaces.c
+++ rdma-core/ib2roce/interfaces.c
@@ -292,7 +292,7 @@ static void qp_destroy(struct i2r_interf
 	}
 #endif
 
-	channelp_foreach(c, i) {
+	channelp_foreach(c, &i->channels) {
 		if (*c) {
 			channel_destroy(*c);
 			*c = NULL;
@@ -410,7 +410,7 @@ void check_out_of_buffer(void *private)
 /* Find an RDMA channel by type */
 struct rdma_channel *find_channel(struct i2r_interface *i, enum channel_type type)
 {
-	channel_foreach(c, i) {
+	channel_foreach(c, &i->channels) {
 
 		if (c->type == type)
 			return c;
@@ -513,26 +513,28 @@ void setup_interface(enum interfaces in)
 	if (!i->mr)
 		panic("ibv_reg_mr failed for %s:%s.\n", i->text, errname());
 
-	channels = 0;
-	i->channel[channels++] = multicast = new_rdma_channel(i, channel_rdmacm);
+	channels = 1 + (nr_mc - 1) / i->device_attr.max_mcast_grp;
+	for(int j = 0; j < channels; j++) {
+		i->channels.c[j] = multicast = new_rdma_channel(i, channel_rdmacm);
 
-	if (!i->channel[0])
-		abort();
+		if (!multicast)
+			abort();
+	}
 
 	if (unicast) {
 
-		i->channel[channels++] = ud = new_rdma_channel(i, channel_ud);
-		i->channel[channels++] = qp1 = new_rdma_channel(i, channel_qp1);
+		i->channels.c[channels++] = ud = new_rdma_channel(i, channel_ud);
+		i->channels.c[channels++] = qp1 = new_rdma_channel(i, channel_qp1);
 
 		if (raw) {
 			if (i == i2r + INFINIBAND) {
-				i->channel[channels++] = raw_channel = new_rdma_channel(i, channel_ibraw);
+				i->channels.c[channels++] = raw_channel = new_rdma_channel(i, channel_ibraw);
 				/* Sadly fallback is not working here */
 			} else {
 				if (packet_socket)
-					i->channel[channels++] = new_rdma_channel(i, channel_packet);
+					i->channels.c[channels++] = new_rdma_channel(i, channel_packet);
 				else
-					i->channel[channels++] = new_rdma_channel(i, channel_raw);
+					i->channels.c[channels++] = new_rdma_channel(i, channel_raw);
 			}
 		}
 	}
@@ -565,7 +567,7 @@ void shutdown_ib(void)
 	if (!i2r[INFINIBAND].context)
 		return;
 
-	channel_foreach(c, i2r + INFINIBAND) {
+	channel_foreach(c, &i2r[INFINIBAND].channels) {
 		if (c->type == channel_rdmacm)
 			leave_mc(INFINIBAND, c);
 	}
@@ -579,7 +581,7 @@ void shutdown_roce(void)
 	if (!i2r[ROCE].context)
 		return;
 
-	channel_foreach(c, i2r + ROCE) {
+	channel_foreach(c, &i2r[ROCE].channels) {
 		if (c->type == channel_rdmacm)
 			leave_mc(ROCE, c);
 	}
@@ -890,7 +892,7 @@ void post_receive_buffers(void)
 	struct i2r_interface *i;
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-		channel_foreach(c, i) {
+		channel_foreach(c, &i->channels) {
 			if (c)
 				post_receive(c);
 		}
@@ -1112,7 +1114,7 @@ unsigned show_interfaces(char *b)
 	int n = 0;
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-		channel_foreach(c, i) {
+		channel_foreach(c, &i->channels) {
 			if (c)
 				n += channel_stats(b + n, c, c->i->text, c->type == channel_rdmacm ? "Multicast" : c->text);
 		}
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- rdma-core.orig/ib2roce/interfaces.h
+++ rdma-core/ib2roce/interfaces.h
@@ -66,31 +66,31 @@ extern int max_iburst;	/* Dont delay unt
 
 #define MAX_CHANNELS_PER_INTERFACE 10
 
+typedef struct rdma_channel *rdma_channel_ptr;
+
+struct channel_list {
+	rdma_channel_ptr c[MAX_CHANNELS_PER_INTERFACE];
+};
+
+bool is_a_channel_of(struct rdma_channel *, struct channel_list *);
+
 /* Iterators for channel array per interface processing */
 
 /* Specifcation of the channel array directly and the iterator is a pointer to pointer of the object */
-#define channelp_raw_foreach(_channel, _interface_ch)				\
-	for(struct rdma_channel **_channel = _interface_ch; \
-		_channel < _interface_ch + MAX_CHANNELS_PER_INTERFACE; _channel++)
+#define channelp_foreach(_channel, _channel_list)					\
+	for(struct rdma_channel **_channel = ((struct rdma_channel **)&((_channel_list)->c));				\
+		_channel < ((struct rdma_channel **)&((_channel_list)->c)) + MAX_CHANNELS_PER_INTERFACE; _channel++)
 
 /* Specification of the channel array directly with an iterator that is the pointer to the object */
-#define channel_raw_foreach(_channel, _interface_ch)						\
-	channelp_raw_foreach(_ch2, _interface_ch) for(struct rdma_channel *_channel = *_ch2; _channel; _channel = NULL)
-
-/* Specification of an interface and iterator using a pointer to the pointer */
-#define channelp_foreach(_channel, _interface)					\
-	channelp_raw_foreach(_channel, (_interface)->channel)
-
-/* Specification of an intrerface and iterator using a pointer to the object */
-#define channel_foreach(_channel, _interface)						\
-	channelp_foreach(_ch2, _interface) for(struct rdma_channel *_channel = *_ch2; _channel; _channel = NULL)
+#define channel_foreach(_channel, _channel_list)						\
+	channelp_foreach(_ch2, _channel_list) for(struct rdma_channel *_channel = *_ch2; _channel; _channel = NULL)
 
 struct i2r_interface {
 	/* Not changed when multithreading */
 	struct ibv_context *context;		/* Not for RDMA CM use */
 	struct ibv_comp_channel *comp_events;
 	struct rdma_event_channel *rdma_events;
-	struct rdma_channel *channel[MAX_CHANNELS_PER_INTERFACE];
+	struct channel_list channels;
 	struct ibv_cq *cq;
 	struct ibv_pd *pd;
 	struct ibv_mr *mr;
@@ -159,7 +159,7 @@ int find_rdma_devices(void);
 struct i2r_interface *find_interface(struct sockaddr_in *sin);
 struct rdma_channel *find_channel(struct i2r_interface *i, enum channel_type type);
 
-void check_joins(struct rdma_channel *infiniband[MAX_CHANNELS_PER_INTERFACE], struct rdma_channel *roce[MAX_CHANNELS_PER_INTERFACE]);
+void check_joins(struct channel_list *infiniband, struct channel_list *roce);
 void next_join_complete(void);
 
 void check_out_of_buffer(void *);
Index: rdma-core/ib2roce/multicast.c
===================================================================
--- rdma-core.orig/ib2roce/multicast.c
+++ rdma-core/ib2roce/multicast.c
@@ -203,7 +203,7 @@ void setup_mc_addrs(struct mc *m, struct
  * Parse an address with port number [:xxx] and/or mgid format [/YYYY]
  */
 struct sockaddr_in *parse_addr(const char *arg, int port,
-	uint8_t *p_mgid_mode, uint8_t *p_tos_mode, bool mc_only)
+		uint8_t *p_mgid_mode, uint8_t *p_tos_mode, bool mc_only)
 {
 	struct addrinfo *res;
 	char *service;
@@ -306,8 +306,8 @@ void mgids_out(void)
 	for (n = 0; n < nr_mgid_signatures; n++) {
 		struct mgid_signature *m = mgid_signatures + n;
 
-			printf("%7s|    0x%04x | %s\n",
-					m->id, m->signature, m->port ? "true" : "false");
+		printf("%7s|    0x%04x | %s\n",
+				m->id, m->signature, m->port ? "true" : "false");
 	}
 }
 
@@ -324,8 +324,8 @@ bool mgid_check(struct mc *m, unsigned s
 
 /* Multicast group specifications on the command line */
 int new_mc_addr(char *arg,
-	bool sendonly_infiniband,
-	bool sendonly_roce)
+		bool sendonly_infiniband,
+		bool sendonly_roce)
 {
 	struct sockaddr_in *si;
 	struct mc *m = mcs + nr_mc;
@@ -363,7 +363,7 @@ out:
 
 
 static int _join_mc(struct in_addr addr, struct sockaddr *sa,
-	unsigned port, uint8_t tos, struct rdma_channel *c, bool sendonly, struct mc *m)
+		unsigned port, uint8_t tos, struct rdma_channel *c, bool sendonly, struct mc *m)
 {
 	int ret;
 	int i;
@@ -371,7 +371,7 @@ static int _join_mc(struct in_addr addr,
 	struct rdma_cm_join_mc_attr_ex mc_attr = {
 		.comp_mask = RDMA_CM_JOIN_MC_ATTR_ADDRESS | RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS,
 		.join_flags = sendonly ? RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER
-                                       : RDMA_MC_JOIN_FLAG_FULLMEMBER,
+			: RDMA_MC_JOIN_FLAG_FULLMEMBER,
 		.addr = sa
 	};
 
@@ -389,18 +389,19 @@ static int _join_mc(struct in_addr addr,
 
 	if (ret) {
 		logg(LOG_CRIT, "Failed to create join request %s:%d on %s. Error %s\n",
-			inet_ntoa(addr), port,
-			c->i->text,
-			errname());
+				inet_ntoa(addr), port,
+				c->i->text,
+				errname());
 		return 1;
 	}
 	logg(LOG_NOTICE, "Join Request %sMC group %s:%d on %s.\n",
-		sendonly ? "Sendonly " : "",
-		inet_ntoa(addr), port,
-		c->i->text);
+			sendonly ? "Sendonly " : "",
+			inet_ntoa(addr), port,
+			c->i->text);
 	st(c, join_requests);
 
 	c->mc[i] = m;
+	c->nr_mcs++;
 	return 0;
 }
 
@@ -424,11 +425,12 @@ static int _leave_mc(struct in_addr addr
 		return 1;
 	}
 	logg(LOG_NOTICE, "Leaving MC group %s on %s .\n",
-		inet_ntoa(addr),
-		c->i->text);
+			inet_ntoa(addr),
+			c->i->text);
 
 	st(c, leave_requests);
 	c->mc[i] = NULL;
+	c->nr_mcs--;
 	return 0;
 }
 
@@ -460,7 +462,7 @@ int leave_mc(enum interfaces i, struct r
  * List the two rdma channels for bridging MC traffic on which joins are currently processed
  */
 static struct global_join_state {
-	struct rdma_channel channels[NR_INTERFACES][MAX_CHANNELS_PER_INTERFACE];
+	struct channel_list *channels[NR_INTERFACES];
 } gjs;
 
 /*
@@ -486,44 +488,50 @@ static void send_joins(void)
 			struct mc_interface *mi = m->interface + in;
 			uint8_t tos = in == ROCE ? m->tos_mode : 0;
 
-			if (mi->channel && mi->channel != gjs.channels[in]) {
-				logg(LOG_INFO, "Not joning multicast group %s which is not on rdma channel %s but on %s\n",
-						m->text, gjs.channels[in]->text, mi->channel->text);
+			if (mi->channel && !is_a_channel_of(mi->channel, gjs.channels[in])) {
+				logg(LOG_INFO, "Not joining multicast group %s which is not on rdma channel %s but on %s\n",
+						m->text, gjs.channels[in]->c[0]->text, mi->channel->text);
 				continue;
 			}
 
 			if (i2r[in].context) {
 				switch(mi->status) {
 
-				case MC_OFF:
-					if (_join_mc(m->addr, mi->sa, port, tos, gjs.channels[in], mi->sendonly, m) == 0) {
-						mi->status = MC_JOINING;
-						mi->channel = gjs.channels[in];
-					} else
-						/* Error during join... Lets retry this in awhile */
-						return;
-					break;
-
-				case MC_ERROR:
-
-					_leave_mc(m->addr, mi->sa, mi->channel, m);
-					mi->status = MC_OFF;
-					mi->channel = NULL;
-					logg(LOG_WARNING, "Left Multicast group %s on %s due to MC_ERROR\n",
-						m->text, interfaces_text[in]);
-					break;
-
-				case MC_JOINED:
-					break;
-
-				case MC_JOINING:
-					/* Join is still being processed */
-					break;
-
-				default:
-					logg(LOG_ERR, "Bad MC status %d MC %s on %s\n",
-					       mi->status, m->text, interfaces_text[in]);
-					break;
+					case MC_OFF:
+						/* Find rdma channel with available multicast slots  */
+						channel_foreach(c, gjs.channels[in]) {
+							if (c->type == channel_rdmacm && c->nr_mcs < c->i->device_attr.max_mcast_grp) {
+								if (_join_mc(m->addr, mi->sa, port, tos, c, mi->sendonly, m) == 0) {
+									mi->status = MC_JOINING;
+									mi->channel = c;
+								} else
+									/* Error during join... Lets retry this in awhile */
+									return;
+							}
+						}
+						panic("Not enough rdma channels for multicast channels");
+						break;
+
+					case MC_ERROR:
+
+						_leave_mc(m->addr, mi->sa, mi->channel, m);
+						mi->status = MC_OFF;
+						mi->channel = NULL;
+						logg(LOG_WARNING, "Left Multicast group %s on %s due to MC_ERROR\n",
+								m->text, interfaces_text[in]);
+						break;
+
+					case MC_JOINED:
+						break;
+
+					case MC_JOINING:
+						/* Join is still being processed */
+						break;
+
+					default:
+						logg(LOG_ERR, "Bad MC status %d MC %s on %s\n",
+								mi->status, m->text, interfaces_text[in]);
+						break;
 				}
 			}
 		}
@@ -548,17 +556,20 @@ void next_join_complete(void)
 	 */
 
 	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-	   if (i->context)	{
-		struct rdma_channel *c = gjs.channels[i - i2r];
+		if (i->context)	{
+			channel_foreach(c, gjs.channels[i - i2r]) {
+				if (c->type != channel_rdmacm)
+					continue;
 
-		if (c->listening)
-			continue;
+				if (c->listening)
+					continue;
 
-		if (rdma_listen(c->id, 50))
-			logg(LOG_ERR, "rdma_listen on %s error %s\n", c->text, errname());
+				if (rdma_listen(c->id, 50))
+					logg(LOG_ERR, "rdma_listen on %s error %s\n", c->text, errname());
 
-		c->listening = true;
-	}
+				c->listening = true;
+			}
+		}
 }
 
 static void __check_joins(void *private)
@@ -572,13 +583,12 @@ static void __check_joins(void *private)
 	}
 }
 
-void check_joins(struct rdma_channel *infiniband[MAX_CHANNELS_PER_INTERFACE],
-	struct rdma_channel *roce[MAX_CHANNELS_PER_INTERFACE])
+void check_joins(struct channel_list *infiniband,
+		struct channel_list *roce)
 {
-	memcpy(gjs.channels[INFINIBAND], infiniband, sizeof(struct rdma_channel *) * MAX_CHANNELS_PER_INTERFACE);
-	memcpy(gjs.channels[ROCE], roce, sizeof(struct rdma_channel *) * MAX_CHANNELS_PER_INTERFACE);
-
- 	__check_joins(NULL);
+	gjs.channels[INFINIBAND] = infiniband;
+	gjs.channels[ROCE] = roce;
+	 __check_joins(NULL);
 }
 
 unsigned show_multicast(char *b)
@@ -633,7 +643,7 @@ static void multicast_cmd(FILE *out, cha
 			if (m->admin)
 				fprintf(out, "admin ");
 
-			if (!is_a_channel_of(mi->channel, in))
+			if (!is_a_channel_of(mi->channel, &i2r[in].channels))
 				fprintf(out, "remote ");
 
 			fprintf(out, "packet_time=%dns, max_burst=%d packets, delayed=%ld packets, last_sent=%ldms ago, last_delayed=%ldms ago, pending=%u packets, burst=%d\n",
