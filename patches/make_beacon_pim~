Index: rdma-core/ib2roce/beacon.c
===================================================================
--- rdma-core.orig/ib2roce/beacon.c
+++ rdma-core/ib2roce/beacon.c
@@ -41,10 +41,12 @@
 #include "beacon.h"
 
 #define BEACON_SIGNATURE 0xD3ADB33F
+#define BEACON_MC_ADDR "239.1.2.3"
+#define BEACON_PORT	1109
 
-static bool beacon = false;		/* Announce our presence (and possibly coordinate between multiple instances in the future */
-
-const char *beacon_arg = NULL;
+static bool beacon = false;
+int beacon_interval = 1000;	/* Default Hello interval in Milliseconds */
+unsigned sessionid;		/* Random Number for this session */
 
 #define BEACON_MCS 500
 
@@ -54,52 +56,118 @@ struct beacon_mc {
 };
 
 /*
- * Beacon processing
+ * Multicast state in the beacon packet
+ */
+struct beacon_multicast {
+	struct in_addr group;
+	bool sendonly[2];
+	uint8_t tos_mode;
+	uint8_t mgid_mode;
+	uint16_t port;
+};
+
+/*
+ * Beacon info
  */
 struct beacon_info {
 	unsigned long signature;
 	char version[10];
+	unsigned sessionid;
+	unsigned hold_time;		/* Validity of the Beacon Info */
+	unsigned sqn;
+	uint64_t timestamp;
 	bool infiniband;
-	uint16_t beacon_port;
-	struct in_addr beacon_mc;
-	uint64_t t;
-	unsigned gateway_qp;
-	struct in_addr bridge_addr;		/* Where is the local bridge */
-	struct in_addr to_addr;			/* To which address is it bridging */
-	unsigned nr_mc;				/* Active Multicast */
-	unsigned nr_tsi;			/* Active TSIs */
-	struct beacon_mc mc[500];
+	struct in_addr addr[2];		/* Addresses of the bridge */
+	unsigned nr_mc;			/* Active Multicast */
+	unsigned nr_tsi;		/* Active TSIs */
+	struct beacon_multicast mc[];	/* nr_mc beacon_jp_multicast instances follow */
+};
+
+/*
+ * Remote bridge states: This is controlled by the beacons that will refresh
+ * the expiration time. If the expiration occurs then the bridge will take subscribe
+ * to all the multicast groups of that bridge.
+ * If a new beacon is encoutered from that bridge then there will be an unsubscribe.
+ */
+struct bridge_state {
+	unsigned long expiration;
+	bool active;
+	struct in_addr origin[2];
+	unsigned beacons_missed;
+	unsigned beacons_received;
+	struct beacon_info last;
 };
 
+#define MAX_BRIDGES 10
+static struct bridge_state remote_bridge[MAX_BRIDGES];
+
+static unsigned int nr_bridges;
+
 static struct mc *beacon_mc;		/* == NULL if unicast */
 static struct sockaddr_in *beacon_sin;
 
-static void prep_beacon_struct(struct i2r_interface *i, struct beacon_info *b)
+static void enable_bridge(struct bridge_state *b)
+{
+	logg(LOG_INFO, "Taking over for bridge on %s\n", inet_ntoa(b->origin[0]));
+
+	/* Subscribe to all MC groups of the specified group */
+	b->active = true;
+}
+
+static void disable_bridge(struct bridge_state *b)
 {
+	logg(LOG_INFO, "Stopping to bridge for %s\n", inet_ntoa(b->origin[0]));
+	/* Unsubscripe from all MC groups of the specified bridge */
+	b->active = false;
+}
+
+static void check_remote_bridges(void)
+{
+	struct bridge_state *b;
+
+	now = timestamp();
+
+	for(b = remote_bridge; b < remote_bridge + nr_bridges; b++)
+		if (b->active && b->expiration && now > b->expiration)
+		{
+			enable_bridge(b);
+		}
+}
+
+static void prep_beacon_struct(struct i2r_interface *i, struct buf *buf)
+{
+	struct beacon_info *b = (void *)buf->raw;
 	enum interfaces in = i - i2r;
 	struct mc *m;
 
+	buf->cur = buf->raw + sizeof(struct beacon_info);
+
 	b->signature = BEACON_SIGNATURE;
 	memcpy(b->version, VERSION, 10);
 	b->infiniband = in == INFINIBAND;
-	b->beacon_port = beacon_sin->sin_port;
-	b->beacon_mc = beacon_sin->sin_addr;
-	b->bridge_addr = i2r[in].if_addr.sin_addr;
-	b->to_addr = i2r[in^1].if_addr.sin_addr;
+	b->sessionid = sessionid;
+	b->addr[INFINIBAND] = i2r[INFINIBAND].if_addr.sin_addr;
+	b->addr[ROCE] = i2r[ROCE].if_addr.sin_addr;
+	b->hold_time = beacon_interval * 3 + beacon_interval / 2;
 	b->nr_mc = nr_mc;
 	b->nr_tsi = i2r[INFINIBAND].nr_tsi;
 	if (b->nr_tsi < i2r[ROCE].nr_tsi)
 		b->nr_tsi = i2r[ROCE].nr_tsi;
 
 	for(m = mcs; m < mcs + nr_mc; m++) {
-		b->mc[m - mcs].addr = m->addr;
-		b->mc[m - mcs].port = m->port;
+		memcpy(buf->cur, &m->addr, sizeof(struct in_addr));
+		buf->cur += sizeof(struct in_addr);
+		memcpy(buf->cur, &m->port, sizeof(unsigned));
+		buf->cur += sizeof(unsigned);
 	}
+	b->timestamp = now = timestamp();
+	buf->end = buf->cur;
 }
 
 static void beacon_received(struct mc *m, enum interfaces in, struct buf *buf)
 {
 	struct beacon_info *b = (struct beacon_info *)buf->cur;
+	struct bridge_state *r;
 	char bridge[40];
 	uint64_t diff;
 
@@ -109,17 +177,67 @@ static void beacon_received(struct mc *m
 	}
 
 	now = timestamp();
-	strcpy(bridge, inet_ntoa(b->bridge_addr));
-	diff = b->t - now;
+	if (buf->ip_valid) {
+		struct in_addr x;
+
+		x.s_addr = buf->ip.saddr;
+		strcpy(bridge, inet_ntoa(x));
+	}
+	else
+		inet_ntop(AF_INET6, &buf->grh.sgid, bridge, INET6_ADDRSTRLEN);
+
+	diff = b->timestamp - now;
 
-	logg(LOG_NOTICE, "Received Beacon on %s Version %s Bridge=%s(%s), BridgeTo=%s MC groups=%u, TSIs=%d. Latency %ld ns GatewayQP=%u\n",
+	logg(LOG_NOTICE, "Received Beacon on %s Version %s Bridge=%s(%s), Bridge=%s MC groups=%u, TSIs=%d. Latency %ld ns\n",
 		beacon_mc->text, b->version, bridge, b->infiniband ? "Infiniband" : "ROCE",
-		inet_ntoa(b->to_addr), b->nr_mc, b->nr_tsi, diff, b->gateway_qp);
+		inet_ntoa(b->addr[0]), b->nr_mc, b->nr_tsi, diff);
+
+	/* See if we already have that bridge */
+	for(r = remote_bridge; r < remote_bridge + nr_bridges; r++)
+		if (r->origin[0].s_addr == b->addr[0].s_addr && r->origin[1].s_addr == b->addr[1].s_addr)
+			break;
+
+	if (r < remote_bridge + nr_bridges) {
+		if (nr_bridges < MAX_BRIDGES) {
+			/* New bridge */
+			nr_bridges++;
+			r->active = false;
+			r->origin[0] = b->addr[0];
+			r->origin[1] = b->addr[1];
+
+		} else {
+			logg(LOG_ERR, "Too many bridges. Max is %d\n", MAX_BRIDGES);
+			return;
+		}
+	}
+	
+	r->beacons_received++;
+	if (r->last.sqn && r->last.sqn != b->sqn) {
+		int missed = b->sqn - r->last.sqn + 1;
+
+		r->beacons_missed++;
+		logg(LOG_NOTICE, "%d beacons missed on %s\n", missed, buf->c->i->text);
+	}
+
+	if (!b->hold_time) {	/* Remote request to forget all information */
+
+		r->expiration = 0;	/* That means it is exempt from expiration scans */
+
+		if (r->active)
+			disable_bridge(r);
+
+		return;
+	}
+	if (r->active) {
+		/* Received a beacon for a bridge that we took over */
+		disable_bridge(r);
+	}
+	memcpy(&r->last, b, sizeof(struct beacon_info));
+	r->expiration = timestamp() + milliseconds(b->hold_time);
 }
 
 static void beacon_send(void *private)
 {
-	struct beacon_info b;
 	struct buf *buf;
 
 	if (beacon_mc) {
@@ -127,23 +245,15 @@ static void beacon_send(void *private)
 
 		for(in = 0; in < NR_INTERFACES; in++) {
 			struct i2r_interface *i = i2r + in;
-			prep_beacon_struct(i, &b);
-			b.t = now = timestamp();
-
-
 			if (i->context && beacon_mc->interface[in].status == MC_JOINED) {
-				if (sizeof(b) > MAX_INLINE_DATA) {
-					buf = alloc_buffer(i->multicast);
-					memcpy(buf->raw, &b, sizeof(b));
-					send_to(i->multicast, buf, sizeof(b), &beacon_mc->interface[in].ai, false, 0, buf);
-				} else
-					send_inline(i->multicast, &b, sizeof(b), &beacon_mc->interface[in].ai, false, 0);
+
+				buf = alloc_buffer(i->multicast);
+				prep_beacon_struct(i, buf);
+				send_to(i->multicast, buf->raw, buf->end - buf->raw, &beacon_mc->interface[in].ai, false, 0, buf);
 			}
 		}
 
-	}
-#ifdef UNICAST
-	else {
+	} else { /* Unicast */
 		struct i2r_interface *i = find_interface(beacon_sin);
 
 		if (!i) {
@@ -152,18 +262,25 @@ static void beacon_send(void *private)
 			return;
 		}
 		buf = alloc_buffer(i->multicast);
-		prep_beacon_struct(i, &b);
-		memcpy(buf->raw, &b, sizeof(b));
+		prep_beacon_struct(i, buf);
 
 		reset_flags(buf);
 		buf->cur = buf->raw;
-		buf->end = buf->cur + sizeof(b);
-
+		buf->end = buf->cur + sizeof(struct beacon_info);
 		send_buf_to(i, buf, beacon_sin);
 
 	}
-#endif
-	add_event(timestamp() + seconds(10), beacon_send, NULL, "Send Beacon");
+
+	check_remote_bridges();
+	if (beacon_interval)
+		add_event(timestamp() + milliseconds(beacon_interval), beacon_send, NULL, "Send Beacon");
+}
+
+void beacon_shutdown(void)
+{
+	/* Send a beacon with a 0 hold time to expire all information at the other bridges */
+	beacon_interval = 0;
+	beacon_send(NULL);
 }
 
 void beacon_setup(void)
@@ -175,17 +292,14 @@ void beacon_setup(void)
 	if (!beacon)
 		return;
 
-	if (!beacon_arg)
-		beacon_arg = "239.1.2.3";
-
 	beacon_mc = NULL;
-	beacon_sin = parse_addr(beacon_arg, default_mc_port, &mgid, &tos, false);
+	beacon_sin = parse_addr(BEACON_MC_ADDR, BEACON_PORT, &mgid, &tos, false);
 	addr = beacon_sin->sin_addr;
 	if (IN_MULTICAST(ntohl(addr.s_addr))) {
 		struct mc *m = mcs + nr_mc++;
 
 		memset(m, 0, sizeof(*m));
-		m->text = strdup(beacon_arg);
+		m->text = BEACON_MC_ADDR;
 		m->mgid_mode = mgid;
 		m->tos_mode = tos;
 		m->addr = addr;
@@ -199,21 +313,72 @@ void beacon_setup(void)
 			beacon_sin = NULL;
 		} else
 			beacon_mc = m;
+
 		m->callback = beacon_received;
 	}
-	add_event(timestamp() + ONE_SECOND, beacon_send, NULL, "Send Beacon");
+
+	/*
+	 * First hello should have a random interval offset for each bridge if multiple
+	 * are starting up simultaneously.
+	 *
+	 * Also the first hello is delayed to ensure the bridges are all up and running
+	 * and have stabilized.
+	 */
+	add_event(timestamp() + seconds(5) + rand() % beacon_interval,
+			beacon_send, NULL, "Send Beacon");
 }
 
 static void beacon_option(char *optarg)
 {
 	beacon = true;
 
-	beacon_arg = optarg;
+	if (optarg)
+		beacon_interval = atoi(optarg);
+}
+
+/* Print the bridge states */
+static void beacon_cmd(char *parameters)
+{
+	struct bridge_state *b;
+
+	if (!nr_bridges) {
+		printf("No remote bridges detected\n");
+		return;
+	}
+	
+	printf("Nr|Origin   |SessID|Time to Expire|Active |Received | Missed\n");
+	printf("--+---------+------+--------------+-------+---------+-------\n");
+
+	for(b = remote_bridge; b < remote_bridge + nr_bridges; b++) {
+		char ex[30];
+		char origin_roce[INET_ADDRSTRLEN];
+
+		if (b->expiration && b->expiration > now)
+			sprintf(ex, "%ld ms", (b->expiration - now / ONE_MILLISECOND));
+		else
+			strcpy(ex, "Expired");
+		
+		inet_ntop(AF_INET, &b->origin[ROCE], origin_roce, INET_ADDRSTRLEN);
+
+		printf("%2ld|%20s/%20s|%10x|%s|%s|%10d|%10d\n",
+				(b - remote_bridge) + 1,
+				inet_ntoa(b->origin[INFINIBAND]),
+				origin_roce,
+				b->last.sessionid,
+				ex,
+				b->active ? "Bridging" : "Monitoring",
+				b->beacons_received,
+				b->beacons_missed);
+	}
 }
 
 __attribute__((constructor))
 static void beacon_init(void) {
 	register_option("beacon", optional_argument, 'b', beacon_option,
-			"<multicast address>/<unicast address>", "Send beacon every second. Off by default");
+			"<time in milliseconds>", "Send beacon in given milliseconds. 1 second by default");
+	register_enable("beaconinterval", true, NULL, &beacon_interval, "100", "0", NULL, "Beacon Interval");
+	register_concom("beacons", true, 0, "Show Beacon info", beacon_cmd);
+
+	sessionid = rand();
 }
 
Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -1315,22 +1315,6 @@ static void status_write(void *private)
 }
 
 #ifdef UNICAST
-/* A mini router follows */
-static struct i2r_interface *find_interface(struct sockaddr_in *sin)
-{
-	struct i2r_interface *i;
-
-	for(i = i2r; i < i2r + NR_INTERFACES; i++)
-	    if (i->context) {
-		unsigned netmask = i->if_netmask.sin_addr.s_addr;
-
-		if ((sin->sin_addr.s_addr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask))
-			return i;
-	}
-
-	return NULL;
-}
-
 /* Ship a unicast datagram to an IP address .... */
 static void send_buf_to(struct i2r_interface *i, struct buf *buf, struct sockaddr_in *sin)
 {
@@ -1707,6 +1691,7 @@ int main(int argc, char **argv)
 	if (event_loop() <0)
 		logg(LOG_ERR, "Event Loop failed with %s\n", errname());
 
+	beacon_shutdown();
 	stop_cores();
 
 	if (background)
Index: rdma-core/ib2roce/interfaces.c
===================================================================
--- rdma-core.orig/ib2roce/interfaces.c
+++ rdma-core/ib2roce/interfaces.c
@@ -863,7 +863,7 @@ void post_receive_buffers(void)
 }
 
 
-static void reset_flags(struct buf *buf)
+void reset_flags(struct buf *buf)
 {
 	memset(&buf->ip_valid, 0, (void *)&buf->ip_csum_ok - (void *)&buf->ip_valid);
 }
@@ -1057,6 +1057,23 @@ void handle_receive_packet(void *private
 	put_buf(buf);
 }
 
+/* A mini router follows */
+struct i2r_interface *find_interface(struct sockaddr_in *sin)
+{
+	struct i2r_interface *i;
+
+	for(i = i2r; i < i2r + NR_INTERFACES; i++)
+	    if (i->context) {
+		unsigned netmask = i->if_netmask.sin_addr.s_addr;
+
+		if ((sin->sin_addr.s_addr & netmask) ==  (i->if_addr.sin_addr.s_addr & netmask))
+			return i;
+	}
+
+	return NULL;
+}
+
+
 static unsigned show_interfaces(char *b)
 {
 	struct i2r_interface *i;
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- rdma-core.orig/ib2roce/interfaces.h
+++ rdma-core/ib2roce/interfaces.h
@@ -136,11 +136,15 @@ void set_rates(void);
 /* Scan a cores rdma channels for completion queue entries */
 void scan_cqs(void *private);
 
+void reset_flags(struct buf *);
+
 int check_rdma_device(enum interfaces i, int port, char *name,
 	       struct ibv_context *c, struct ibv_port_attr *a, struct ibv_device_attr *d);
 
 /* Scan through available RDMA devices in order to locate the devices for bridging */
 int find_rdma_devices(void);
+/* Find the interface that allows us to reach a certain IP address */
+struct i2r_interface *find_interface(struct sockaddr_in *sin);
 
 void check_out_of_buffer(void *);
 
Index: rdma-core/ib2roce/buffers.c
===================================================================
--- rdma-core.orig/ib2roce/buffers.c
+++ rdma-core/ib2roce/buffers.c
@@ -43,6 +43,7 @@
 #include "buffers.h"
 #include "endpoint.h"
 #include "cli.h"
+#include "hash.h"
 
 #include <sys/mman.h>
 #include <stdatomic.h>
@@ -455,6 +456,94 @@ int send_buf(struct buf *buf, struct rdm
 }
 
 
+static unsigned keylength[nr_hashes] = { 4, 6, 16, 2 };
+
+struct rdma_unicast *hash_table[nr_hashes][0x100];
+
+static unsigned generate_hash_key(enum hashes type, uint8_t *key, void *p)
+{
+	int i;
+	unsigned sum = 0;
+
+	memcpy(key, p, keylength[type]);
+
+	for (i = 0; i < keylength[type]; i++)
+		sum += key[i];
+
+	return sum & 0xff;
+}
+
+static struct rdma_unicast *find_key_in_chain(enum hashes type,
+	struct rdma_unicast *next, uint8_t *key)
+{
+	for ( ; next != NULL; next = next->hash[type].next)
+		if (memcmp(key, next->hash[type].key, keylength[type]) == 0)
+			break;
+
+	return next;
+}
+
+static void add_to_hash(struct rdma_unicast *ra, enum hashes type, void *p)
+{
+	struct hash_item *h = &ra->hash[type];
+
+	if (h->member)
+		abort();        /* Already a member of the hash */
+
+	h->hash = generate_hash_key(type, h->key, p);
+
+	/* Duplicate key ? */
+	if (find_key_in_chain(type, hash_table[type][h->hash], h->key))
+		abort();
+
+	h->next = hash_table[type][h->hash];
+	hash_table[type][h->hash] = ra;
+
+	h->member = true;
+}
+
+static struct rdma_unicast *find_in_hash(enum hashes type, void *p)
+{
+	uint8_t key[hash_max_keylen];
+	unsigned hash;
+
+	hash = generate_hash_key(type, key, p);
+
+	return find_key_in_chain(type, hash_table[type][hash], key);
+}
+
+/* Ship a unicast datagram to an IP address .... */
+void send_buf_to(struct i2r_interface *i, struct buf *buf, struct sockaddr_in *sin)
+{
+	struct rdma_unicast *ra;
+	int ret;
+
+	/* Find address */
+	ra = find_in_hash(hash_ip, &sin->sin_addr);
+	if (!ra) {
+		ra = new_rdma_unicast(i, sin);
+		add_to_hash(ra, hash_ip, &sin->sin_addr);
+	}
+
+	switch (ra->state) {
+		case UC_NONE:   /* We need to resolve the address. Queue up the buffer and initiate */
+			fifo_put(&ra->pending, buf);
+			resolve(ra);
+			return;
+
+		case UC_CONNECTED: /* Channel is open. We can send now */
+			ret = send_buf(buf, ra);
+			if (!ret)
+				logg(LOG_ERR, "Failed to send to %s:%d\n",
+				inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));
+			return;
+
+		default:                /* Resolution is in progress. Just queue it up on the address */
+			fifo_put(&ra->pending, buf);
+			return;
+	}
+}
+
 static void buffers_cmd(char *parameters)
 {
 	struct buf *buf;
Index: rdma-core/ib2roce/beacon.h
===================================================================
--- rdma-core.orig/ib2roce/beacon.h
+++ rdma-core/ib2roce/beacon.h
@@ -38,5 +38,5 @@
  */
 
 void beacon_setup(void);
-
+void beacon_shutdown(void);
 #endif
Index: rdma-core/ib2roce/endpoint.h
===================================================================
--- rdma-core.orig/ib2roce/endpoint.h
+++ rdma-core/ib2roce/endpoint.h
@@ -80,6 +80,18 @@ void list_endpoints(struct i2r_interface
 
 enum uc_state { UC_NONE, UC_ADDR_REQ, UC_ROUTE_REQ, UC_CONN_REQ, UC_CONNECTED, UC_ERROR };
 
+/* Enough to fit a GID */
+#define hash_max_keylen 16
+
+struct hash_item {
+	struct rdma_unicast *next;      /* Linked list to avoid collisions */
+	unsigned hash;
+	bool member;
+	uint8_t key[hash_max_keylen];
+};
+
+enum hashes { hash_ip, hash_mac, hash_gid, hash_lid, nr_hashes };
+
 struct rdma_unicast {
 	struct i2r_interface *i;
 	enum uc_state state;
@@ -87,6 +99,7 @@ struct rdma_unicast {
 	struct rdma_channel *c;		/* Channel for resolution and I/O */
 	struct fifo pending;		/* Buffers waiting on resolution to complete */
 	struct ah_info ai;		/* If ai.ah != NULL then the address info is valid */
+	struct hash_item hash[nr_hashes];
 };
 
 struct rdma_unicast *new_rdma_unicast(struct i2r_interface *i, struct sockaddr_in *sin);
Index: rdma-core/ib2roce/multicast.h
===================================================================
--- rdma-core.orig/ib2roce/multicast.h
+++ rdma-core/ib2roce/multicast.h
@@ -92,10 +92,14 @@ struct mc_interface {
 	unsigned long delayed;		/* Packets delayed */
 };
 
+struct bridge_state;
+
 struct mc {
 	struct in_addr addr;
 	struct mc_interface interface[2];
 	void (*callback)(struct mc *, enum interfaces, struct buf *);
+	struct bridge *bridge_state;		/* Set if its a remote bridge */
+	bool enabled;				/* Is forwarding active ? */
 	uint8_t tos_mode;
 	uint16_t port;
 	struct mgid_signature *mgid_mode;
