Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -111,6 +111,7 @@ static bool packet_socket = false;	/* Do
 static bool loopback_blocking = true;	/* Ask for loopback blocking on Multicast QPs */
 static int drop_packets = 0;		/* Packet dropper */
 static int rate = 0;			/* Limit sending rate */
+static bool parse_pgm = false;		/* Parse all packets as if they were PGM packets */
 
 /* Timestamp in milliseconds */
 static unsigned long timestamp(void)
@@ -2805,6 +2806,359 @@ static unsigned int remove_forwards(stru
 	return n;
 }
 
+struct nak {
+	struct pgm_nak *next;
+	unsigned sqn;
+	bool nak_sent;
+	bool ncf_sent;
+	bool nnak_sent;
+};
+
+struct pgm_key {
+	struct in_addr mcgroup;
+	union {
+		struct {
+			struct in_addr sender;
+			uint16_t source_port;
+		};
+		uint8_t gsi[6];
+	};
+};
+
+/* Stream information */
+struct pgm_stream {
+	struct pgm_key key;	
+	struct i2r_interface *i;	/* Interface of the source */
+	const char *text;
+	unsigned trail;			/* Sender trail */
+	unsigned lead;			/* Sender lead */
+
+	unsigned last;			/* Highest SQN received */
+	unsigned last_seq;		/* Last in sequence */
+	unsigned oldest;		/* The oldest message available locally */
+	struct nak *nak;
+};
+
+/* Records (ODATA/RDATA) in a stream */
+struct pgm_record {
+	struct pgm_key key;
+	uint32_t sqn;			/* Message ID  */
+	struct pgm_stream *stream;	
+	struct buf *buf;		/* Address of buffer */
+	void *start;			/* Beginning of ODATA/RDATA record */
+	unsigned len;			/* Length of the message */
+};
+
+struct hash *pgm_hash;
+struct hash *pgm_record;
+
+static void init_pgm_streams(void)
+{
+	pgm_hash = hash_create(0, sizeof(struct pgm_key));
+	pgm_record = hash_create(0, sizeof(struct pgm_key) + sizeof(uint32_t));
+}
+
+static bool add_record(struct buf *buf, struct pgm_key *key, uint32_t sqn, void *start, unsigned len)
+{
+	struct pgm_record *r = calloc(1, sizeof(pgm_record));
+
+	r->key = *key;
+	r->sqn = sqn;
+	r->buf = buf;
+	r->start = start;
+	r->len = len;
+
+	lock();
+	if (hash_find(pgm_record, &r)) {
+		unlock();
+		return false;
+	} else {
+		get_buf(buf);
+		hash_add(pgm_record, &r);
+		unlock();
+		return true;
+	}
+}
+
+static struct pgm_record *find_record(struct pgm_key *key, uint32_t sqn)
+{
+	struct pgm_record f = { .key = *key, .sqn = sqn };
+
+	return hash_find(pgm_record, &f);
+}
+
+/* Forwarded packet if ib2roce behaves like a DLR */
+static void forward_packet(struct buf *buf, struct pgm_key *key, uint32_t sqn)
+{
+}
+
+/* Packet delivery in sequence */
+static void deliver_in_seq(struct buf *buf, struct pgm_key *key, uint32_t sqn)
+{
+}
+
+static const char *format_stream_text(struct i2r_interface *i, struct mc *m, struct pgm_key *key)
+{
+	static char b[50];
+
+	snprintf(b, sizeof(b), "%s(%s):%d", m->text, inet_ntoa(key->sender), key->source_port);
+	return strdup(b);
+}
+
+static void pgm_out(struct i2r_interface *i, struct mc *m, struct buf *buf)
+{
+	struct pgm_key key;
+	struct pgm_stream *s;
+	uint32_t sqn;
+	uint8_t *start;
+	uint16_t total_opt_length = 0;
+	union {
+		struct pgm_header pgm;
+		struct {
+			uint8_t skip[8];
+			struct in_addr addr;
+			uint16_t port;
+		};
+	} header;
+	struct pgm_spm spm;
+	struct pgm_data data;
+	struct pgm_nak nak;
+#if 0
+	struct pgm_poll poll;
+	struct pgm_polr polr;
+#endif
+	struct pgm_ack ack;
+redo:
+	start = buf->cur;
+	PULL(buf, header);
+
+	memcpy(key.gsi, header.pgm.pgm_gsi, sizeof(key.gsi));
+	key.mcgroup = m->addr;
+	s = hash_find(pgm_hash, &key);
+
+	if (!s) {
+		lock();
+		s = hash_find(pgm_hash, &key);
+		if (!s) {
+			s = calloc(1, sizeof(struct pgm_stream));
+			s->key = key;
+			s->i = i;
+			s->text = format_stream_text(i, m, &key);
+
+			logg(LOG_NOTICE, "%s: New Stream %s\n", i->text, s->text);
+		}
+		unlock();
+	}	
+
+	if (header.pgm.pgm_options & 0x1) {
+		bool last = false;
+		uint8_t *opt_start = buf->cur;
+
+		do {
+			struct pgm_opt_header opt;
+			struct pgm_opt_length length;
+			struct pgm_opt_fragment fragment;
+			struct pgm_opt_nak_list nak_list;
+			struct pgm_opt_join join;
+			struct pgm_opt_redirect redirect;
+			struct pgm_opt_fin fin;
+			struct pgm_opt_syn syn;
+			struct pgm_opt_rst rst;
+			void *start_opt = buf->cur;
+
+			PULL(buf, opt);
+			last = opt.opt_type & PGM_OPT_END;
+			switch (opt.opt_type & PGM_OPT_MASK) {
+				case PGM_OPT_LENGTH:
+					PULL(buf, length);
+					total_opt_length = length.opt_total_length;
+					break;
+				case PGM_OPT_FRAGMENT:
+					PULL(buf, fragment);
+					logg(LOG_NOTICE, "%s: OPT Fragment SQN=%x offset=%d len=%d\n", s->text,
+						fragment.opt_sqn, fragment.opt_frag_off, fragment.opt_frag_len);
+					break;
+				case PGM_OPT_NAK_LIST:
+					PULL(buf, nak_list);
+					logg(LOG_NOTICE, "%s: OPT NAK list #%d\n", s->text, (opt.opt_length - 1) /4 );
+
+					break;
+				case PGM_OPT_JOIN:
+					PULL(buf, join);
+					logg(LOG_NOTICE, "%s: OPT Join MIN SQN=%d\n",
+							s->text, join.opt_join_min);
+					break;
+				case PGM_OPT_REDIRECT:
+					PULL(buf, redirect);
+
+					logg(LOG_NOTICE, "%s: OPT Redirect NLA=%s\n", s->text, inet_ntoa(redirect.opt_nla));
+					break;
+
+				/* Not sure if these options are in use.  They are mostly not necessary (?) */
+				case PGM_OPT_SYN:
+					PULL(buf, syn);
+					logg(LOG_NOTICE, "%s: OPT SYN\n", s->text);
+					break;
+				case PGM_OPT_FIN:
+					PULL(buf, fin);
+					logg(LOG_NOTICE, "%s: OPT FIN\n", s->text);
+					break;
+				case PGM_OPT_RST:
+					PULL(buf, rst);
+					logg(LOG_NOTICE, "%s: OPT RST\n", s->text);
+					break;
+
+				/* NAK Intervals */
+				case PGM_OPT_NAK_BO_IVL:
+				case PGM_OPT_NAK_BO_RNG:
+
+				/* NLA redirection */
+				case PGM_OPT_PATH_NLA:
+
+				/* Broken Multicast ??? */
+				case PGM_OPT_NBR_UNREACH:
+
+				case PGM_OPT_INVALID:
+
+				/* Congestion "Control" and avoidance. Traffic load feedback */
+				case PGM_OPT_CR:
+				case PGM_OPT_CRQST:
+
+				/* Forward Error correction.... How would this work ??? */
+				case PGM_OPT_PARITY_PRM:
+				case PGM_OPT_PARITY_GRP:
+				case PGM_OPT_CURR_TGSIZE:
+
+				/* Extensions by PGMCC */
+				case PGM_OPT_PGMCC_DATA:
+				case PGM_OPT_PGMCC_FEEDBACK:
+
+				default: 
+					logg(LOG_NOTICE, "%s: Invalid PGM option=%x. Option Skipped.\n", s->text, opt.opt_type);
+					return;
+			}
+			buf->cur = start_opt + opt.opt_length;
+		} while (!last);
+
+		if (total_opt_length != buf->cur - opt_start)
+			logg(LOG_NOTICE, "%s: Option length mismatch. Expected %d but it is %ld\n", s->text, total_opt_length, buf->cur - opt_start);
+	}
+
+	switch (header.pgm.pgm_type) {
+		case PGM_SPM:		/* Multicast downstream */
+			PULL(buf, spm);
+			logg(LOG_NOTICE, "%s: SPM SQN=%x TRAIL=%x LEAD=%x NLA=%s\n",
+				s->text, spm.spm_sqn, spm.spm_trail, spm.spm_lead, inet_ntoa(spm.spm_nla));
+			s->trail = spm.spm_trail;
+			s->lead = spm.spm_lead;
+			if (s->last_seq < s->lead) {
+				/* We are missing packets */
+			}
+			break;
+
+/* 		These may not exist although described in the RFC. There is no definition of the spmr struct available
+		case PGM_SPMR:		Unicast upstream
+			PULL(buf, spmr);
+			break;
+*/
+		case PGM_ODATA:		/* Multicast downstream */
+		case PGM_RDATA:		/* Multicast downstream */
+			PULL(buf, data);
+			logg(LOG_NOTICE, "%s: O/RDATA SQN=%x TRAIL=%x\n", s->text, data.data_sqn, data.data_trail);
+
+			sqn = data.data_sqn;
+
+			if (sqn < s->last_seq)
+				/* Old repeated data */
+				break;
+
+			if (!add_record(buf, &key, sqn, start, sizeof(struct pgm_header) + total_opt_length + header.pgm.pgm_tsdu_length))
+		       		/* Not so old but this is a record we already have */
+				break;
+	
+			/* Move tail/lead */
+			if (data.data_trail > s->trail)
+				s->trail = data.data_trail;
+
+			if (sqn > s->lead)
+				s->lead = data.data_sqn;
+
+			if (sqn == s->last_seq + 1 || !s->last_seq) {
+				/* The next packet that we need ! */
+				s->last_seq = sqn;
+				forward_packet(buf, &key, sqn);
+				deliver_in_seq(buf, &key, sqn);
+
+				if (s->last + 1 == sqn || !s->last) {
+					/* Perfect this is the way it should be. Consistent history */
+					s->last = sqn;
+				} else {
+					/* We just filled up in a missing piece check how long our consistent history goes now */
+					while (s->last_seq <= s->last) {
+						struct pgm_record *r = find_record(&key, s->last_seq + 1);
+						if (r) {
+							deliver_in_seq(r->buf, &key, s->last_seq + 1);
+							s->last_seq++;
+						} else
+							break;
+					}
+					/* If this was RDATA and there still is a hole then send NAK */
+				}
+			} else { /* We have received some future record */
+				forward_packet(buf, &key, sqn);
+				s->last = sqn;
+				/* We have opened up some hole between s->last_seq and s->last. Could send NAK */
+
+				/* s->last_seq ... s->last -1 is missing at this point */
+
+				if (s->last_seq < s->trail) {
+					/* Unrecoverable packet loss */
+				} else {
+					/* Send NAK */
+				}
+			}
+
+			break;
+
+		case PGM_NAK:		/* Unicast upstream */
+		case PGM_NCF:		/* Multicast downstream */
+		case PGM_NNAK:		/* Unicast upstream DLR ->source */
+			PULL(buf, nak);
+			logg(LOG_NOTICE, "%s: NAK/NCF/NNAK SQN=%x NLA=%s GRP_NLA=%s\n",
+				s->text, nak.nak_sqn, inet_ntoa(nak.nak_src_nla),
+				inet_ntoa(nak.nak_grp_nla));
+			break;
+
+#if 0
+		/* Is POLL really used I do not know of a DLR */
+		case PGM_POLL:		/* DLR downstream multicast */
+			PULL(buf, poll);
+			logg(LOG_NOTICE, "%s: POLL\n", s->text);
+			break;
+
+		case PGM_POLR:		/* Unicast response upstream to DLR */
+			PULL(buf, polr);
+			logg(LOG_NOTICE, "%s: POLR\n", s->text);
+			break;
+#endif
+
+		/* Not RFC compliant but it seems to be used sometimes */
+		case PGM_ACK:		/* Unicast upstream */
+			PULL(buf, ack);
+			logg(LOG_NOTICE, "%s: ACK RX_MAX=%x BITMAP=%x\n", s->text, ack.ack_rx_max, ack.ack_bitmap);
+			break;
+
+		default:
+			logg(LOG_NOTICE, "%s: Invalid PGM type=%x. Packet Skipped.\n", buf->c->text, header.pgm.pgm_type);
+			return;
+	}
+
+	buf->cur = start + sizeof(struct pgm_header) + total_opt_length + header.pgm.pgm_tsdu_length;
+	if (buf->cur < buf->end)
+		goto redo;
+
+}
+
 #if 0
 /*
  * Update the forwarder if the source point changes
@@ -3198,6 +3552,10 @@ static void receive_multicast(struct buf
 		}
 	}
 
+	if (parse_pgm) {
+		pgm_out(c->i, m, buf);
+	}
+
 	if (m->beacon) {
 		beacon_received(buf);
 		return;
@@ -4857,6 +5215,7 @@ struct enable_option {
 {	"huge", &huge, NULL, "on", "off", "Enable the use of Huge memory for the packet pool" }, 
 {	"loopbackprev", &loopback_blocking, NULL, "on", "off", "Multicast loopback prevention of the NIC" },
 {	"packetsocket", &packet_socket, NULL, "on", "off", "Use a packet socket instead of a RAW QP to capure IB/ROCE traffic" },
+{	"pgm",	&parse_pgm, NULL, "on", "off", "Decode Payload following RFC 3208 PGM" },
 {	"rate", NULL, &rate, "2", "0", "Make RDMA limit the output speed 2 =2.5GBPS 5 = 5GBPS 3 = 10GBPS ...(see enum ibv_rate)" },
 { 	"raw", 	&raw, NULL, "on", "off", "Use of RAW sockets to capture SIDR Requests. Avoids having to use a patched kernel" },
 {	"unicast", &unicast, NULL, "on", "off", "Processing of unicast packets with QP1 handling of SIDR REQ/REP" },
@@ -5166,6 +5525,7 @@ int main(int argc, char **argv)
 			nr_mc, mgid_mode->id, nr_buffers);
 
 	init_buf();	/* Setup interface registers memmory */
+	init_pgm_streams();
 
 	setup_interface(INFINIBAND);
 	setup_interface(ROCE);
