Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -49,7 +49,6 @@
 #include <fcntl.h>
 #include <ctype.h>
 #include <pthread.h>
-#include <threads.h>
 #include <numa.h>
 #include <stdatomic.h>
 #include <arpa/inet.h>
@@ -80,6 +79,9 @@
 #include "fifo.h"
 #include "ring.h"
 #include "hash.h"
+#include "sched.h"
+#include "logging.h"
+
 #include "ibraw.h"
 #include "cma-hdr.h"
 
@@ -102,7 +104,6 @@ static unsigned default_port = 0;	/* Por
 static unsigned default_mc_port = 4711;	/* Port for MC groups that do not have a port (if a port is required) */
 static bool debug = false;		/* Stay in foreground, print more details */
 static bool background = false;		/* Are we actually running in the background ? */
-static bool terminated = false;		/* Daemon received a signal to terminate */
 static bool update_requested = false;	/* Received SIGUSR1. Dump all MC data details */
 static bool beacon = false;		/* Announce our presence (and possibly coordinate between multiple instances in the future */
 static bool bridging = true;		/* Allow briding */
@@ -123,32 +124,6 @@ static int irate = 0;			/* Software dela
 static int max_rburst = 10;		/* Dont delay until # of packets for ROCE */
 static int max_iburst = 10;		/* Dont delay until # of packets for Infiniband */
 static int stat_interval = 10;		/* Interval for statistics */
-static int loglevel = LOG_INFO;		/* LOG level for console output */
-
-#define ONE_SECOND (1000000000UL)
-#define ONE_MILLISECOND (ONE_SECOND/1000UL)
-#define ONE_MICROSECOND (1000UL)
-
-/* Conversion of constants to microseconds */
-#define seconds(x) ((x)*ONE_SECOND)
-#define milliseconds(x) ((x)*ONE_MILLISECOND)
-
-
-/* Timestamp in nanoseconds */
-static uint64_t timestamp(void)
-{
-	struct timespec t;
-
-	clock_gettime(CLOCK_REALTIME, &t);
-	return seconds(t.tv_sec) + t.tv_nsec;
-}
-
-#define cpu_relax()	asm volatile("rep; nop")
-
-thread_local uint64_t now;		/* We do not want contention on this one */
-
-__attribute__ ((format (printf, 2, 3)))
-static void logg(int prio, const char *fmt, ...);
 
 static const char *inet6_ntoa(void *x)
 {
@@ -157,10 +132,6 @@ static const char *inet6_ntoa(void *x)
 	return inet_ntop(AF_INET6, x, buf, INET6_ADDRSTRLEN);
 }
 
-__attribute__ ((format (printf, 1, 2)))
-static void panic(const char *fmt, ...);
-
-
 static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;		/* Generic serialization mutex */
 
 /* Is the lock taken */
@@ -250,74 +221,11 @@ uint8_t tos_mode = 0;
 
 static char *ib_name, *roce_name;
 
-enum interfaces { INFINIBAND, ROCE, NR_INTERFACES };
-
-static const char *interfaces_text[NR_INTERFACES] = { "Infiniband", "ROCE" };
-
-enum stats { packets_received, packets_sent, packets_bridged, packets_invalid, packets_queued,
-		join_requests, join_failure, join_success,
-		leave_requests,
-		pgm_dup, pgm_odata, pgm_rdata, pgm_spm, pgm_nak, pgm_ack,
-		nr_stats
-};
-
-static const char *stats_text[nr_stats] = {
-	"PacketsReceived", "PacketsSent", "PacketsBridged", "PacketsInvalid", "PacketsQueued",
-	"JoinRequests", "JoinFailures", "JoinSuccess", "LeaveRequests",
-	"pgmdup", "pgm_odata", "pgm_rdata", "pgm_spm", "pgm_nak"
-};
-
-enum channel_type { channel_rdmacm, channel_ud, channel_qp1,
-	channel_raw, channel_ibraw,
-	channel_packet, channel_incoming,
-	channel_err, nr_channel_types };
-
 struct buf;
 
-typedef void receive_callback(struct buf *);
 typedef void event_callback(void *);
 
 /*
- * Channel data stucture,
- *
- * Channels may be associated with a core on which a busyloop runs.
- *
- * Therefore changes to variables may only be made from code
- * running on that core if multithreading is active.
- */
-struct rdma_channel {
-	struct i2r_interface *i;	/* The network interface of this channel */
-	struct core_info *core;		/* Core the channel is on or NULL if comp_events is used */
-	receive_callback *receive;
-	struct ibv_cq *cq;		/* Every channel has a distinct CQ */
-	struct ibv_qp *qp;		/* All of the ibv_xxes are pointing to the interface versions if this is not a rdmacm channel */
-	struct ibv_mr *mr;
-	struct ibv_comp_channel *comp_events;
-	struct ibv_pd *pd;
-	struct ibv_flow *flow;
-	unsigned int active_receive_buffers;
-	unsigned int active_send_buffers;	/* if the sender is on a different core than the receiver then we have a race condition for the buffers */
-	unsigned int cq_high;		/* Largest number of CQs taken from the queue */
-	unsigned int nr_cq;		/* Number of items for the CQ */
-	unsigned int nr_send;		/* Maximum number of write buffers to use */
-	unsigned int nr_receive;	/* Number of read buffer to post */
-	unsigned stats[nr_stats];
-	enum channel_type type;
-	struct fifo send_queue;		/* Packets that were deferred for write */
-	bool listening;			/* rdmacm Channel is listening for connections */
-	const char *text;
-	struct rdma_unicast *ru;	/* Only rdmacm */
-	struct rdma_cm_id *id;		/* Only rdmacm */
-	struct sockaddr *bindaddr;	/* Only rdmacm */
-	struct ibv_qp_attr attr;	/* Only !rdmacm */
-	int fh;				/* Only channel_packet */
-	uint64_t last_snapshot;		/* when was the last snapshot taken */
-	unsigned last_received, last_sent;
-	unsigned pps_in, pps_out;	/* Rate in the last interval */
-	unsigned max_pps_in, max_pps_out; /* Max Rate seen */
-};
-
-/*
  * The forwarding struct describes the forwarding for datagrams
  * coming from a source QP to another QP at an endpoint.
  * This is singly linked list attache to the endpoints
@@ -428,15 +336,7 @@ struct rdma_unicast {
 #endif
 
 
-static inline void st(struct rdma_channel *c, enum stats s)
-{
-	c->stats[s]++;
-}
-
 /* Forwards */
-static void add_event(uint64_t  when, event_callback *callback, void *private, const char *text);
-static uint64_t run_events(void);
-static void register_callback(void (*callback)(void *), int fd, void *private);
 static void handle_comp_event(void *private);
 static void handle_rdma_event(void *private);
 static void handle_async_event(void *private);
@@ -1190,13 +1090,8 @@ struct channel_info {
  *
  */
 
-#define MAX_CORE 8
-#define MAX_CQS_PER_CORE 4
-
 static unsigned cores = 0;		/* How many cores can we consume */
 
-enum core_state { core_off, core_init, core_running, core_err, nr_core_states };
- 
 /*
  * Determine the core to be used for a channel
  */
@@ -1225,23 +1120,6 @@ nocore:
 }
 
 typedef void thread_callback(void *);
-thread_local struct core_info *current = NULL;
-
-struct core_info {
-	unsigned nr_channels;
-	struct rdma_channel channel[MAX_CQS_PER_CORE];
-	/* Statistics */
-	unsigned samples;
-	long sum_latency;
-	unsigned max_latency;
-	unsigned min_latency;
-	struct ring ring;
-	/* Rarely used */
-	enum core_state state;
-	int numa_node;
-	pthread_t thread;			/* Thread */
-	pthread_attr_t attr;
-} core_infos[MAX_CORE];
 
 static void show_core_config(void)
 {
@@ -1267,55 +1145,6 @@ static void show_core_config(void)
 	}
 }
 
-__attribute__ ((format (printf, 2, 3)))
-static void logg(int prio, const char *fmt, ...)
-{
-	va_list valist;
-
-	if ((prio & 0x7) > loglevel)
-		return;
-
-	va_start(valist, fmt);
-
-	if (current) {
-		int n;
-		char b[150];
-		b[0] = '0' + prio;
-
-		n = vsnprintf(b + 1, 149, fmt, valist);
-		ring_put(&current->ring, b, n);
-
-	} else if (background)
-		vsyslog(prio, fmt, valist);
-	else
-		vprintf(fmt, valist);
-}
-
-#define NR_FRAMES 100
-__attribute__ ((format (printf, 1, 2)))
-static void panic(const char *fmt, ...)
-{
-	va_list valist;
-	void *frames[NR_FRAMES];
-	int nrframes;
-	int j;
-	char **strings;
-
-	printf("IB2ROCE Panic: ");
-	va_start(valist, fmt);
-	vprintf(fmt, valist);
-	
-	nrframes = backtrace(frames, NR_FRAMES);
-	strings = backtrace_symbols(frames, nrframes);
-
-	for( j= 0; j < nrframes; j++) {
-		printf("%d. %s\n", j, strings[j]);
-	}
-	free(strings);
-	abort();
-}
-
-
 static struct rdma_channel *new_rdma_channel(struct i2r_interface *i, enum channel_type type)
 {
 	struct rdma_channel *c;
@@ -1410,18 +1239,39 @@ static void arm_channels(struct core_inf
  *
  * NOHZ should be enabled though to avoid hiccups from timer interrupts
  */
-static void *busyloop(void *private)
+static void scan_cqs(void *private)
 {
-	struct rdma_channel *c;
-	int cqs;
+	struct core_info *core = private;
 	int i;
-	unsigned cpu;
-
+	int cqs;
+	struct rdma_channel *c;
 	struct ibv_wc wc[10];
 
-	current = private;
+	for(i = 0; i < core->nr_channels; i++) {
+		cqs = ibv_poll_cq(core->channel[i].cq, 10, wc);
+		if (cqs) {
+			c = core->channel + i;
+
+			if (cqs > 0)
+				process_cqes(c, wc, cqs);
+			else {
+				logg(LOG_WARNING, "Busyloop: CQ polling failed with: %s on %s\n",
+						errname(), c->text);
+				core->state = core_err;
+				continue;
+			}
+		}
+	}
+}
+
+
+static void *busyloop(void *private)
+{
+	struct core_info *core = private;
+	unsigned cpu;
+
 	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
-	numa_run_on_node(current->numa_node);
+	numa_run_on_node(core->numa_node);
 
 	current->state = core_init;
 
@@ -1432,57 +1282,10 @@ static void *busyloop(void *private)
 	 * Initialize relevant data structures for this thread. These must be allocated
 	 * from the thread to ensure that they are thread local
 	 */
-	arm_channels(current);
-
-	current->state = core_running;
-
-	now = timestamp(); 	/* Will be done by run_events in the future */
-	do {
-		uint64_t tdiff;
-	
-		cpu_relax();
-		/* Scan CQs */
-		for(i = 0; i < current->nr_channels; i++) {
-			c = current->channel + i;
-			cqs = ibv_poll_cq(c->cq, 10, wc);
-			if (cqs) {
-
-				if (cqs > 0)
-					process_cqes(c, wc, cqs);
-				else {
-					logg(LOG_ERR, "Busyloop: CQ polling failed with: %s on %s\n",
-						errname(), c->text);
-					current->state = core_err;
-					continue;
-				}
-			}
-		}
-
-
-		if (latency) {
-			tdiff = timestamp() - now;
-
-			if (tdiff > current->max_latency)
-				current->max_latency = tdiff;
-			if (tdiff < current->min_latency || !current->min_latency)
-				current->min_latency = tdiff;
-
-			if (tdiff > 5000) {
-				current->sum_latency += tdiff;
-				current->samples++;
-				if (current->samples > 1000000000) {
-					current->samples = 1;
-					current->sum_latency = tdiff;
-				}
-				if (tdiff > ONE_MILLISECOND)
-					logg(LOG_NOTICE, "Busyloop took longer than a millisecond %ld\n", tdiff);
-			}
-		}
-
-		run_events();
-
-	} while (!terminated);
+	arm_channels(core);
 
+	core->state = core_running;
+	busy_event_loop(scan_cqs, core);
 	return NULL;
 }
 
@@ -5088,7 +4891,7 @@ static void handle_async_event(void *pri
 	 * We can make exceptions later.
 	 */
 
-	terminated = true;
+	terminate(0);
 
         ibv_ack_async_event(&event);
 }
@@ -5441,81 +5244,6 @@ static void beacon_setup(const char *opt
 	add_event(timestamp() + ONE_SECOND, beacon_send, NULL, "Send Beacon");
 }
 
-/* Events are timed according to nanoseconds in the current epoch */
-struct timed_event {
-	uint64_t time;		/* When should it occur */
-	event_callback *callback;	/* function to run */
-	void *private;
-	struct timed_event *next;	/* The following event */
-	const char *text;
-};
-
-/* Event queues for each of the threads */
-thread_local static struct timed_event *next_event;
-
-static void add_event(uint64_t time, event_callback *callback, void *private, const char *text)
-{
-	struct timed_event *t;
-	struct timed_event *prior = NULL;
-	struct timed_event *new_event;
-
-	new_event = calloc(1, sizeof(struct timed_event));
-	new_event->time = time;
-	new_event->callback = callback;
-	new_event->private = private;
-	new_event->text = text;
-
-	for(t = next_event; t && time > t->time; t = t->next)
-		prior = t;
-
-	new_event->next = t;
-
-	if (prior)
-		prior->next = new_event;
-	else
-		next_event = new_event;
-}
-
-static int64_t time_to_next_event(void)
-{
-	if (next_event)
-		return (long)next_event->time - (long)timestamp();
-	else
-		return 0;
-}
-
-/*
- * Run the next event if availabe and return the time till the next event
- * or 0 if there is none
- */
-static uint64_t run_events(void)
-{
-	now = timestamp();
-	while (next_event) {
-		struct timed_event *te = next_event;
-		uint64_t old_now;
-
-		if (te->time > now + ONE_MICROSECOND)
-			return te->time - now;
-	
-		/* Time is up for an event */
-		next_event = te->next;
-		te->callback(te->private);
-	
-		if (latency) {
-			old_now = now;
-			now = timestamp();
-			if (now - old_now > ONE_MILLISECOND)
-				logg(LOG_ERR, "Callback %s took %ld nanoseconds which is longer than a millisecond\n",
-					te->text, now-old_now);
-		}
-
-		free(te);
-	}
-	return 0;
-}
-
-
 static void check_joins(void *private)
 {
 	struct i2r_interface *i;
@@ -5578,15 +5306,14 @@ static void calculate_pps(void *private)
 
 static void brief_status(void)
 {
-	char buf[100];
-	char buf2[150];
+	char buf[4000];
+	char buf2[4200];
 	char counts[200];
 
 	unsigned n = 0;
 	const char *events;
 
-	for(struct timed_event *z = next_event; z; z = z->next)
-		n += sprintf(buf + n, "%ldms,", (z->time - timestamp()) / ONE_MILLISECOND);
+	n = get_timer_list(buf, ',');
 
 	if (n > 0)
 		buf[n -1] = 0;
@@ -5642,30 +5369,6 @@ static void logging(void *private)
 	add_event(timestamp() + seconds(10), logging, NULL, "Brief Status");
 }
 
-/*
- * Logic to support building a pollfd table for the event loop
- */
-#define MAX_POLL_ITEMS 20
-
-unsigned poll_items = 0;
-
-struct pollfd pfd[MAX_POLL_ITEMS];
-static void (*poll_callback[MAX_POLL_ITEMS])(void *);
-void *poll_private[MAX_POLL_ITEMS];
-
-static void register_callback(void (*callback)(void *), int fd, void *private)
-{
-	struct pollfd e = { fd, POLLIN, 0};
-
-	if (poll_items == MAX_POLL_ITEMS)
-		panic("Max poll items reached\n");
-
-	poll_callback[poll_items] = callback;
-	pfd[poll_items] = e;
-	poll_private[poll_items] = private;
-	poll_items++;
-}
-
 static void setup_timed_events(void)
 {
 	now = timestamp();
@@ -5715,67 +5418,6 @@ static void arm_channels(struct core_inf
 }
 
 
-static int event_loop(void)
-{
-	int64_t timeout;
-	int events = 0;
-	unsigned long t;
- 
-	arm_channels(NULL);
-	setup_timed_events();
-
-loop:
-	if (terminated)
-		goto out;
-
-	timeout = time_to_next_event();
-	if (timeout) {
-		/*
-		 * If we come from processing poll events then
-		 * give priority to more poll event processing
-		 */
-		if ((timeout <= 0 && events == 0) ||
-			       timeout < -(long)milliseconds(10))
-
-			timeout = run_events();
-
-	}
-	
-	if (timeout <= 0 || timeout > (long)seconds(10))
-		timeout = seconds(10);
- 
- 	events = poll(pfd, poll_items, (timeout + ONE_MILLISECOND/2) / ONE_MILLISECOND);
-
-	if (terminated)
-		goto out;
-
-	if (events < 0) {
-		logg(LOG_WARNING, "Poll failed with error=%s\n", errname());
-		goto out;
-	}
-
-	if (events == 0)
-		goto loop;
-
-	for(t = 0; t < poll_items; t++)
-		if (pfd[t].revents & POLLIN)
-			poll_callback[t](poll_private[t]);
-
-	goto loop;
-out:
-	return 0;
-}
-
-/*
- * Daemon Management functions
- */
-
-static void terminate(int x)
-{
-	terminated = true;
-}
-
-
 static void update_status(int x)
 {
 	update_requested = true;
@@ -6495,12 +6137,17 @@ static void tsi_cmd(char *parameters)
 
 static void event_cmd(char *parameters)
 {
+	char buffer[4000];
+	int n;
+
 	printf("Scheduled events on the high latency thread\n");
 	printf("-------------------------------------------\n");
 
-	for(struct timed_event *z = next_event; z; z = z->next) {
-		printf("%ldms %s\n", (z->time - timestamp()) / ONE_MILLISECOND, z->text);
-	}
+	n = get_timer_list(buffer, '\n');
+	if (n)
+		printf("%s\n", buffer);
+	else
+		printf("No events.\n");
 }
 
 static int log_interval;
@@ -6587,7 +6234,7 @@ static void console_input(void *private)
 
 	if (ret == 0) {
 		printf("\n");
-		terminated = true;
+		terminate(0);
 		return;
 	}
 
@@ -6707,8 +6354,11 @@ int main(int argc, char **argv)
 	send_queue_monitor(NULL);
 
 	start_cores();
+	arm_channels(NULL);
+	setup_timed_events();
 
-	event_loop();
+	if (event_loop() <0)
+		logg(LOG_ERR, "Event Loop failed with %s\n", errname());
 
 	stop_cores();
 
Index: rdma-core/ib2roce/sched.c
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/sched.c
@@ -0,0 +1,340 @@
+/*
+ * RDMA Infiniband to ROCE Bridge or Gateway
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <threads.h>
+#include <numa.h>
+#include <stdatomic.h>
+#include <sys/ioctl.h>
+#include <poll.h>
+#include <sys/mman.h>
+
+
+#include "errno.h"
+#include "interfaces.h"
+#include "cli.h"
+#include "sched.h"
+
+/* Timestamp in nanoseconds */
+uint64_t timestamp(void)
+{
+	struct timespec t;
+
+	clock_gettime(CLOCK_REALTIME, &t);
+	return t.tv_sec * ONE_SECOND + t.tv_nsec;
+}
+
+struct core_info core_infos[MAX_CORE];
+
+thread_local uint64_t now;
+thread_local struct core_info *current = NULL;
+
+int cores = 0;
+bool latency = false;
+
+static bool terminated = false;
+
+/*
+ * Logic to support building a pollfd table for the event loop
+ */
+#define MAX_POLL_ITEMS 20
+
+unsigned poll_items = 0;
+
+static struct pollfd pfd[MAX_POLL_ITEMS];
+static void (*poll_callback[MAX_POLL_ITEMS])(void *);
+void *poll_private[MAX_POLL_ITEMS];
+
+void register_callback(event_callback *callback, int fd, void *private)
+{
+	struct pollfd e = { fd, POLLIN, 0};
+
+	if (poll_items == MAX_POLL_ITEMS)
+		abort();
+
+	poll_callback[poll_items] = callback;
+	pfd[poll_items] = e;
+	poll_private[poll_items] = private;
+	poll_items++;
+}
+
+/* Events are timed according to nanoseconds in the current epoch */
+struct timed_event {
+	uint64_t time;          /* When should it occur */
+	event_callback *callback;       /* function to run */
+	void *private;
+	struct timed_event *next;       /* The following event */
+	const char *text;
+};
+
+/* Event queues for each of the threads */
+thread_local static struct timed_event *next_event;
+
+int64_t time_to_next_event(void)
+{
+	if (next_event)
+		return (long)next_event->time - (long)timestamp();
+	else
+		return 0;
+}
+
+int get_timer_list(char *buf, char separator)
+{
+	int n = 0;
+
+	for(struct timed_event *z = next_event; z; z = z->next)
+		n += sprintf(buf + n, "%ldms%c", (z->time - timestamp()) / ONE_MILLISECOND, separator);
+
+	return n;
+}
+
+void add_event(uint64_t time, event_callback *callback, void *private, const char *text)
+{
+	struct timed_event *t;
+	struct timed_event *prior = NULL;
+	struct timed_event *new_event;
+
+	new_event = calloc(1, sizeof(struct timed_event));
+	new_event->time = time;
+	new_event->callback = callback;
+	new_event->private = private;
+	new_event->text = text;
+
+	for(t = next_event; t && time > t->time; t = t->next)
+		prior = t;
+
+	new_event->next = t;
+
+	if (prior)
+		prior->next = new_event;
+	else
+		next_event = new_event;
+}
+
+/*
+ * Run the next event if availabe and return the time till the next event
+ * or 0 if there is none
+ */
+uint64_t run_events(void)
+{
+	while (next_event) {
+		struct timed_event *te = next_event;
+
+		now = timestamp();
+
+		if (te->time > now + ONE_MICROSECOND)
+			return te->time - now;
+
+		/* Time is up for an event */
+		next_event = te->next;
+		te->callback(te->private);
+		free(te);
+	}
+	return 0;
+}
+
+
+void terminate(int x)
+{
+	terminated = true;
+}
+
+int event_loop(void)
+{
+	int64_t timeout;
+	int events = 0;
+
+	while (!terminated) {
+
+		timeout = time_to_next_event();
+		if (timeout) {
+			/*
+			 * If we come from processing poll events then
+			 * give priority to more poll event processing
+			 */
+			if ((timeout <= 0 && events == 0) ||
+				       timeout < -(long)milliseconds(10))
+
+				timeout = run_events();
+
+		}
+
+		if (timeout <= 0 || timeout > (long)seconds(10))
+			timeout = seconds(10);
+
+	 	events = poll(pfd, poll_items, (timeout + ONE_MILLISECOND/2) / ONE_MILLISECOND);
+
+		if (events < 0)
+			return - 1;
+
+		if (events > 0) {
+			unsigned t;
+
+			for(t = 0; t < poll_items; t++)
+				if (pfd[t].revents & POLLIN)
+					poll_callback[t](poll_private[t]);
+		}
+	}
+	return 0;
+}
+
+int busy_event_loop(event_callback *callback, void *private)
+{
+
+
+	while (!terminated) {
+		cpu_relax();
+		callback(private);
+		run_events();
+	}
+	return 0;
+}
+
+
+static void channel_zap(struct rdma_channel *c)
+{
+	c->last_snapshot = 0;
+	c->max_pps_in = 0;
+	c->max_pps_out = 0;
+	c->cq_high = 0;
+
+	for(int k = 0; k < nr_stats; k++)
+		c->stats[k] = 0;
+
+	if (cores) {
+		for(unsigned i = 0; i < cores; i++) {
+			struct core_info *ci = core_infos + i;
+
+			if (latency) {
+				ci->samples = 0;
+				ci->max_latency = 0;
+				ci->min_latency = 0;
+				ci->sum_latency = 0;
+			}
+
+		}
+	}
+}
+
+
+static void zap_cmd(char *parameters)
+{
+	for(struct i2r_interface *i = i2r; i <i2r + NR_INTERFACES; i++) if (i->context) {
+		if (i->multicast)
+			channel_zap(i->multicast);
+#ifdef UNICAST
+		if (i->ud)
+			channel_zap(i->ud);
+		if (i->raw)
+			channel_zap(i->raw);
+		if (i->qp1)
+			channel_zap(i->qp1);
+#endif
+	}
+	printf("Ok\n");
+}
+
+static void event_cmd(char *parameters)
+{
+	char buffer[4000];
+	int n;
+
+	printf("Scheduled events on the high latency thread\n");
+	printf("-------------------------------------------\n");
+
+	n = get_timer_list(buffer, '\n');
+	if (n)
+		printf("%s\n", buffer);
+	else
+		printf("No events.\n");
+}
+
+static void core_cmd(char *parameters) {
+	if (!parameters) {
+		if (cores) {
+			unsigned i;
+
+			for(i = 0; i < cores; i++) {
+				unsigned j;
+				struct core_info *ci = core_infos + i;
+
+				printf("Core %d: NUMA=%d", i, ci->numa_node);
+				if (latency)
+					printf(" Loops over 5usecs=%u Average=%luns, Max=%uns, Min=%uns\n",
+						ci->samples, ci->samples ? ci->sum_latency / ci->samples : 0,
+						ci->max_latency, ci->min_latency);
+
+				for (j = 0; j < ci->nr_channels; j++)
+					channel_stat(ci->channel + j);
+			}
+		} else
+			printf("No cores active. ib2roce operates in single threaded mode.\n");
+	} else
+		printf("Dynamic reseetting of the core config not supported.\n");
+}
+
+
+static void core_set(char *optarg)
+{
+	cores = atoi(optarg);
+	if (cores > 8)
+		panic("More than 8 cores\n");
+}
+
+__attribute__((constructor))
+static void sched_init(void)
+{
+	register_concom("zap", true, 0, "Clear counters", zap_cmd );
+	register_concom("cores", true, 1, "Setup and list core configuration", core_cmd);
+	register_concom("events", true,	0, "Show scheduler event queue", event_cmd);
+	register_option("cores", required_argument, 'k', core_set,
+			"<nr>", "Spin on the given # of cores");
+}
+
Index: rdma-core/ib2roce/sched.h
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/sched.h
@@ -0,0 +1,113 @@
+#ifndef IB2ROCE_SCHED_H
+#define IB2ROCE_SCHED_H
+/*
+ * RDMA Infiniband to ROCE Bridge or Gateway
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <threads.h>
+#include "ring.h"
+#include "channel.h"
+
+/* Time keeping */
+#define ONE_SECOND (1000000000UL)
+#define ONE_MILLISECOND (ONE_SECOND/1000UL)
+#define ONE_MICROSECOND (1000UL)
+
+#define seconds(x) ((x)*ONE_SECOND)
+#define milliseconds(x) ((x)*ONE_MILLISECOND)
+
+uint64_t timestamp(void);
+extern thread_local uint64_t now;
+
+/*
+ * Core layout
+ *
+ * The basic ib2roce thread is outside of the cores here running
+ * in high latency mode which is used for management and for all
+ * activities not pushed to the polling cores.
+ *
+ * Cores always contain pairs of QPs on both interfaces. That reduces
+ * lock contention and optimizes the behavior overall.
+ *
+ */
+#define MAX_CORE 8
+#define MAX_CQS_PER_CORE 4
+
+enum core_state { core_off, core_init, core_running, core_err, nr_core_states };
+
+struct core_info {
+	unsigned nr_channels;
+	struct rdma_channel channel[MAX_CQS_PER_CORE];
+	/* Statistics */
+	unsigned samples;
+	long sum_latency;
+	unsigned max_latency;
+	unsigned min_latency;
+	struct ring ring;
+	/* Rarely used */
+	enum core_state state;
+	int numa_node;
+	pthread_t thread;                       /* Thread */
+	pthread_attr_t attr;
+};
+
+extern int cores;
+
+extern struct core_info core_infos[];
+
+extern thread_local struct core_info *current;
+
+#define cpu_relax()	asm volatile("rep; nop")
+
+typedef void event_callback(void *);
+void add_event(uint64_t when, event_callback *callback, void *private, const char *text);
+void register_callback(event_callback *callback, int fd, void *private);
+
+int64_t time_to_next_event(void);	/* Time till next event */
+uint64_t run_events(void);	/* Run events that are scheduled */
+int event_loop(void);		/* Enter loop running events and servicing fd callbacks */
+int busy_event_loop(event_callback *callback, void *private);	/* Enter loop running events and servicing fd callbacks */
+void terminate(int x);		/* Terminate the event loop */
+
+int get_timer_list(char *b, char separator);	/* List the timers and put the data into the buffer */
+
+#endif
Index: rdma-core/ib2roce/CMakeLists.txt-NO_MSTFLINT
===================================================================
--- rdma-core.orig/ib2roce/CMakeLists.txt-NO_MSTFLINT
+++ rdma-core/ib2roce/CMakeLists.txt-NO_MSTFLINT
@@ -7,6 +7,9 @@ rdma_executable(ib2roce
   hash.c
   errno.c
   ring.c
+  sched.c
+  channel.c
+  logging.c
 )
 target_link_libraries(ib2roce LINK_PRIVATE
   ibverbs
Index: rdma-core/ib2roce/ring.h
===================================================================
--- rdma-core.orig/ib2roce/ring.h
+++ rdma-core/ib2roce/ring.h
@@ -1,3 +1,6 @@
+#ifndef IB2ROCE_RING
+#define IB2ROCE_RING
+
 /*
  * RDMA Infiniband to ROCE Bridge or Gateway
  *
@@ -55,3 +58,5 @@ int ring_get(struct ring *r, char *msg,
 
 void ring_test(void);
 
+#endif
+
Index: rdma-core/ib2roce/channel.h
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/channel.h
@@ -0,0 +1,141 @@
+#ifndef IB2ROCE_CHANNEL
+#define IB2ROCE_CHANNEL
+
+/*
+ * RDMA Gateway Interface definitions
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <numa.h>
+#include <stdatomic.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <rdma/rdma_cma.h>
+#include <infiniband/ib.h>
+#include <infiniband/verbs.h>
+#include <poll.h>
+#include <sys/mman.h>
+
+#include "fifo.h"
+
+enum interfaces { INFINIBAND, ROCE, NR_INTERFACES };
+
+extern const char *interfaces_text[NR_INTERFACES];
+
+enum stats { packets_received, packets_sent, packets_bridged, packets_invalid, packets_queued,
+		join_requests, join_failure, join_success,
+		leave_requests,
+		pgm_dup, pgm_odata, pgm_rdata, pgm_spm, pgm_nak, pgm_ack,
+		nr_stats
+};
+
+extern const char *stats_text[nr_stats];
+
+enum channel_type { channel_rdmacm, channel_ud, channel_qp1,
+	channel_raw, channel_ibraw,
+	channel_packet, channel_incoming,
+	channel_err, nr_channel_types };
+
+struct buf;
+
+typedef void receive_callback(struct buf *);
+
+/*
+ * Channel data stucture,
+ *
+ * Channels may be associated with a core on which a busyloop runs.
+ *
+ * Therefore changes to variables may only be made from code
+ * running on that core if multithreading is active.
+ */
+struct rdma_channel {
+	struct i2r_interface *i;	/* The network interface of this channel */
+	struct core_info *core;		/* Core the channel is on or NULL if comp_events is used */
+	receive_callback *receive;
+	struct ibv_cq *cq;		/* Every channel has a distinct CQ */
+	struct ibv_qp *qp;		/* All of the ibv_xxes are pointing to the interface versions if this is not a rdmacm channel */
+	struct ibv_mr *mr;
+	struct ibv_comp_channel *comp_events;
+	struct ibv_pd *pd;
+	struct ibv_flow *flow;
+	unsigned int active_receive_buffers;
+	unsigned int active_send_buffers;	/* if the sender is on a different core than the receiver then we have a race condition for the buffers */
+	unsigned int cq_high;		/* Largest number of CQs taken from the queue */
+	unsigned int nr_cq;		/* Number of items for the CQ */
+	unsigned int nr_send;		/* Maximum number of write buffers to use */
+	unsigned int nr_receive;	/* Number of read buffer to post */
+	unsigned stats[nr_stats];
+	enum channel_type type;
+	struct fifo send_queue;		/* Packets that were deferred for write */
+	bool listening;			/* rdmacm Channel is listening for connections */
+	const char *text;
+	struct rdma_unicast *ru;	/* Only rdmacm */
+	struct rdma_cm_id *id;		/* Only rdmacm */
+	struct sockaddr *bindaddr;	/* Only rdmacm */
+	struct ibv_qp_attr attr;	/* Only !rdmacm */
+	int fh;				/* Only channel_packet */
+	uint64_t last_snapshot;		/* when was the last snapshot taken */
+	unsigned last_received, last_sent;
+	unsigned pps_in, pps_out;	/* Rate in the last interval */
+	unsigned max_pps_in, max_pps_out; /* Max Rate seen */
+};
+
+static inline void st(struct rdma_channel *c, enum stats s)
+{
+	c->stats[s]++;
+}
+
+int channel_stats(char *b, struct rdma_channel *c, const char *interface, const char *type);
+void channel_stat(struct rdma_channel *c);
+
+#endif
+
Index: rdma-core/ib2roce/channel.c
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/channel.c
@@ -0,0 +1,130 @@
+/*
+ * RDMA channel implementation
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <numa.h>
+#include <stdatomic.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <rdma/rdma_cma.h>
+#include <infiniband/ib.h>
+#include <infiniband/verbs.h>
+#include <poll.h>
+#include <sys/mman.h>
+
+
+#include "fifo.h"
+#include "interfaces.h"
+#include "channel.h"
+#include "cli.h"
+
+const char *interfaces_text[NR_INTERFACES] = { "Infiniband", "ROCE" };
+
+const char *stats_text[nr_stats] = {
+	"PacketsReceived", "PacketsSent", "PacketsBridged", "PacketsInvalid", "PacketsQueued",
+	"JoinRequests", "JoinFailures", "JoinSuccess", "LeaveRequests",
+	"pgmdup", "pgm_odata", "pgm_rdata", "pgm_spm", "pgm_nak"
+};
+
+
+int channel_stats(char *b, struct rdma_channel *c, const char *interface, const char *type)
+{
+	int n = 0;
+	int j;
+
+	n += sprintf(b + n, "\nChannel %s(%s):\n", interface, type);
+
+	for(j =0; j < nr_stats; j++)
+		if (c->stats[j]) {
+			n += sprintf(b + n, "%s=%u\n", stats_text[j], c->stats[j]);
+	}
+	return n;
+}
+
+void channel_stat(struct rdma_channel *c)
+{
+	printf(" Channel %s: ActiveRecvBuffers=%u/%u ActiveSendBuffers=%u/%u CQ_high=%u SendQ=%u\n", c->text,
+		c->active_receive_buffers, c->nr_receive, c->active_send_buffers, c->nr_send, c->cq_high, fifo_items(&c->send_queue));
+
+	if (c->last_snapshot && (c->max_pps_in || c->max_pps_out))
+		printf(" pps_in=%d pps_out=%d max_pps_in=%d max_pps_out=%d\n",
+				c->pps_in, c->pps_out, c->max_pps_in, c->max_pps_out);
+
+	for(int k = 0; k < nr_stats; k++)
+		if (c->stats[k])
+			printf(" %s=%u", stats_text[k], c->stats[k]);
+
+	printf("\n");
+}
+
+static void channels_cmd(char *parameters)
+{
+	for(struct i2r_interface *i = i2r; i <i2r + NR_INTERFACES; i++) if (i->context) {
+		if (i->multicast)
+			channel_stat(i->multicast);
+#ifdef UNICAST
+		if (i->ud)
+			channel_stat(i->ud);
+		if (i->raw)
+			channel_stat(i->raw);
+		if (i->qp1)
+			channel_stat(i->qp1);
+#endif
+	}
+}
+
+__attribute__((constructor))
+static void channel_init(void)
+{
+	register_concom("channels", true, 0, "Print information about communication channels", channels_cmd);
+}
Index: rdma-core/ib2roce/logging.c
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/logging.c
@@ -0,0 +1,105 @@
+/*
+ * Logging support to syslog or console
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syslog.h>
+#include <execinfo.h>
+#include "sched.h"
+#include "ring.h"
+#include "logging.h"
+
+int loglevel = LOG_INFO;
+bool background;
+
+
+__attribute__ ((format (printf, 2, 3)))
+void logg(int prio, const char *fmt, ...)
+{
+	va_list valist;
+
+	if ((prio & 0x7) > loglevel)
+		return;
+
+	va_start(valist, fmt);
+
+	if (current) {
+		int n;
+		char b[150];
+		b[0] = '0' + prio;
+
+		n = vsnprintf(b + 1, 149, fmt, valist);
+		ring_put(&current->ring, b, n);
+
+	} else if (background)
+		vsyslog(prio, fmt, valist);
+	else
+		vprintf(fmt, valist);
+}
+
+#define NR_FRAMES 100
+__attribute__ ((format (printf, 1, 2)))
+void panic(const char *fmt, ...)
+{
+	va_list valist;
+	void *frames[NR_FRAMES];
+	int nrframes;
+	int j;
+	char **strings;
+
+	printf("IB2ROCE Panic: ");
+	va_start(valist, fmt);
+	vprintf(fmt, valist);
+
+	nrframes = backtrace(frames, NR_FRAMES);
+	strings = backtrace_symbols(frames, nrframes);
+
+	for( j= 0; j < nrframes; j++) {
+		printf("%d. %s\n", j, strings[j]);
+	}
+	free(strings);
+	abort();
+}
+
Index: rdma-core/ib2roce/logging.h
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/logging.h
@@ -0,0 +1,64 @@
+#ifndef IB2ROCE_LOGGING
+#define IB2ROCE_LOGGING
+/*
+ * Logging interface
+ *
+ * (C) 2021-2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+__attribute__ ((format (printf, 2, 3)))
+void logg(int prio, const char *fmt, ...);
+
+__attribute__ ((format (printf, 1, 2)))
+void panic(const char *fmt, ...);
+
+extern bool background;
+
+char *__hexbytes(char *b, uint8_t *q, unsigned len, char separator);
+
+char *hexbytes(uint8_t *q, unsigned len, char separator);
+
+static inline char *_hexbytes(uint8_t *q, unsigned len)
+{
+	return hexbytes(q, len, ' ');
+}
+
+#endif
+
