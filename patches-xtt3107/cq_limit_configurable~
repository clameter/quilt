Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -110,17 +110,21 @@ static bool testing = false;		/* Run som
 static bool packet_socket = false;	/* Do not use RAW QPs, use packet socket instead */
 static bool loopback_blocking = true;	/* Ask for loopback blocking on Multicast QPs */
 static int drop_packets = 0;		/* Packet dropper */
-static int rate = 0;			/* Limit sending rate */
+static int hwrate = 0;			/* Limit sending rate using the NIC */
+static int swrate = 0;			/* Limit sending rate through software */
 
-/* Timestamp in milliseconds */
+/* Timestamp in microseconds */
 static unsigned long timestamp(void)
 {
 	struct timespec t;
 
 	clock_gettime(CLOCK_REALTIME, &t);
-	return t.tv_sec * 1000 + (t.tv_nsec + 500000) / 1000000;
+	return t.tv_sec * 1000 + (t.tv_nsec + 500) / 1000;
 }
 
+#define seconds(x) ((x)*1000000)
+#define miliseconds(x) ((x)*1000)
+
 #define cpu_relax()	asm volatile("rep; nop")
 
 __attribute__ ((format (printf, 2, 3)))
@@ -240,7 +244,7 @@ static const char *stats_text[nr_stats]
 	"LeaveRequests"
 };
 
-unsigned max_wc_cqs = 100;
+int max_wc_cqs = 100;
 
 static int cq_high = 0;	/* Largest batch of CQs encountered */
 
@@ -598,11 +602,13 @@ const char *mc_text[NR_MC_STATUS] = { "I
  */
 static struct mc {
 	struct in_addr addr;
+	struct ah_info ai[2];
+	unsigned long last_sent[2];	/* Timestamp of last packet sent */
+	unsigned pending[2];		/* Number of packets to be sent later */
 	enum mc_status status[2];
 	bool sendonly[2];
 	bool beacon;
 	uint16_t port;
-	struct ah_info ai[2];
 	struct sockaddr *sa[2];
 	struct mgid_signature *mgid_mode;
 	const char *text;
@@ -3417,8 +3423,8 @@ redo:
 		return NULL;
 	}
 
-	if (rate)
-		at->static_rate = rate;
+	if (hwrate)
+		at->static_rate = hwrate;
 
 	ah = ibv_create_ah(i->pd, at);
 	if (!ah) {
@@ -3682,11 +3688,27 @@ static void receive_multicast(struct buf
 	if (drop_packets && (c->stats[packets_received] % drop_packets) == drop_packets - 1)
 		return;
 
+	if (swrate && m->last_sent[in]) {
+		unsigned long tdiff = timestamp() - m->last_sent[in];
+
+		if (tdiff < ((m->pending[in] + 1) * 10000000) / swrate) {
+			m->pending[in]++;
+			add_event(m->last_sent[in] + (m->pending[in] * 1000000) / swrate, send_delayed);
+			/* Schedule packet somewhere */
+			return;
+
+		}
+	} 
 	ret = send_to(i2r[in ^ 1].multicast, buf->cur, buf->end - buf->cur, m->ai + (in ^ 1), false, 0, buf);
 
 	if (ret)
 		return;
 
+	if (swrate) {
+		m->last_sent[in] = timestamp();
+		m->pending[in] = 0;
+	}
+
 	st(c, packets_bridged);
 	return;
 
@@ -4777,7 +4799,7 @@ static void status_write(void)
 		close(fd);
 		update_requested = false;
 	}
-	add_event(timestamp() + 60000, status_write);
+	add_event(timestamp() + seconds(60), status_write);
 }
 
 #define BEACON_MCS 500
@@ -4958,7 +4980,7 @@ static void beacon_send(void)
 		send_buf_to(i, buf, beacon_sin);
 
 	}
-	add_event(timestamp() + 10000, beacon_send);
+	add_event(timestamp() + miliseconds(10), beacon_send);
 }
 
 static void beacon_setup(const char *opt_arg)
@@ -4991,7 +5013,7 @@ static void beacon_setup(const char *opt
 		} else
 			beacon_mc = m;
 	}
-	add_event(timestamp() + 1000, beacon_send);
+	add_event(timestamp() + miliseconds(1), beacon_send);
 }
 
 /* Events are timed according to milliseconds in the current epoch */
@@ -5031,7 +5053,7 @@ static void check_joins(void)
 	/* Maintenance tasks */
 	if (nr_mc > active_mc) {
 		join_processing();
-		add_event(timestamp() + 1000, check_joins);
+		add_event(timestamp() + miliseconds(1), check_joins);
 	} else {
 		/*
 		 * All active so start listening. This means we no longer
@@ -5060,7 +5082,7 @@ static void logging(void)
 	const char *events;
 
 	for(struct timed_event *z = next_event; z; z = z->next)
-		n += sprintf(buf + n, "%ldms,", z->time - timestamp());
+		n += sprintf(buf + n, "%ldms,", (z->time - timestamp()) / 1000);
 
 	if (n > 0)
 		buf[n -1] = 0;
@@ -5069,7 +5091,7 @@ static void logging(void)
 
 	if (n == 0) {
 		events = "No upcoming events";
-		interval = 10000;
+		interval = seconds(10);
 	} else {
 		snprintf(buf2, sizeof(buf2), "Events in %s", buf);
 		events = buf2;
@@ -5366,18 +5388,20 @@ struct enable_option {
 	const char *off_value;
 	const char *description;
 } enable_table[] = {
-{	"buffers", NULL, &nr_buffers, "1000000", "10000","Number of 8k buffers allocated for packet processing" },
-{	"bridging", &bridging, NULL, "on", "off", "Forwarding of packets between interfaces" },
-{	"drop", NULL, &drop_packets, "100", "0", "Drop multicast packets. The value is the number of multicast packets to send before dropping" },
-{	"flow", &flow_steering, NULL, "on", "off", "Enable flow steering to limit the traffic on the RAW sockets [Experimental, Broken]" },
-{	"huge", &huge, NULL, "on", "off", "Enable the use of Huge memory for the packet pool" }, 
-{	"loopbackprev", &loopback_blocking, NULL, "on", "off", "Multicast loopback prevention of the NIC" },
-{	"packetsocket", &packet_socket, NULL, "on", "off", "Use a packet socket instead of a RAW QP to capure IB/ROCE traffic" },
-{	"pgm",NULL,(int *)&pgm_mode, "on", "off", "PGM processing mode (0=None, 1= Passtrough, 2=DLR, 3=Resend with new TSI" },
-{	"rate", NULL, &rate, "2", "0", "Make RDMA limit the output speed 2 =2.5GBPS 5 = 5GBPS 3 = 10GBPS ...(see enum ibv_rate)" },
-{ 	"raw", 	&raw, NULL, "on", "off", "Use of RAW sockets to capture SIDR Requests. Avoids having to use a patched kernel" },
-{	"unicast", &unicast, NULL, "on", "off", "Processing of unicast packets with QP1 handling of SIDR REQ/REP" },
-{	NULL, NULL, NULL, NULL, NULL, NULL }
+{ "buffers",		NULL, &nr_buffers,	"1000000", "10000",	"Number of 8k buffers allocated for packet processing" },
+{ "bridging",		&bridging, NULL,	"on", "off",	"Forwarding of packets between interfaces" },
+{ "drop",		NULL,	&drop_packets,	"100", "0",	"Drop multicast packets. The value is the number of multicast packets to send before dropping" },
+{ "flow",		&flow_steering, NULL,	"on", "off",	"Enable flow steering to limit the traffic on the RAW sockets [Experimental, Broken]" },
+{ "huge",		&huge,	NULL,		"on", "off",	"Enable the use of Huge memory for the packet pool" }, 
+{ "packetspp",		NULL,	&max_wc_cqs,	"1000", "10",	"Packets per Poll: The number of packets to receive per Poll of the RDMA stack" },
+{ "loopbackprev",	&loopback_blocking, NULL, "on", "off",	"Multicast loopback prevention of the NIC" },
+{ "packetsocket",	&packet_socket, NULL,	"on", "off",	"Use a packet socket instead of a RAW QP to capure IB/ROCE traffic" },
+{ "pgm",		NULL,	(int *)&pgm_mode, "on", "off",	"PGM processing mode (0=None, 1= Passtrough, 2=DLR, 3=Resend with new TSI" },
+{ "hwrate",		NULL,	&hwrate,	"2", "0",	"Set the speed in the RDMA NIC to limit the output speed 2 =2.5GBPS 5 = 5GBPS 3 = 10GBPS ...(see enum ibv_rate)" },
+{ "swrate",		NULL, &swrate,		"1000", "0",	"Limit the packets per second to be sent to an endpoint (0=off)" },
+{ "raw",		&raw,	NULL,		"on", "off",	"Use of RAW sockets to capture SIDR Requests. Avoids having to use a patched kernel" },
+{ "unicast",		&unicast, NULL,		"on", "off",	"Processing of unicast packets with QP1 handling of SIDR REQ/REP" },
+{ NULL, NULL, NULL, NULL, NULL, NULL }
 };
 
 static void enable(char *option, bool enable)
