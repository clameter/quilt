Index: rdma-core/ib2roce/CMakeLists.txt
===================================================================
--- rdma-core.orig/ib2roce/CMakeLists.txt
+++ rdma-core/ib2roce/CMakeLists.txt
@@ -17,6 +17,23 @@ rdma_sbin_executable(ib2roce
   cli.c
   pgm.c
 )
+
+rdma_executable(mclisten
+  mclisten.c
+  fifo.c
+  hash.c
+  errno.c
+  sched.c
+  channel.c
+  logging.c
+  locking.c
+  buffers.c
+  multicast.c
+  interfaces.c
+  cli.c
+  pgm.c
+)
+
 target_link_libraries(ib2roce LINK_PRIVATE
   ibverbs
   ibumad
@@ -37,7 +54,9 @@ add_link_options("--export-dynamic")
 rdma_man_pages(
   man/ib2roce.1
   man/ib2roce.7
-  )
+  man/bcom.1
+  man/mclisten.1
+)
 
 rdma_subst_install(FILES "ib2roce.service.in"
   DESTINATION "${CMAKE_INSTALL_SYSTEMD_SERVICEDIR}"
Index: rdma-core/ib2roce/logging.c
===================================================================
--- rdma-core.orig/ib2roce/logging.c
+++ rdma-core/ib2roce/logging.c
@@ -57,8 +57,14 @@
 #include "pgm.h"
 
 int loglevel = LOG_INFO;
+#ifdef DAEMON
 bool background;
 bool systemd;
+#else
+#define background false
+#define systemd false
+#define current NULL
+#endif
 
 static void __logg(int prio, const char *fmt, va_list valist)
 {
@@ -180,6 +186,7 @@ bool sum_stats(unsigned *stats, struct i
 	return r;
 }
 
+#ifdef DAEMON
 void brief_status(FILE *out)
 {
 	char buf[4000];
@@ -308,14 +315,20 @@ static void systemd_set(char *optarg)
 	systemd = true;
 }
 
+#endif
+
 __attribute__((constructor))
 static void logging_init(void)
 {
+#ifdef DAEMON
 	register_concom("continuous", false, 1,	"Print continous status in specified interval",	continous_cmd);
 	register_concom("status", true, 0, "Print a brief status", statuscmd);
+#endif
 	register_enable("loglevel", true, NULL, &loglevel, "5","3", NULL,
 		"Log output to console (0=EMERG, 1=ALERT, 2=CRIT, 3=ERR, 4=WARN, 5=NOTICE, 6=INFO, 7=DEBUG)");
 	register_option("verbose", no_argument, 'v', verbose_set, NULL, "Increase logging detail");
+#ifdef DAEMON
 	register_option("systemd", no_argument, 's', systemd_set, NULL, "Operate from systemd");
+#endif
 }
 
Index: rdma-core/ib2roce/mclisten.c
===================================================================
--- /dev/null
+++ rdma-core/ib2roce/mclisten.c
@@ -0,0 +1,320 @@
+/*
+ * RDMA Multicast Listener
+ *
+ * (C) 2022 Christoph Lameter <cl@linux.com>
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * $Author: Christoph Lameter [cl@linux.com]$
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <ctype.h>
+
+#include "errno.h"
+#include "fifo.h"
+#include "ring.h"
+#include "hash.h"
+#include "sched.h"
+#include "logging.h"
+#include "locking.h"
+#include "buffers.h"
+#include "multicast.h"
+#include "interfaces.h"
+#include "cli.h"
+#include "pgm.h"
+
+/* Globals */
+
+static bool verbose = false;		/* More detailed info */
+
+static char *payload_dump(uint8_t *p)
+{
+	return _hexbytes(p, 48);
+}
+
+static char *grh_str(struct ibv_grh *g)
+{
+        struct iphdr *i = (void *)g + 20;
+        char xbuf[INET6_ADDRSTRLEN];
+        char xbuf2[INET6_ADDRSTRLEN];
+        char hbuf1[30];
+        char hbuf2[30];
+        struct in_addr saddr, daddr;
+        static char buf[200];
+
+        saddr.s_addr = i->saddr;
+        daddr.s_addr = i->daddr;
+
+        strcpy(hbuf1, inet_ntoa(saddr));
+        strcpy(hbuf2, inet_ntoa(daddr));
+
+        sprintf(buf, "GRH(flow=%u Len=%u next_hdr=%u hop_limit=%u SGID=%s DGID:%s SourceIP=%s DestIP=%s)",
+                        ntohl(g->version_tclass_flow), ntohs(g->paylen), g->next_hdr, g->hop_limit,
+                        inet_ntop(AF_INET6, &g->sgid, xbuf2, INET6_ADDRSTRLEN),
+                        inet_ntop(AF_INET6, &g->dgid, xbuf, INET6_ADDRSTRLEN),
+                        hbuf1, hbuf2);
+	return buf;
+}
+
+#ifdef HAVE_MSTFLINT
+static void shutdown_sniffer(int arg) {
+	struct i2r_interface *i = i2r + INFINIBAND;
+
+	if (clear_ib_sniffer(i->port, i->raw->qp))
+		logg(LOG_ERR, "Failed to switch off sniffer mode on %s\n", i->raw->text);
+	else
+		logg(LOG_NOTICE, "ABORT handler cleared the sniffer mode on Infiniband\n");
+}
+#endif
+
+/* Delayed packet send due to traffic shaping */
+static void delayed_send(void *private)
+{
+	struct buf *buf = private;
+	struct rdma_channel *c = buf->c;
+	struct mc_interface *mi = buf->mi;
+	int ret;
+
+	mi->delayed++;
+	mi->pending--;
+	if (!mi->pending) {
+		/*
+		 * The last pending packet so we are off rate limiting.
+		 */
+		c->i->mc_rate_limited--;
+		mi->burst = 0;
+		mi->last_sent = timestamp();
+	}
+
+	ret = send_to(c, buf->cur, buf->end - buf->cur, &mi->ai, buf->imm_valid, buf->imm, buf);
+	if (!ret)
+		st(c, packets_bridged);
+	buf->mi = NULL;
+}
+
+/*
+ * We have an GRH header so the packet has been processed by the RDMA
+ * Subsystem and we can take care of it using the RDMA calls
+ */
+void receive_multicast(struct buf *buf)
+{
+	struct mc *m;
+	struct rdma_channel *c = buf->c;
+	enum interfaces in = c->i - i2r;
+	struct ib_addr *dgid = (struct ib_addr *)&buf->grh.dgid.raw;
+	struct in_addr dest_addr;
+	int ret;
+	const char *reason = NULL;
+
+	if (!buf->grh_valid) {
+		logg(LOG_WARNING, "No GRH on %s. Packet discarded: %s\n",
+			c->text, payload_dump(buf->cur));
+		goto invalid_packet;
+	}
+
+	if (buf->ip_valid) {
+
+		if (!IN_MULTICAST(ntohl(buf->ip.daddr))) {
+			reason = "Unicast Packet";
+			goto discardit;
+		}
+
+		if (buf->ip.saddr == c->i->if_addr.sin_addr.s_addr) {
+			reason = "Loopback Packet";
+			goto discardit;
+		}
+
+		
+		if (!__valid_addr(c->i, buf->ip.saddr)) {
+			reason = "Packet not originating on source interface";
+			goto discardit;
+		}
+
+	} else /* ! buf->ip_valid */ {
+
+		if (buf->grh.dgid.raw[0] !=  0xff) {
+			reason = "Unicast Packet";
+			goto discardit;
+		}
+
+		if (memcmp(&buf->grh.sgid, &c->i->gid, sizeof(union ibv_gid)) == 0) {
+
+			reason = "Loopback Packet";
+			goto discardit;
+		}
+
+		/*
+		 * ib2roce sets the hop limit to 1. By default is it
+		 * 0. So if hop_limit is set then another ib2roce already
+		 * processed the packet. Discard it.
+		 */
+		if (buf->grh.hop_limit) {
+			reason = "Hop Limit !=0 discard packet.\n";
+			goto discardit;
+		}
+	}
+
+	dest_addr.s_addr = dgid->sib_addr32[3];
+	m = hash_lookup_mc(dest_addr);
+
+	logg(LOG_DEBUG, "From %s: MC=%s\n", c->text, inet_ntoa(dest_addr));
+
+	if (!m) {
+		logg(LOG_INFO, "Discard Packet: Multicast group %s not found\n",
+			inet_ntoa(dest_addr));
+		goto invalid_packet;
+	}
+
+	if (m->interface[in].sendonly) {
+
+		logg(LOG_INFO, "Discard Packet: Received data from Sendonly MC group %s from %s\n",
+			m->text, c->text);
+		goto invalid_packet;
+	}
+
+	if (!buf->ip_valid) {
+		unsigned char *mgid = buf->grh.dgid.raw;
+		unsigned short signature = ntohs(*(unsigned short*)(mgid + 2));
+
+		if (!mgid_check(m, signature)) {
+			logg(LOG_INFO, "Discard Packet: MGID multicast signature(%x)  mismatch. MGID=%s\n",
+					signature, inet6_ntoa(mgid));
+			goto invalid_packet;
+		}
+
+	}
+
+	if (m->callback) {
+		m->callback(m, in, buf);
+		return;
+	}
+
+	if (!m->enabled)
+		return;
+
+	if (pgm_mode != pgm_none) {
+		uint8_t *saved = buf->cur;
+		if (!pgm_process(c, m, buf))
+			return;
+		buf->cur = saved;
+	}
+
+	return;
+
+discardit:    
+	logg(LOG_DEBUG, "%s on multicast channel %s: GRH=%s %s\n", reason, c->text, grh_str(&buf->grh), payload_dump(buf->cur));
+
+invalid_packet:
+	st(c, packets_invalid);
+}
+
+static void setup_timed_events(void)
+{
+	uint64_t x;
+	int ret;
+
+	now = timestamp();
+
+	if (background)
+		logging(NULL);
+
+	calculate_pps(NULL);
+
+	check_joins(&i2r[INFINIBAND].channels, &i2r[ROCE].channels);
+}
+
+static void setup_termination_signals(void)
+{
+	signal(SIGINT, terminate);
+	signal(SIGTERM, terminate);
+	signal(SIGHUP, terminate);	/* Future: Reload a potential config file */
+}
+
+static void verbose_set(char *optarg)
+{
+	verbose = true;
+}
+
+static void setup_options(void)
+{
+	register_option("verbose", no_argument, 'v', verbose_set,
+		       	NULL, "Print more details");
+}
+
+__attribute__((constructor))
+static void options_init(void)
+{
+	setup_options();
+	setup_enable();
+}
+
+int main(int argc, char **argv)
+{
+	int ret = 0;
+
+	parse_options(argc, argv);
+
+	setup_termination_signals();
+
+	ret = find_rdma_devices();
+	if (ret)
+		return ret;
+
+	logg (LOG_NOTICE, "%s device = %s:%d, %s device = %s:%d. Multicast Groups=%d MGIDs=%s Buffers=%u\n",
+			interfaces_text[INFINIBAND], i2r[INFINIBAND].rdma_name, i2r[INFINIBAND].port,
+			interfaces_text[ROCE], i2r[ROCE].rdma_name, i2r[ROCE].port,
+			nr_mc, mgid_text(NULL), nr_buffers);
+
+	init_buf();	/* Setup interface registers memmory */
+
+	setup_interface(INFINIBAND);
+
+	post_receive_buffers();
+
+	arm_channels(NULL);
+	setup_timed_events();
+
+	if (event_loop() < 0)
+		logg(LOG_ERR, "Event Loop failed with %s\n", errname());
+
+	shutdown_roce();
+	closelog();
+
+	return EXIT_SUCCESS;
+}
Index: rdma-core/ib2roce/channel.h
===================================================================
--- rdma-core.orig/ib2roce/channel.h
+++ rdma-core/ib2roce/channel.h
@@ -53,7 +53,11 @@ extern unsigned default_port;
 
 extern bool latency;
 
+#ifdef DAEMON
 enum interfaces { INFINIBAND, ROCE, NR_INTERFACES };
+#else
+enum interfaces { RDMA_INTERFACE, NR_INTERFACES };
+#endif
 
 extern const char *interfaces_text[NR_INTERFACES];
 
Index: rdma-core/ib2roce/interfaces.h
===================================================================
--- rdma-core.orig/ib2roce/interfaces.h
+++ rdma-core/ib2roce/interfaces.h
@@ -53,6 +53,7 @@
 
 #define MAX_GID 20
 
+#ifdef DAEMON
 extern char *ib_name, *roce_name;
 
 extern bool bridging;
@@ -63,6 +64,10 @@ extern int rrate;	/* Software delay per
 extern int irate;	/* Software delay per message for Infiniband */
 extern int max_rburst;	/* Dont delay until # of packets for ROCE */
 extern int max_iburst;	/* Dont delay until # of packets for Infiniband */
+#else
+#define bridging false
+#define unicast false
+#endif
 
 #define MAX_CHANNELS_PER_INTERFACE 10
 
