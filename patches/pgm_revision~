Index: rdma-core/ib2roce/pgm.c
===================================================================
--- rdma-core.orig/ib2roce/pgm.c
+++ rdma-core/ib2roce/pgm.c
@@ -124,75 +124,6 @@ static const uint64_t type_to_cat = {
         (cat_nak << (13 * PGM_TYPE_SHIFT))		/* PGM_ACK         = 0x0d */
 };
 
-/*
- * Parse the options following the PGM header.
- *
- * opt is an array indexed by the option type pointing to the data associated with that option.
- *
- * The function returns a pointer at the end of options where the data would start. It returns
- * NULL if the pgm_type is invalid or the options consistency check fails.
- *
- */
-static uint8_t *pgm_opt_parse(struct pgm_header *h, uint16_t *opt_offset)
-{
-	uint8_t *a;
-	uint8_t *opt_start;
-	uint8_t *pgm_start = (uint8_t *)h;
-	struct pgm_opt_header *poh;
-	uint16_t *v;
-	unsigned total_opt_length;
-	unsigned n;
-	enum cat_type c;
-
-	memset(opt_offset, 0, sizeof(uint16_t) * MAX_PGM_OPT);
-
-	n = h->pgm_type & PGM_TYPE_MASK;
-
-	/* Extract category from type_to_cat */
-	c = (type_to_cat >> (n * PGM_TYPE_SHIFT)) & ((1 << PGM_TYPE_SHIFT) -1);
-
-	if (n >= MAX_PGM_TYPE || c == cat_invalid)
-		/* Unsupported PGM type */
-		return NULL;
-
-	/* move to the beginning of the options. Extracts size for category from cat_sizes */
-	a = pgm_start + sizeof(struct pgm_header) + ((cat_sizes >> (c * PGM_CAT_SHIFT)) & ((1 << PGM_CAT_SHIFT) -1));
-
-	if (!(h->pgm_type & PGM_OPT_PRESENT))
-		/* No options available */
-		return a;
-
-	opt_start = a;
-
-	do {
-		poh = (struct pgm_opt_header *)a;
-		n = poh->opt_type & PGM_OPT_MASK;
-
-		/*
-		 * RFC3208 allows ignoring options that are unknown.
-		 * We just skip over unknown data
-		 */
-		if (n <= MAX_PGM_OPT)
-			opt_offset[n] = (a + sizeof(struct pgm_opt_header)) - pgm_start;
-
-		a += poh->opt_length;
-
-	} while (!(poh->opt_type & PGM_OPT_END));
-
-	v = (uint16_t *)(opt_offset[PGM_OPT_LENGTH] + pgm_start);
-
-	if (!v)
-		/* No OPT_LENGTH specified */
-		return a;
-
-	total_opt_length = ntohs(*v);
-	if (a - opt_start != total_opt_length)
-		/* Corrupted option list */
-		return NULL;
-
-	return a;
-}
-
 static void init_pgm_streams(void)
 {
 	struct i2r_interface *i;
@@ -276,6 +207,13 @@ bool pgm_process(struct rdma_channel *c,
 	int ret = true;
 	uint8_t *a;
 	uint16_t opt_offset[MAX_PGM_OPT];
+	unsigned total_opt_length;
+	uint8_t *opt_start;
+	uint8_t *pgm_start = (uint8_t *)(buf->cur);
+	struct pgm_opt_header *poh;
+	uint16_t *v;
+	unsigned n;
+	enum cat_type ct;
 
 	header = (void *)buf->cur;
 
@@ -288,6 +226,7 @@ bool pgm_process(struct rdma_channel *c,
 	if (pgm_mode < pgm_passthrough)
 		return true;
 
+	/* Process common values in PGM header and lookup the sender */
 	tdsu = ntohs(header->pgm.pgm_tsdu_length);
 
 	tsi.mcgroup = m->addr;
@@ -298,12 +237,64 @@ bool pgm_process(struct rdma_channel *c,
 
 	s = hash_find(i->pgm_tsi_hash, &tsi);
 
-	a = pgm_opt_parse(&header->pgm, opt_offset);
-	if (!a) {
-		logg(LOG_NOTICE, "%s: Invalid PGM type/Options %x. Packet Skipped.\n", text, header->pgm.pgm_type);
+	/*
+	 * Parse the options following the PGM header.
+	 *
+	 * opt is an array indexed by the option type pointing to the data associated with that option.
+	 *
+	 */
+	memset(opt_offset, 0, sizeof(uint16_t) * MAX_PGM_OPT);
+
+	n = header->pgm.pgm_type & PGM_TYPE_MASK;
+
+	/* Extract category from type_to_cat */
+	ct = (type_to_cat >> (n * PGM_TYPE_SHIFT)) & ((1 << PGM_TYPE_SHIFT) -1);
+
+	if (n >= MAX_PGM_TYPE || ct == cat_invalid) {
+		logg(LOG_NOTICE, "%s: Invalid PGM type %x. Packet Skipped.\n", s->text, n);
 		return false;
 	}
 
+	/* move to the beginning of the options. Extracts size for category from cat_sizes */
+	a = pgm_start + sizeof(struct pgm_header) + ((cat_sizes >> (ct * PGM_CAT_SHIFT)) & ((1 << PGM_CAT_SHIFT) -1));
+
+	opt_start = a;
+
+	if (!(header->pgm.pgm_type & PGM_OPT_PRESENT))
+		goto options_done;
+
+
+	do {
+		poh = (struct pgm_opt_header *)a;
+		n = poh->opt_type & PGM_OPT_MASK;
+
+		/*
+		 * RFC3208 allows ignoring options that are unknown.
+		 * We just skip over unknown data
+		 */
+		if (n <= MAX_PGM_OPT)
+			opt_offset[n] = (a + sizeof(struct pgm_opt_header)) - pgm_start;
+
+		a += poh->opt_length;
+
+	} while (!(poh->opt_type & PGM_OPT_END));
+
+	v = (uint16_t *)(opt_offset[PGM_OPT_LENGTH] + pgm_start);
+
+	if (!v) {
+		logg(LOG_NOTICE, "%s: packet without OPT_LENGTH.\n", s->text);
+		total_opt_length = 0;
+	} else {
+
+		total_opt_length = ntohs(*v);
+		if (a - opt_start != total_opt_length) {
+			logg(LOG_NOTICE, "%s: total_opt_length mismatch. Packet skipped\n", s->text);
+			/* Corrupted option list */
+			return false;
+		}
+	}
+
+options_done:
 	buf->cur += sizeof(struct pgm_header);
 	switch (header->pgm.pgm_type & PGM_TYPE_MASK) {
 		case PGM_SPM:		/* Multicast downstream */
