Index: rdma-core/ib2roce/ib2roce.c
===================================================================
--- rdma-core.orig/ib2roce/ib2roce.c
+++ rdma-core/ib2roce/ib2roce.c
@@ -87,7 +87,7 @@
 
 #define BEACON_SIGNATURE 0xD3ADB33F
 
-// #define HAVE_MSTFLINT
+#define HAVE_MSTFLINT
 // #define DEBUG
 
 /* Globals */
@@ -1036,7 +1036,7 @@ static int post_receive(struct rdma_chan
 		ret = ibv_post_recv(c->qp, &recv_wr, &recv_failure);
 		if (ret) {
 			free_buffer(buf);
-			logg(LOG_WARNING, "ibv_post_recv failed: %s\n", errname());
+			logg(LOG_WARNING, "ibv_post_recv failed: %s:%s\n", c->text, errname());
 			break;
                 }
 		c->active_receive_buffers++;
@@ -1223,7 +1223,7 @@ static void start_channel(struct rdma_ch
 				logg(LOG_CRIT, "ibv_modify_qp: Error when moving %s to RTS state. %s\n", c->text, errname());
 
 		}
-		logg(LOG_NOTICE, "QP %s moved to state %s\n", c->text,  send ? "RTS/RTR" : "RTR" );
+		logg(LOG_NOTICE, "QP %s moved to state %s: QPN=0x%x\n", c->text,  send ? "RTS/RTR" : "RTR", c->qp->qp_num);
 	}
 }
 
@@ -2066,9 +2066,9 @@ static int send_ud(struct rdma_channel *
 		errno = - ret;
 		logg(LOG_WARNING, "Failed to post send: %s on %s\n", errname(), c->text);
 	} else
-		if (log_packets > 1)
-			logg(LOG_NOTICE, "RDMA Send to QPN=%x QKEY=%x %d bytes\n",
-				wr.wr.ud.remote_qpn, wr.wr.ud.remote_qkey, len);
+//	if (log_packets > 1)
+			logg(LOG_NOTICE, "RDMA Send to %s QPN=%x QKEY=%x %d bytes AH=%p handle=%x pd=%p context=%p\n", c->text,
+				wr.wr.ud.remote_qpn, wr.wr.ud.remote_qkey, len, ah, ah->handle, ah->pd, ah->context);
 
 	return ret;
 }
@@ -2438,7 +2438,7 @@ static struct endpoint *at_to_ep(struct
 		at->static_rate = id->route.path_rec->rate;
 		if (at->port_num != id->port_num)
 			abort();
-
+		logg(LOG_NOTICE, "%s: Lookup of %s resulted in DLID=%x\n", i->text, inet_ntoa(addr), at->dlid);
 		rdma_destroy_id(id);
 
 	}
@@ -2455,10 +2455,11 @@ static struct endpoint *at_to_ep(struct
 
 	ah = ibv_create_ah(i->pd, at);
 	if (!ah) {
-		logg(LOG_ERR, "create_ep: Failed to create Endpoint on %s: %s. IP=%s\n",
+		logg(LOG_ERR, "at_to_ep: Failed to create Endpoint on %s: %s. IP=%s\n",
 				i->text, errname(), inet_ntoa(ep->addr));
 		return NULL;
-	}
+	} else
+		logg(LOG_NOTICE, "at_to_ep %s: AH=%p created from %s LID =%x\n", i->text, ah, inet_ntoa(addr), at->dlid); 
 
 	ep = calloc(1, sizeof(struct endpoint));
 	if (!ep)
@@ -2588,7 +2589,7 @@ static void learn_source_address(struct
 	if (!unicast)	/* If unicast is not enabled then dont bother to gather addresses */
 		return;
 
-	buf_to_ep(buf);
+	buf->source_ep = buf_to_ep(buf);
 }
 
 /*
@@ -3126,12 +3127,12 @@ static void receive_raw(struct buf *buf)
 		w->sl = ib_get_sl(ih);
 
 		if (!unicast_lid(w->slid) || !lids[1]) {
-			logg(LOG_NOTICE, "SLID=%x DLID=%x\n", lids[0], lids[1]);
 			reason = "Invalid SLID or DLID";
 			goto discard;
 		}
 
 		if (w->slid == i->port_attr.lid) {
+			logg(LOG_NOTICE, "SLID=%x DLID=%x len=%d %s\n", lids[0], lids[1], len, payload_dump(buf->raw));
 			reason = "Unicast Loopback";
 			goto discard;
 		}
@@ -3360,9 +3361,14 @@ static void receive_ud(struct buf *buf)
 	struct endpoint *e;
 	struct forward *f;
 	struct ibv_wc *w = buf->w;
+	char e_str[40];
 
 	learn_source_address(buf);
 
+	if (!buf->grh_valid)
+		/* Even if there is no GRH there is space reserved at the beginning for UD packets */
+		buf->cur += 40;
+
 	e = buf->source_ep;
 	if (!e) {
 		reason = "Cannot find endpoint";
